import {
  hash
} from "./chunk-UZDZS3XV.js";
import {
  DOMBooleanAttributes,
  ELEMENT_IS_NAMESPACED,
  ELEMENT_PRESERVE_ATTRIBUTE_CASE,
  FILENAME,
  HYDRATION_END,
  HYDRATION_START,
  HYDRATION_START_ELSE,
  RawTextElements,
  UNINITIALIZED,
  disallowed_paragraph_contents,
  interactive_elements,
  is_tag_valid_with_parent,
  validate_store
} from "./chunk-ULFNOIAW.js";
import {
  DEV
} from "./chunk-IP2U24VQ.js";
import {
  subscribe_to_store
} from "./chunk-GV2RBXNV.js";
import {
  is_promise,
  noop
} from "./chunk-ZHNMYN2P.js";

// node_modules/svelte/src/escaping.js
var ATTR_REGEX = /[&"<]/g;
var CONTENT_REGEX = /[&<]/g;
function escape_html(value, is_attr) {
  const str = String(value ?? "");
  const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern.lastIndex = 0;
  let escaped = "";
  let last = 0;
  while (pattern.test(str)) {
    const i = pattern.lastIndex - 1;
    const ch = str[i];
    escaped += str.substring(last, i) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last = i + 1;
  }
  return escaped + str.substring(last);
}

// node_modules/svelte/src/internal/server/context.js
var current_component = null;
function push(fn) {
  current_component = { p: current_component, c: null, d: null };
  if (DEV) {
    current_component.function = fn;
  }
}
function pop() {
  var component = (
    /** @type {Component} */
    current_component
  );
  var ondestroy = component.d;
  if (ondestroy) {
    on_destroy.push(...ondestroy);
  }
  current_component = component.p;
}

// node_modules/svelte/src/internal/server/hydration.js
var BLOCK_OPEN = `<!--${HYDRATION_START}-->`;
var BLOCK_OPEN_ELSE = `<!--${HYDRATION_START_ELSE}-->`;
var BLOCK_CLOSE = `<!--${HYDRATION_END}-->`;
var EMPTY_COMMENT = `<!---->`;

// node_modules/svelte/src/internal/server/blocks/html.js
function html(value) {
  var open = DEV ? `<!--${hash(String(value ?? ""))}-->` : "<!---->";
  return `${open}${value}<!---->`;
}

// node_modules/svelte/src/internal/server/dev.js
var parent = null;
var seen;
function stringify(element2) {
  if (element2.filename === null) return `\`<${element2.tag}>\``;
  return `\`<${element2.tag}>\` (${element2.filename}:${element2.line}:${element2.column})`;
}
function print_error(payload, parent2, child) {
  var message = `${stringify(parent2)} cannot contain ${stringify(child)}

This can cause content to shift around as the browser repairs the HTML, and will likely result in a \`hydration_mismatch\` warning.`;
  if ((seen ?? (seen = /* @__PURE__ */ new Set())).has(message)) return;
  seen.add(message);
  console.error(message);
  payload.head.out += `<script>console.error(${JSON.stringify(message)})<\/script>`;
}
function push_element(payload, tag, line, column) {
  var filename = (
    /** @type {import('#server').Component} */
    current_component.function[FILENAME]
  );
  var child = { tag, parent, filename, line, column };
  if (parent !== null && !is_tag_valid_with_parent(tag, parent.tag)) {
    print_error(payload, parent, child);
  }
  if (interactive_elements.has(tag)) {
    let element2 = parent;
    while (element2 !== null) {
      if (interactive_elements.has(element2.tag)) {
        print_error(payload, element2, child);
        break;
      }
      element2 = element2.parent;
    }
  }
  if (disallowed_paragraph_contents.includes(tag)) {
    let element2 = parent;
    while (element2 !== null) {
      if (element2.tag === "p") {
        print_error(payload, element2, child);
        break;
      }
      element2 = element2.parent;
    }
  }
  parent = child;
}
function pop_element() {
  parent = /** @type {Element} */
  parent.parent;
}

// node_modules/svelte/src/internal/server/index.js
var INVALID_ATTR_NAME_CHAR_REGEX = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
var VoidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "menuitem",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function copy_payload({ out, css, head: head2 }) {
  return {
    out,
    css: new Set(css),
    head: {
      title: head2.title,
      out: head2.out
    }
  };
}
function assign_payload(p1, p2) {
  p1.out = p2.out;
  p1.head = p2.head;
}
function element(payload, tag, attributes_fn = noop, children_fn = noop) {
  payload.out += "<!---->";
  if (tag) {
    payload.out += `<${tag} `;
    attributes_fn();
    payload.out += `>`;
    if (!VoidElements.has(tag)) {
      children_fn();
      if (!RawTextElements.includes(tag)) {
        payload.out += EMPTY_COMMENT;
      }
      payload.out += `</${tag}>`;
    }
  }
  payload.out += "<!---->";
}
var on_destroy = [];
function render(component, options = {}) {
  const payload = { out: "", css: /* @__PURE__ */ new Set(), head: { title: "", out: "" } };
  const prev_on_destroy = on_destroy;
  on_destroy = [];
  payload.out += BLOCK_OPEN;
  if (options.context) {
    push();
    current_component.c = options.context;
  }
  component(payload, options.props ?? {}, {}, {});
  if (options.context) {
    pop();
  }
  payload.out += BLOCK_CLOSE;
  for (const cleanup of on_destroy) cleanup();
  on_destroy = prev_on_destroy;
  let head2 = payload.head.out + payload.head.title;
  for (const { hash: hash2, code } of payload.css) {
    head2 += `<style id="${hash2}">${code}</style>`;
  }
  return {
    head: head2,
    html: payload.out,
    body: payload.out
  };
}
function head(payload, fn) {
  const head_payload = payload.head;
  head_payload.out += BLOCK_OPEN;
  fn(head_payload);
  head_payload.out += BLOCK_CLOSE;
}
function attr(name, value, is_boolean = false) {
  if (value == null || !value && is_boolean || value === "" && name === "class") return "";
  const assignment = is_boolean ? "" : `="${escape_html(value, true)}"`;
  return ` ${name}${assignment}`;
}
function css_props(payload, is_html, props, component, dynamic = false) {
  const styles = style_object_to_string(props);
  if (is_html) {
    payload.out += `<div style="display: contents; ${styles}">`;
  } else {
    payload.out += `<g style="${styles}">`;
  }
  if (dynamic) {
    payload.out += "<!---->";
  }
  component();
  if (is_html) {
    payload.out += `<!----></div>`;
  } else {
    payload.out += `<!----></g>`;
  }
}
function spread_attributes(attrs, classes, styles, flags = 0) {
  if (styles) {
    attrs.style = attrs.style ? style_object_to_string(merge_styles(
      /** @type {string} */
      attrs.style,
      styles
    )) : style_object_to_string(styles);
  }
  if (classes) {
    const classlist = attrs.class ? [attrs.class] : [];
    for (const key in classes) {
      if (classes[key]) {
        classlist.push(key);
      }
    }
    attrs.class = classlist.join(" ");
  }
  let attr_str = "";
  let name;
  const is_html = (flags & ELEMENT_IS_NAMESPACED) === 0;
  const lowercase = (flags & ELEMENT_PRESERVE_ATTRIBUTE_CASE) === 0;
  for (name in attrs) {
    if (typeof attrs[name] === "function") continue;
    if (name[0] === "$" && name[1] === "$") continue;
    if (INVALID_ATTR_NAME_CHAR_REGEX.test(name)) continue;
    if (lowercase) {
      name = name.toLowerCase();
    }
    const is_boolean = is_html && DOMBooleanAttributes.includes(name);
    attr_str += attr(name, attrs[name], is_boolean);
  }
  return attr_str;
}
function spread_props(props) {
  const merged_props = {};
  let key;
  for (let i = 0; i < props.length; i++) {
    const obj = props[i];
    for (key in obj) {
      merged_props[key] = obj[key];
    }
  }
  return merged_props;
}
function stringify2(value) {
  return typeof value === "string" ? value : value == null ? "" : value + "";
}
function style_object_to_string(style_object) {
  return Object.keys(style_object).filter(
    /** @param {any} key */
    (key) => style_object[key] != null && style_object[key] !== ""
  ).map(
    /** @param {any} key */
    (key) => `${key}: ${escape_html(style_object[key], true)};`
  ).join(" ");
}
function add_styles(style_object) {
  const styles = style_object_to_string(style_object);
  return styles ? ` style="${styles}"` : "";
}
function merge_styles(attribute, styles) {
  var merged = {};
  if (attribute) {
    for (var declaration of attribute.split(";")) {
      var i = declaration.indexOf(":");
      var name = declaration.slice(0, i).trim();
      var value = declaration.slice(i + 1).trim();
      if (name !== "") merged[name] = value;
    }
  }
  for (name in styles) {
    merged[name] = styles[name];
  }
  return merged;
}
function store_get(store_values, store_name, store) {
  var _a;
  if (DEV) {
    validate_store(store, store_name.slice(1));
  }
  if (store_name in store_values && store_values[store_name][0] === store) {
    return store_values[store_name][2];
  }
  (_a = store_values[store_name]) == null ? void 0 : _a[1]();
  store_values[store_name] = [store, null, void 0];
  const unsub = subscribe_to_store(
    store,
    /** @param {any} v */
    (v) => store_values[store_name][2] = v
  );
  store_values[store_name][1] = unsub;
  return store_values[store_name][2];
}
function store_set(store, value) {
  store.set(value);
  return value;
}
function mutate_store(store_values, store_name, store, expression) {
  store_set(store, store_get(store_values, store_name, store));
  return expression;
}
function update_store(store_values, store_name, store, d = 1) {
  let store_value = store_get(store_values, store_name, store);
  store.set(store_value + d);
  return store_value;
}
function update_store_pre(store_values, store_name, store, d = 1) {
  const value = store_get(store_values, store_name, store) + d;
  store.set(value);
  return value;
}
function unsubscribe_stores(store_values) {
  for (const store_name in store_values) {
    store_values[store_name][1]();
  }
}
function value_or_fallback(value, fallback) {
  return value === void 0 ? fallback() : value;
}
async function value_or_fallback_async(value, fallback) {
  return value === void 0 ? fallback() : value;
}
function slot(payload, slot_fn, slot_props, fallback_fn) {
  if (slot_fn === void 0) {
    if (fallback_fn !== null) {
      fallback_fn();
    }
  } else {
    slot_fn(payload, slot_props);
  }
}
function rest_props(props, rest) {
  const rest_props2 = {};
  let key;
  for (key in props) {
    if (!rest.includes(key)) {
      rest_props2[key] = props[key];
    }
  }
  return rest_props2;
}
function sanitize_props(props) {
  const { children, $$slots, ...sanitized } = props;
  return sanitized;
}
function sanitize_slots(props) {
  const sanitized = {};
  if (props.children) sanitized.default = true;
  for (const key in props.$$slots) {
    sanitized[key] = true;
  }
  return sanitized;
}
function bind_props(props_parent, props_now) {
  var _a;
  for (const key in props_now) {
    const initial_value = props_parent[key];
    const value = props_now[key];
    if (initial_value === void 0 && value !== void 0 && ((_a = Object.getOwnPropertyDescriptor(props_parent, key)) == null ? void 0 : _a.set)) {
      props_parent[key] = value;
    }
  }
}
function await_block(promise, pending_fn, then_fn) {
  if (is_promise(promise)) {
    promise.then(null, noop);
    if (pending_fn !== null) {
      pending_fn();
    }
  } else if (then_fn !== null) {
    then_fn(promise);
  }
}
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function inspect(args, inspect2 = console.log) {
  inspect2("init", ...args);
}
function once(get_value) {
  let value = (
    /** @type {V} */
    UNINITIALIZED
  );
  return () => {
    if (value === UNINITIALIZED) {
      value = get_value();
    }
    return value;
  };
}

export {
  escape_html,
  push,
  pop,
  html,
  push_element,
  pop_element,
  VoidElements,
  copy_payload,
  assign_payload,
  element,
  on_destroy,
  render,
  head,
  attr,
  css_props,
  spread_attributes,
  spread_props,
  stringify2 as stringify,
  add_styles,
  merge_styles,
  store_get,
  store_set,
  mutate_store,
  update_store,
  update_store_pre,
  unsubscribe_stores,
  value_or_fallback,
  value_or_fallback_async,
  slot,
  rest_props,
  sanitize_props,
  sanitize_slots,
  bind_props,
  await_block,
  ensure_array_like,
  inspect,
  once
};
//# sourceMappingURL=chunk-JK67KNG5.js.map
