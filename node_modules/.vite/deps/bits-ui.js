import {
  dequal
} from "./chunk-KXUD2J44.js";
import {
  nanoid
} from "./chunk-YPTH2STO.js";
import {
  $11d87f3f76e88657$export$b4a036af3fc0b032,
  $14e0f24ef4ac5c92$export$2061056d06d7cdf7,
  $14e0f24ef4ac5c92$export$629b0a497aa65267,
  $14e0f24ef4ac5c92$export$a18c89cbd24170ff,
  $14e0f24ef4ac5c92$export$a2258d9c4118825c,
  $14e0f24ef4ac5c92$export$a5a3b454ada2268e,
  $14e0f24ef4ac5c92$export$aa8b41735afcabd2,
  $14e0f24ef4ac5c92$export$ea39ec197993aef0,
  $35ea8db9cb2ccb90$export$99faa760c7908e4f,
  $35ea8db9cb2ccb90$export$ca871e8dbb80966f,
  $35ea8db9cb2ccb90$export$d3b7288e7994edea,
  $fae977aafc393c5c$export$588937bcd60ade55,
  $fae977aafc393c5c$export$6b862160d295c8e,
  $fae977aafc393c5c$export$fd7893f06e92a6a4,
  $fb18d541ea1ad717$export$ad991b66133851cf
} from "./chunk-EHR7CZJI.js";
import {
  arrow,
  autoUpdate,
  computePosition,
  flip,
  offset,
  shift,
  size
} from "./chunk-FLCUM7TW.js";
import {
  createFocusTrap
} from "./chunk-F75ECU5H.js";
import "./chunk-P43WOQ5F.js";
import {
  derived,
  get,
  readable,
  readonly,
  writable
} from "./chunk-HAUKTYWL.js";
import {
  createEventDispatcher,
  onDestroy,
  onMount
} from "./chunk-XTZQFBFI.js";
import {
  action,
  add_locations,
  bind_this,
  check_target,
  element,
  handle_lazy_img,
  hmr,
  if_block,
  init,
  legacy_api,
  legacy_rest_props,
  prop,
  remove_input_defaults,
  set_attributes,
  set_dynamic_element_attributes,
  set_style,
  setup_stores,
  slot,
  spread_props,
  store_get,
  store_unsub,
  transition
} from "./chunk-XPI6QZ3D.js";
import {
  bubble_event,
  default_slot
} from "./chunk-UZDZS3XV.js";
import {
  append,
  child,
  comment,
  event,
  first_child,
  replay_events,
  reset,
  set_text,
  sibling,
  template,
  text
} from "./chunk-M5JWWCYO.js";
import {
  FILENAME,
  ORIGINAL,
  deep_read_state,
  derived_safe_equal,
  get as get2,
  getContext,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  mark_module_end,
  mark_module_start,
  mutable_source,
  pop,
  push,
  set,
  setContext,
  source,
  template_effect,
  tick,
  validate_component,
  validate_dynamic_element_tag,
  validate_store,
  validate_void_dynamic_element
} from "./chunk-ULFNOIAW.js";
import "./chunk-IP2U24VQ.js";
import "./chunk-6IVNZR47.js";
import "./chunk-GV2RBXNV.js";
import "./chunk-ZHNMYN2P.js";
import {
  __export
} from "./chunk-M4H726CL.js";

// node_modules/bits-ui/dist/bits/accordion/index.js
var accordion_exports = {};
__export(accordion_exports, {
  Content: () => accordion_content_default,
  Header: () => accordion_header_default,
  Item: () => accordion_item_default,
  Root: () => accordion_default,
  Trigger: () => accordion_trigger_default
});

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/array.js
function back(array, index, increment, loop = true) {
  const previousIndex = index - increment;
  if (previousIndex <= 0) {
    return loop ? array[array.length - 1] : array[0];
  }
  return array[previousIndex];
}
function forward(array, index, increment, loop = true) {
  const nextIndex = index + increment;
  if (nextIndex > array.length - 1) {
    return loop ? array[0] : array[array.length - 1];
  }
  return array[nextIndex];
}
function next(array, index, loop = true) {
  if (index === array.length - 1) {
    return loop ? array[0] : array[index];
  }
  return array[index + 1];
}
function prev(array, currentIndex, loop = true) {
  if (currentIndex <= 0) {
    return loop ? array[array.length - 1] : array[0];
  }
  return array[currentIndex - 1];
}
function last(array) {
  return array[array.length - 1];
}
function wrapArray(array, startIndex) {
  return array.map((_, index) => array[(startIndex + index) % array.length]);
}
function toggle(item, array, compare = dequal) {
  const itemIdx = array.findIndex((innerItem) => compare(innerItem, item));
  if (itemIdx !== -1) {
    array.splice(itemIdx, 1);
  } else {
    array.push(item);
  }
  return array;
}
function chunk(arr, size2) {
  const result = [];
  for (let i = 0; i < arr.length; i += size2) {
    result.push(arr.slice(i, i + size2));
  }
  return result;
}
function isValidIndex(index, arr) {
  return index >= 0 && index < arr.length;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/style.js
function styleToString(style) {
  return Object.keys(style).reduce((str, key) => {
    if (style[key] === void 0)
      return str;
    return str + `${key}:${style[key]};`;
  }, "");
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/attr.js
function disabledAttr(disabled) {
  return disabled ? true : void 0;
}
var hiddenInputAttrs = {
  type: "hidden",
  "aria-hidden": true,
  hidden: true,
  tabIndex: -1,
  style: styleToString({
    position: "absolute",
    opacity: 0,
    "pointer-events": "none",
    margin: 0,
    transform: "translateX(-100%)"
  })
};
function portalAttr(portal) {
  if (portal !== null) {
    return "";
  }
  return void 0;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/store/lightable.js
function lightable(value) {
  function subscribe(run) {
    run(value);
    return () => {
    };
  }
  return { subscribe };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/makeElement.js
function getElementByMeltId(id) {
  if (!isBrowser)
    return null;
  const el = document.querySelector(`[data-melt-id="${id}"]`);
  return isHTMLElement(el) ? el : null;
}
var hiddenAction = (obj) => {
  return new Proxy(obj, {
    get(target, prop2, receiver) {
      return Reflect.get(target, prop2, receiver);
    },
    ownKeys(target) {
      return Reflect.ownKeys(target).filter((key) => key !== "action");
    }
  });
};
var isFunctionWithParams = (fn) => {
  return typeof fn === "function";
};
var emptyMeltElement = makeElement("empty");
function makeElement(name27, args) {
  const { stores, action: action2, returned } = args ?? {};
  const derivedStore = (() => {
    if (stores && returned) {
      return derived(stores, (values) => {
        const result = returned(values);
        if (isFunctionWithParams(result)) {
          const fn = (...args2) => {
            return hiddenAction({
              ...result(...args2),
              [`data-melt-${name27}`]: "",
              action: action2 ?? noop
            });
          };
          fn.action = action2 ?? noop;
          return fn;
        }
        return hiddenAction({
          ...result,
          [`data-melt-${name27}`]: "",
          action: action2 ?? noop
        });
      });
    } else {
      const returnedFn = returned;
      const result = returnedFn == null ? void 0 : returnedFn();
      if (isFunctionWithParams(result)) {
        const resultFn = (...args2) => {
          return hiddenAction({
            ...result(...args2),
            [`data-melt-${name27}`]: "",
            action: action2 ?? noop
          });
        };
        resultFn.action = action2 ?? noop;
        return lightable(resultFn);
      }
      return lightable(hiddenAction({
        ...result,
        [`data-melt-${name27}`]: "",
        action: action2 ?? noop
      }));
    }
  })();
  const actionFn = action2 ?? (() => {
  });
  actionFn.subscribe = derivedStore.subscribe;
  return actionFn;
}
function makeElementArray(name27, args) {
  const { stores, returned, action: action2 } = args;
  const { subscribe } = derived(stores, (values) => returned(values).map((value) => hiddenAction({
    ...value,
    [`data-melt-${name27}`]: "",
    action: action2 ?? noop
  })));
  const actionFn = action2 ?? (() => {
  });
  actionFn.subscribe = subscribe;
  return actionFn;
}
function createElHelpers(prefix4) {
  const name27 = (part) => part ? `${prefix4}-${part}` : prefix4;
  const attribute2 = (part) => `data-melt-${prefix4}${part ? `-${part}` : ""}`;
  const selector10 = (part) => `[data-melt-${prefix4}${part ? `-${part}` : ""}]`;
  const getEl = (part) => document.querySelector(selector10(part));
  return {
    name: name27,
    attribute: attribute2,
    selector: selector10,
    getEl
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/is.js
var isBrowser = typeof document !== "undefined";
var isFunction = (v) => typeof v === "function";
function isDocument(element2) {
  return element2 instanceof Document;
}
function isElement(element2) {
  return element2 instanceof Element;
}
function isHTMLElement(element2) {
  return element2 instanceof HTMLElement;
}
function isHTMLInputElement(element2) {
  return element2 instanceof HTMLInputElement;
}
function isHTMLLabelElement(element2) {
  return element2 instanceof HTMLLabelElement;
}
function isHTMLButtonElement(element2) {
  return element2 instanceof HTMLButtonElement;
}
function isElementDisabled(element2) {
  const ariaDisabled = element2.getAttribute("aria-disabled");
  const disabled = element2.getAttribute("disabled");
  const dataDisabled = element2.hasAttribute("data-disabled");
  if (ariaDisabled === "true" || disabled !== null || dataDisabled) {
    return true;
  }
  return false;
}
function isTouch(event2) {
  return event2.pointerType === "touch";
}
function isFocusVisible(element2) {
  return element2.matches(":focus-visible");
}
function isContentEditable(element2) {
  if (!isHTMLElement(element2))
    return false;
  return element2.isContentEditable;
}
function isNull(value) {
  return value === null;
}
function isNumberString(value) {
  if (isNaN(parseInt(value)))
    return false;
  return true;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isReadable(value) {
  return isObject(value) && "subscribe" in value;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/dom.js
function getTabbableNodes(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) {
    nodes.push(walker.currentNode);
  }
  return nodes;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/callbacks.js
function executeCallbacks(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}
function noop() {
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/event.js
function addEventListener(target, event2, handler, options) {
  const events = Array.isArray(event2) ? event2 : [event2];
  events.forEach((_event) => target.addEventListener(_event, handler, options));
  return () => {
    events.forEach((_event) => target.removeEventListener(_event, handler, options));
  };
}
function addMeltEventListener(target, event2, handler, options) {
  const events = Array.isArray(event2) ? event2 : [event2];
  if (typeof handler === "function") {
    const handlerWithMelt = withMelt((_event) => handler(_event));
    events.forEach((_event) => target.addEventListener(_event, handlerWithMelt, options));
    return () => {
      events.forEach((_event) => target.removeEventListener(_event, handlerWithMelt, options));
    };
  }
  return () => noop();
}
function dispatchMeltEvent(originalEvent) {
  const node = originalEvent.currentTarget;
  if (!isHTMLElement(node))
    return null;
  const customMeltEvent = new CustomEvent(`m-${originalEvent.type}`, {
    detail: {
      originalEvent
    },
    cancelable: true
  });
  node.dispatchEvent(customMeltEvent);
  return customMeltEvent;
}
function withMelt(handler) {
  return (event2) => {
    const customEvent = dispatchMeltEvent(event2);
    if (customEvent == null ? void 0 : customEvent.defaultPrevented)
      return;
    return handler(event2);
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/highlight.js
function addHighlight(element2) {
  element2.setAttribute("data-highlighted", "");
}
function removeHighlight(element2) {
  element2.removeAttribute("data-highlighted");
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/lifecycle.js
var safeOnMount = (fn) => {
  try {
    onMount(fn);
  } catch {
    return fn;
  }
};
var safeOnDestroy = (fn) => {
  try {
    onDestroy(fn);
  } catch {
    return fn;
  }
};

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/list.js
function getOptions(el) {
  return Array.from(el.querySelectorAll('[role="option"]:not([data-disabled])')).filter((el2) => isHTMLElement(el2));
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/locale.js
function getElemDirection(elem) {
  const style = window.getComputedStyle(elem);
  const direction = style.getPropertyValue("direction");
  return direction;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/object.js
function omit(obj, ...keys) {
  const result = {};
  for (const key of Object.keys(obj)) {
    if (!keys.includes(key)) {
      result[key] = obj[key];
    }
  }
  return result;
}
function stripValues(inputObject, toStrip, recursive) {
  return Object.fromEntries(Object.entries(inputObject).filter(([_, value]) => !dequal(value, toStrip)));
}
function removeUndefined(obj) {
  const result = {};
  for (const key in obj) {
    const value = obj[key];
    if (value !== void 0) {
      result[key] = value;
    }
  }
  return result;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/withGet.js
function withGet(store) {
  return {
    ...store,
    get: () => get(store)
  };
}
withGet.writable = function(initial) {
  const internal = writable(initial);
  let value = initial;
  return {
    subscribe: internal.subscribe,
    set(newValue) {
      internal.set(newValue);
      value = newValue;
    },
    update(updater) {
      const newValue = updater(value);
      internal.set(newValue);
      value = newValue;
    },
    get() {
      return value;
    }
  };
};
withGet.derived = function(stores, fn) {
  const subscribers = /* @__PURE__ */ new Map();
  const get3 = () => {
    const values = Array.isArray(stores) ? stores.map((store) => store.get()) : stores.get();
    return fn(values);
  };
  const subscribe = (subscriber) => {
    const unsubscribers = [];
    const storesArr = Array.isArray(stores) ? stores : [stores];
    storesArr.forEach((store) => {
      unsubscribers.push(store.subscribe(() => {
        subscriber(get3());
      }));
    });
    subscriber(get3());
    subscribers.set(subscriber, unsubscribers);
    return () => {
      const unsubscribers2 = subscribers.get(subscriber);
      if (unsubscribers2) {
        for (const unsubscribe of unsubscribers2) {
          unsubscribe();
        }
      }
      subscribers.delete(subscriber);
    };
  };
  return {
    get: get3,
    subscribe
  };
};

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/overridable.js
var overridable = (_store, onChange) => {
  const store = withGet(_store);
  const update = (updater, sideEffect) => {
    store.update((curr) => {
      const next2 = updater(curr);
      let res = next2;
      if (onChange) {
        res = onChange({ curr, next: next2 });
      }
      sideEffect == null ? void 0 : sideEffect(res);
      return res;
    });
  };
  const set2 = (curr) => {
    update(() => curr);
  };
  return {
    ...store,
    update,
    set: set2
  };
};

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/sleep.js
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/id.js
function generateId() {
  return nanoid(10);
}
function generateIds(args) {
  return args.reduce((acc, curr) => {
    acc[curr] = generateId();
    return acc;
  }, {});
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/keyboard.js
var kbd = {
  ALT: "Alt",
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  ARROW_UP: "ArrowUp",
  BACKSPACE: "Backspace",
  CAPS_LOCK: "CapsLock",
  CONTROL: "Control",
  DELETE: "Delete",
  END: "End",
  ENTER: "Enter",
  ESCAPE: "Escape",
  F1: "F1",
  F10: "F10",
  F11: "F11",
  F12: "F12",
  F2: "F2",
  F3: "F3",
  F4: "F4",
  F5: "F5",
  F6: "F6",
  F7: "F7",
  F8: "F8",
  F9: "F9",
  HOME: "Home",
  META: "Meta",
  PAGE_DOWN: "PageDown",
  PAGE_UP: "PageUp",
  SHIFT: "Shift",
  SPACE: " ",
  TAB: "Tab",
  CTRL: "Control",
  ASTERISK: "*",
  A: "a",
  P: "p"
};
var FIRST_KEYS = [kbd.ARROW_DOWN, kbd.PAGE_UP, kbd.HOME];
var LAST_KEYS = [kbd.ARROW_UP, kbd.PAGE_DOWN, kbd.END];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SELECTION_KEYS = [kbd.ENTER, kbd.SPACE];
var getNextKey = (dir = "ltr", orientation = "horizontal") => {
  return {
    horizontal: dir === "rtl" ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,
    vertical: kbd.ARROW_DOWN
  }[orientation];
};
var getPrevKey = (dir = "ltr", orientation = "horizontal") => {
  return {
    horizontal: dir === "rtl" ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,
    vertical: kbd.ARROW_UP
  }[orientation];
};
var getDirectionalKeys = (dir = "ltr", orientation = "horizontal") => {
  return {
    nextKey: getNextKey(dir, orientation),
    prevKey: getPrevKey(dir, orientation)
  };
};

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/debounce.js
function debounce(fn, wait = 500) {
  let timeout = null;
  return function(...args) {
    const later = () => {
      timeout = null;
      fn(...args);
    };
    timeout && clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/platform.js
var isDom = () => typeof window !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return (agent == null ? void 0 : agent.platform) ?? navigator.platform;
}
var pt = (v) => isDom() && v.test(getPlatform().toLowerCase());
var ua = (v) => isDom() && v.test(navigator.userAgent);
var isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;
var isMac = () => pt(/^mac/) && !isTouchDevice();
var isFirefox = () => ua(/firefox\//i);
var isApple = () => pt(/mac|iphone|ipad|ipod/i);
var isIos = () => isApple() && !isMac();

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/polygon/hull.js
function makeHull(points) {
  const newPoints = points.slice();
  newPoints.sort(POINT_COMPARATOR);
  return makeHullPresorted(newPoints);
}
function makeHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length == 1 && lowerHull.length == 1 && upperHull[0].x == lowerHull[0].x && upperHull[0].y == lowerHull[0].y)
    return upperHull;
  else
    return upperHull.concat(lowerHull);
}
function POINT_COMPARATOR(a, b) {
  if (a.x < b.x)
    return -1;
  else if (a.x > b.x)
    return 1;
  else if (a.y < b.y)
    return -1;
  else if (a.y > b.y)
    return 1;
  else
    return 0;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/polygon/index.js
function getPointsFromEl(el) {
  const rect = el.getBoundingClientRect();
  return [
    { x: rect.left, y: rect.top },
    { x: rect.right, y: rect.top },
    { x: rect.right, y: rect.bottom },
    { x: rect.left, y: rect.bottom }
  ];
}
function makeHullFromElements(els) {
  const points = els.flatMap((el) => getPointsFromEl(el));
  return makeHull(points);
}
function pointInPolygon(point, polygon) {
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > point.y !== yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/scroll.js
var LOCK_CLASSNAME = "data-melt-scroll-lock";
function assignStyle(el, style) {
  if (!el)
    return;
  const previousStyle = el.style.cssText;
  Object.assign(el.style, style);
  return () => {
    el.style.cssText = previousStyle;
  };
}
function setCSSProperty(el, property, value) {
  if (!el)
    return;
  const previousValue = el.style.getPropertyValue(property);
  el.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el.style.setProperty(property, previousValue);
    } else {
      el.style.removeProperty(property);
    }
  };
}
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function removeScroll(_document) {
  const doc = _document ?? document;
  const win = doc.defaultView ?? window;
  const { documentElement, body } = doc;
  const locked = body.hasAttribute(LOCK_CLASSNAME);
  if (locked)
    return noop;
  body.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const scrollbarSidePadding = win.getComputedStyle(body)[paddingProperty];
  const setStyle = () => assignStyle(body, {
    overflow: "hidden",
    [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
  });
  const setIOSStyle = () => {
    const { scrollX, scrollY, visualViewport } = win;
    const offsetLeft = (visualViewport == null ? void 0 : visualViewport.offsetLeft) ?? 0;
    const offsetTop = (visualViewport == null ? void 0 : visualViewport.offsetTop) ?? 0;
    const restoreStyle = assignStyle(body, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
    });
    return () => {
      restoreStyle == null ? void 0 : restoreStyle();
      win.scrollTo(scrollX, scrollY);
    };
  };
  const cleanups = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle()];
  return () => {
    cleanups.forEach((fn) => fn == null ? void 0 : fn());
    body.removeAttribute(LOCK_CLASSNAME);
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/store/derivedVisible.js
function derivedVisible(obj) {
  const { open, forceVisible, activeTrigger } = obj;
  return derived([open, forceVisible, activeTrigger], ([$open, $forceVisible, $activeTrigger]) => ($open || $forceVisible) && $activeTrigger !== null);
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/store/effect.js
function effect(stores, fn) {
  let cb = void 0;
  const destroy = derived(stores, (stores2) => {
    cb == null ? void 0 : cb();
    cb = fn(stores2);
  }).subscribe(noop);
  const unsub = () => {
    destroy();
    cb == null ? void 0 : cb();
  };
  safeOnDestroy(unsub);
  return unsub;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/store/toWritableStores.js
function toWritableStores(properties) {
  const result = {};
  Object.keys(properties).forEach((key) => {
    const propertyKey = key;
    const value = properties[propertyKey];
    result[propertyKey] = withGet(writable(value));
  });
  return result;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/rovingFocus.js
function handleRovingFocus(nextElement) {
  if (!isBrowser)
    return;
  sleep(1).then(() => {
    const currentFocusedElement = document.activeElement;
    if (!isHTMLElement(currentFocusedElement) || currentFocusedElement === nextElement)
      return;
    currentFocusedElement.tabIndex = -1;
    if (nextElement) {
      nextElement.tabIndex = 0;
      nextElement.focus();
    }
  });
}
function getFocusableElements() {
  return Array.from(document.querySelectorAll('a[href]:not([tabindex="-1"]), button:not([disabled]):not([tabindex="-1"]), input:not([disabled]):not([tabindex="-1"]), select:not([disabled]):not([tabindex="-1"]), textarea:not([disabled]):not([tabindex="-1"]), [tabindex]:not([tabindex="-1"])'));
}
function getNextFocusable(currentElement) {
  const focusableElements = getFocusableElements();
  const currentIndex = focusableElements.indexOf(currentElement);
  const nextIndex = currentIndex + 1;
  const nextElement = focusableElements[nextIndex];
  if (nextIndex < focusableElements.length && isHTMLElement(nextElement)) {
    return nextElement;
  }
  return null;
}
function getPreviousFocusable(currentElement) {
  const focusableElements = getFocusableElements();
  const currentIndex = focusableElements.indexOf(currentElement);
  const previousIndex = currentIndex - 1;
  const prevElement = focusableElements[previousIndex];
  if (previousIndex >= 0 && isHTMLElement(prevElement)) {
    return prevElement;
  }
  return null;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/typeahead.js
var ignoredKeys = /* @__PURE__ */ new Set(["Shift", "Control", "Alt", "Meta", "CapsLock", "NumLock"]);
var defaults = {
  onMatch: handleRovingFocus,
  getCurrentItem: () => document.activeElement
};
function createTypeaheadSearch(args = {}) {
  const withDefaults = { ...defaults, ...args };
  const typed = withGet(writable([]));
  const resetTyped = debounce(() => {
    typed.update(() => []);
  });
  const handleTypeaheadSearch = (key, items) => {
    if (ignoredKeys.has(key))
      return;
    const currentItem = withDefaults.getCurrentItem();
    const $typed = get(typed);
    if (!Array.isArray($typed)) {
      return;
    }
    $typed.push(key.toLowerCase());
    typed.set($typed);
    const candidateItems = items.filter((item) => {
      if (item.getAttribute("disabled") === "true" || item.getAttribute("aria-disabled") === "true" || item.hasAttribute("data-disabled")) {
        return false;
      }
      return true;
    });
    const isRepeated = $typed.length > 1 && $typed.every((char) => char === $typed[0]);
    const normalizeSearch = isRepeated ? $typed[0] : $typed.join("");
    const currentItemIndex = isHTMLElement(currentItem) ? candidateItems.indexOf(currentItem) : -1;
    let wrappedItems = wrapArray(candidateItems, Math.max(currentItemIndex, 0));
    const excludeCurrentItem = normalizeSearch.length === 1;
    if (excludeCurrentItem) {
      wrappedItems = wrappedItems.filter((v) => v !== currentItem);
    }
    const nextItem = wrappedItems.find((item) => (item == null ? void 0 : item.innerText) && item.innerText.toLowerCase().startsWith(normalizeSearch.toLowerCase()));
    if (isHTMLElement(nextItem) && nextItem !== currentItem) {
      withDefaults.onMatch(nextItem);
    }
    resetTyped();
  };
  return {
    typed,
    resetTyped,
    handleTypeaheadSearch
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/elements.js
function getPortalParent(node) {
  let parent = node.parentElement;
  while (isHTMLElement(parent) && !parent.hasAttribute("data-portal")) {
    parent = parent.parentElement;
  }
  return parent || "body";
}
function getPortalDestination(node, portalProp) {
  if (portalProp !== void 0)
    return portalProp;
  const portalParent = getPortalParent(node);
  if (portalParent === "body")
    return document.body;
  return null;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/ignore.js
function createClickOutsideIgnore(meltId) {
  return (e) => {
    const target = e.target;
    const triggerEl = getElementByMeltId(meltId);
    if (!triggerEl || !isElement(target))
      return false;
    const id = triggerEl.id;
    if (isHTMLLabelElement(target) && id === target.htmlFor) {
      return true;
    }
    if (target.closest(`label[for="${id}"]`)) {
      return true;
    }
    return false;
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/focus.js
async function handleFocus(args) {
  const { prop: prop2, defaultEl } = args;
  await Promise.all([sleep(1), tick]);
  if (prop2 === void 0) {
    defaultEl == null ? void 0 : defaultEl.focus();
    return;
  }
  const returned = isFunction(prop2) ? prop2(defaultEl) : prop2;
  if (typeof returned === "string") {
    const el = document.querySelector(returned);
    if (!isHTMLElement(el))
      return;
    el.focus();
  } else if (isHTMLElement(returned)) {
    returned.focus();
  }
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/math.js
function snapValueToStep(value, min, max, step) {
  const remainder = (value - (isNaN(min) ? 0 : min)) % step;
  let snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;
  if (!isNaN(min)) {
    if (snappedValue < min) {
      snappedValue = min;
    } else if (!isNaN(max) && snappedValue > max) {
      snappedValue = min + Math.floor((max - min) / step) * step;
    }
  } else if (!isNaN(max) && snappedValue > max) {
    snappedValue = Math.floor(max / step) * step;
  }
  const string = step.toString();
  const index = string.indexOf(".");
  const precision = index >= 0 ? string.length - index : 0;
  if (precision > 0) {
    const pow = Math.pow(10, precision);
    snappedValue = Math.round(snappedValue * pow) / pow;
  }
  return snappedValue;
}
function clamp(min, value, max) {
  return Math.max(min, Math.min(value, max));
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/accordion/create.js
var { name, selector } = createElHelpers("accordion");
var defaults2 = {
  multiple: false,
  disabled: false,
  forceVisible: false
};
var createAccordion = (props) => {
  const withDefaults = { ...defaults2, ...props };
  const options = toWritableStores(omit(withDefaults, "value", "onValueChange", "defaultValue"));
  const meltIds = generateIds(["root"]);
  const { disabled, forceVisible } = options;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  const isSelected = (key, v) => {
    if (v === void 0)
      return false;
    if (typeof v === "string")
      return v === key;
    return v.includes(key);
  };
  const isSelectedStore = derived(value, ($value) => {
    return (key) => isSelected(key, $value);
  });
  const root5 = makeElement(name(), {
    returned: () => ({
      "data-melt-id": meltIds.root
    })
  });
  const parseItemProps = (props2) => {
    if (typeof props2 === "string") {
      return { value: props2 };
    } else {
      return props2;
    }
  };
  const parseHeadingProps = (props2) => {
    if (typeof props2 === "number") {
      return { level: props2 };
    } else {
      return props2;
    }
  };
  const item = makeElement(name("item"), {
    stores: value,
    returned: ($value) => {
      return (props2) => {
        const { value: itemValue, disabled: disabled2 } = parseItemProps(props2);
        return {
          "data-state": isSelected(itemValue, $value) ? "open" : "closed",
          "data-disabled": disabledAttr(disabled2)
        };
      };
    }
  });
  const trigger = makeElement(name("trigger"), {
    stores: [value, disabled],
    returned: ([$value, $disabled]) => {
      return (props2) => {
        const { value: itemValue, disabled: disabled2 } = parseItemProps(props2);
        return {
          disabled: disabledAttr($disabled || disabled2),
          "aria-expanded": isSelected(itemValue, $value) ? true : false,
          "aria-disabled": disabled2 ? true : false,
          "data-disabled": disabledAttr(disabled2),
          "data-value": itemValue,
          "data-state": isSelected(itemValue, $value) ? "open" : "closed"
        };
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        const disabled2 = node.dataset.disabled === "true";
        const itemValue = node.dataset.value;
        if (disabled2 || !itemValue)
          return;
        handleValueUpdate(itemValue);
      }), addMeltEventListener(node, "keydown", (e) => {
        if (![kbd.ARROW_DOWN, kbd.ARROW_UP, kbd.HOME, kbd.END].includes(e.key)) {
          return;
        }
        e.preventDefault();
        if (e.key === kbd.SPACE || e.key === kbd.ENTER) {
          const disabled2 = node.dataset.disabled === "true";
          const itemValue = node.dataset.value;
          if (disabled2 || !itemValue)
            return;
          handleValueUpdate(itemValue);
          return;
        }
        const el = e.target;
        const rootEl = getElementByMeltId(meltIds.root);
        if (!rootEl || !isHTMLElement(el))
          return;
        const items = Array.from(rootEl.querySelectorAll(selector("trigger")));
        const candidateItems = items.filter((item2) => {
          if (!isHTMLElement(item2))
            return false;
          return item2.dataset.disabled !== "true";
        });
        if (!candidateItems.length)
          return;
        const elIdx = candidateItems.indexOf(el);
        if (e.key === kbd.ARROW_DOWN) {
          candidateItems[(elIdx + 1) % candidateItems.length].focus();
        }
        if (e.key === kbd.ARROW_UP) {
          candidateItems[(elIdx - 1 + candidateItems.length) % candidateItems.length].focus();
        }
        if (e.key === kbd.HOME) {
          candidateItems[0].focus();
        }
        if (e.key === kbd.END) {
          candidateItems[candidateItems.length - 1].focus();
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const content = makeElement(name("content"), {
    stores: [value, disabled, forceVisible],
    returned: ([$value, $disabled, $forceVisible]) => {
      return (props2) => {
        const { value: itemValue } = parseItemProps(props2);
        const isVisible = isSelected(itemValue, $value) || $forceVisible;
        return {
          "data-state": isVisible ? "open" : "closed",
          "data-disabled": disabledAttr($disabled),
          "data-value": itemValue,
          hidden: isVisible ? void 0 : true,
          style: styleToString({
            display: isVisible ? void 0 : "none"
          })
        };
      };
    },
    action: (node) => {
      tick().then(() => {
        const contentId = generateId();
        const triggerId = generateId();
        const parentTrigger = document.querySelector(`${selector("trigger")}, [data-value="${node.dataset.value}"]`);
        if (!isHTMLElement(parentTrigger))
          return;
        node.id = contentId;
        parentTrigger.setAttribute("aria-controls", contentId);
        parentTrigger.id = triggerId;
      });
    }
  });
  const heading = makeElement(name("heading"), {
    returned: () => {
      return (props2) => {
        const { level } = parseHeadingProps(props2);
        return {
          role: "heading",
          "aria-level": level,
          "data-heading-level": level
        };
      };
    }
  });
  function handleValueUpdate(itemValue) {
    value.update(($value) => {
      if ($value === void 0) {
        return withDefaults.multiple ? [itemValue] : itemValue;
      }
      if (Array.isArray($value)) {
        if ($value.includes(itemValue)) {
          return $value.filter((v) => v !== itemValue);
        }
        $value.push(itemValue);
        return $value;
      }
      return $value === itemValue ? void 0 : itemValue;
    });
  }
  return {
    ids: meltIds,
    elements: {
      root: root5,
      item,
      trigger,
      content,
      heading
    },
    states: {
      value
    },
    helpers: {
      isSelected: isSelectedStore
    },
    options
  };
};

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/avatar/create.js
var defaults3 = {
  src: "",
  delayMs: 0,
  onLoadingStatusChange: void 0
};
var createAvatar = (props) => {
  const withDefaults = { ...defaults3, ...props };
  const options = toWritableStores(omit(withDefaults, "loadingStatus", "onLoadingStatusChange"));
  const { src, delayMs } = options;
  const loadingStatusWritable = withDefaults.loadingStatus ?? writable("loading");
  const loadingStatus = overridable(loadingStatusWritable, withDefaults == null ? void 0 : withDefaults.onLoadingStatusChange);
  effect([src, delayMs], ([$src, $delayMs]) => {
    if (isBrowser) {
      const image2 = new Image();
      image2.src = $src;
      image2.onload = () => {
        if (delayMs !== void 0) {
          const timerId = window.setTimeout(() => {
            loadingStatus.set("loaded");
          }, $delayMs);
          return () => window.clearTimeout(timerId);
        } else {
          loadingStatus.set("loaded");
        }
      };
      image2.onerror = () => {
        loadingStatus.set("error");
      };
    }
  });
  const image = makeElement("avatar-image", {
    stores: [src, loadingStatus],
    returned: ([$src, $loadingStatus]) => {
      const imageStyles = styleToString({
        display: $loadingStatus === "loaded" ? "block" : "none"
      });
      return {
        src: $src,
        style: imageStyles
      };
    }
  });
  const fallback = makeElement("avatar-fallback", {
    stores: [loadingStatus],
    returned: ([$loadingStatus]) => {
      return {
        style: $loadingStatus === "loaded" ? styleToString({
          display: "none"
        }) : void 0,
        hidden: $loadingStatus === "loaded" ? true : void 0
      };
    }
  });
  return {
    elements: {
      image,
      fallback
    },
    states: {
      loadingStatus
    },
    options
  };
};

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/checkbox/create.js
var defaults4 = {
  disabled: false,
  required: false,
  name: void 0,
  value: "on",
  defaultChecked: false
};
function createCheckbox(props) {
  const withDefaults = { ...defaults4, ...props };
  const options = toWritableStores(omit(withDefaults, "checked", "defaultChecked"));
  const { disabled, name: name27, required, value } = options;
  const checkedWritable = withDefaults.checked ?? writable(withDefaults.defaultChecked);
  const checked = overridable(checkedWritable, withDefaults == null ? void 0 : withDefaults.onCheckedChange);
  const root5 = makeElement("checkbox", {
    stores: [checked, disabled, required],
    returned: ([$checked, $disabled, $required]) => {
      return {
        "data-disabled": disabledAttr($disabled),
        disabled: disabledAttr($disabled),
        "data-state": $checked === "indeterminate" ? "indeterminate" : $checked ? "checked" : "unchecked",
        type: "button",
        role: "checkbox",
        "aria-checked": $checked === "indeterminate" ? "mixed" : $checked,
        "aria-required": $required
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "keydown", (e) => {
        if (e.key === kbd.ENTER)
          e.preventDefault();
      }), addMeltEventListener(node, "click", () => {
        if (disabled.get())
          return;
        checked.update((value2) => {
          if (value2 === "indeterminate")
            return true;
          return !value2;
        });
      }));
      return {
        destroy: unsub
      };
    }
  });
  const input = makeElement("checkbox-input", {
    stores: [checked, name27, value, required, disabled],
    returned: ([$checked, $name, $value, $required, $disabled]) => {
      return {
        type: "checkbox",
        "aria-hidden": true,
        hidden: true,
        tabindex: -1,
        name: $name,
        value: $value,
        checked: $checked === "indeterminate" ? false : $checked,
        required: $required,
        disabled: disabledAttr($disabled),
        style: styleToString({
          position: "absolute",
          opacity: 0,
          "pointer-events": "none",
          margin: 0,
          transform: "translateX(-100%)"
        })
      };
    }
  });
  const isIndeterminate = derived(checked, ($checked) => $checked === "indeterminate");
  const isChecked = derived(checked, ($checked) => $checked === true);
  return {
    elements: {
      root: root5,
      input
    },
    states: {
      checked
    },
    helpers: {
      isIndeterminate,
      isChecked
    },
    options
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/collapsible/create.js
var defaults5 = {
  defaultOpen: false,
  disabled: false,
  forceVisible: false
};
var { name: name2 } = createElHelpers("collapsible");
function createCollapsible(props) {
  const withDefaults = { ...defaults5, ...props };
  const options = toWritableStores(omit(withDefaults, "open", "defaultOpen", "onOpenChange"));
  const { disabled, forceVisible } = options;
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const root5 = makeElement(name2(), {
    stores: [open, disabled],
    returned: ([$open, $disabled]) => ({
      "data-state": $open ? "open" : "closed",
      "data-disabled": disabledAttr($disabled)
    })
  });
  const trigger = makeElement(name2("trigger"), {
    stores: [open, disabled],
    returned: ([$open, $disabled]) => ({
      "data-state": $open ? "open" : "closed",
      "data-disabled": disabledAttr($disabled),
      disabled: disabledAttr($disabled)
    }),
    action: (node) => {
      const unsub = addMeltEventListener(node, "click", () => {
        const disabled2 = node.dataset.disabled !== void 0;
        if (disabled2)
          return;
        open.update(($open) => !$open);
      });
      return {
        destroy: unsub
      };
    }
  });
  const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => $open || $forceVisible);
  const content = makeElement(name2("content"), {
    stores: [isVisible, disabled],
    returned: ([$isVisible, $disabled]) => ({
      "data-state": $isVisible ? "open" : "closed",
      "data-disabled": disabledAttr($disabled),
      hidden: $isVisible ? void 0 : true,
      style: styleToString({
        display: $isVisible ? void 0 : "none"
      })
    })
  });
  return {
    elements: {
      root: root5,
      trigger,
      content
    },
    states: {
      open
    },
    options
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/actions/click-outside/action.js
var documentClickStore = readable(void 0, (set2) => {
  function clicked(event2) {
    set2(event2);
    set2(void 0);
  }
  const unsubscribe = addEventListener(document, "pointerup", clicked, {
    passive: false,
    capture: true
  });
  return unsubscribe;
});

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/actions/escape-keydown/action.js
var documentEscapeKeyStore = readable(void 0, (set2) => {
  function keydown(event2) {
    if (event2 && event2.key === kbd.ESCAPE) {
      set2(event2);
    }
    set2(void 0);
  }
  const unsubscribe = addEventListener(document, "keydown", keydown, {
    passive: false
  });
  return unsubscribe;
});
var useEscapeKeydown = (node, config = {}) => {
  let unsub = noop;
  function update(config2 = {}) {
    unsub();
    const options = { enabled: true, ...config2 };
    const enabled = isReadable(options.enabled) ? options.enabled : readable(options.enabled);
    unsub = executeCallbacks(
      // Handle escape keydowns
      documentEscapeKeyStore.subscribe((e) => {
        var _a;
        if (!e || !get(enabled))
          return;
        const target = e.target;
        if (!isHTMLElement(target) || target.closest("[data-escapee]") !== node) {
          return;
        }
        e.preventDefault();
        if (options.ignore) {
          if (isFunction(options.ignore)) {
            if (options.ignore(e))
              return;
          } else if (Array.isArray(options.ignore)) {
            if (options.ignore.length > 0 && options.ignore.some((ignoreEl) => {
              return ignoreEl && target === ignoreEl;
            }))
              return;
          }
        }
        (_a = options.handler) == null ? void 0 : _a.call(options, e);
      }),
      effect(enabled, ($enabled) => {
        if ($enabled) {
          node.dataset.escapee = "";
        } else {
          delete node.dataset.escapee;
        }
      })
    );
  }
  update(config);
  return {
    update,
    destroy() {
      node.removeAttribute("data-escapee");
      unsub();
    }
  };
};

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/actions/floating/action.js
var defaultConfig = {
  strategy: "absolute",
  placement: "top",
  gutter: 5,
  flip: true,
  sameWidth: false,
  overflowPadding: 8
};
var ARROW_TRANSFORM = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function useFloating(reference, floating, opts = {}) {
  if (!floating || !reference || opts === null)
    return {
      destroy: noop
    };
  const options = { ...defaultConfig, ...opts };
  const arrowEl = floating.querySelector("[data-arrow=true]");
  const middleware = [];
  if (options.flip) {
    middleware.push(flip({
      boundary: options.boundary,
      padding: options.overflowPadding
    }));
  }
  const arrowOffset = isHTMLElement(arrowEl) ? arrowEl.offsetHeight / 2 : 0;
  if (options.gutter || options.offset) {
    const data = options.gutter ? { mainAxis: options.gutter } : options.offset;
    if ((data == null ? void 0 : data.mainAxis) != null) {
      data.mainAxis += arrowOffset;
    }
    middleware.push(offset(data));
  }
  middleware.push(shift({
    boundary: options.boundary,
    crossAxis: options.overlap,
    padding: options.overflowPadding
  }));
  if (arrowEl) {
    middleware.push(arrow({ element: arrowEl, padding: 8 }));
  }
  middleware.push(size({
    padding: options.overflowPadding,
    apply({ rects, availableHeight, availableWidth }) {
      if (options.sameWidth) {
        Object.assign(floating.style, {
          width: `${Math.round(rects.reference.width)}px`,
          minWidth: "unset"
        });
      }
      if (options.fitViewport) {
        Object.assign(floating.style, {
          maxWidth: `${availableWidth}px`,
          maxHeight: `${availableHeight}px`
        });
      }
    }
  }));
  function compute() {
    if (!reference || !floating)
      return;
    if (isHTMLElement(reference) && !reference.ownerDocument.documentElement.contains(reference))
      return;
    const { placement, strategy } = options;
    computePosition(reference, floating, {
      placement,
      middleware,
      strategy
    }).then((data) => {
      const x = Math.round(data.x);
      const y = Math.round(data.y);
      const [side, align] = getSideAndAlignFromPlacement(data.placement);
      floating.setAttribute("data-side", side);
      floating.setAttribute("data-align", align);
      Object.assign(floating.style, {
        position: options.strategy,
        top: `${y}px`,
        left: `${x}px`
      });
      if (isHTMLElement(arrowEl) && data.middlewareData.arrow) {
        const { x: x2, y: y2 } = data.middlewareData.arrow;
        const dir = data.placement.split("-")[0];
        arrowEl.setAttribute("data-side", dir);
        Object.assign(arrowEl.style, {
          position: "absolute",
          left: x2 != null ? `${x2}px` : "",
          top: y2 != null ? `${y2}px` : "",
          [dir]: `calc(100% - ${arrowOffset}px)`,
          transform: ARROW_TRANSFORM[dir],
          backgroundColor: "inherit",
          zIndex: "inherit"
        });
      }
      return data;
    });
  }
  Object.assign(floating.style, {
    position: options.strategy
  });
  return {
    destroy: autoUpdate(reference, floating, compute)
  };
}
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/actions/focus-trap/action.js
function createFocusTrap2(config = {}) {
  let trap;
  const { immediate, ...focusTrapOptions } = config;
  const hasFocus = writable(false);
  const isPaused = writable(false);
  const activate = (opts) => trap == null ? void 0 : trap.activate(opts);
  const deactivate = (opts) => {
    trap == null ? void 0 : trap.deactivate(opts);
  };
  const pause = () => {
    if (trap) {
      trap.pause();
      isPaused.set(true);
    }
  };
  const unpause = () => {
    if (trap) {
      trap.unpause();
      isPaused.set(false);
    }
  };
  const useFocusTrap = (node) => {
    trap = createFocusTrap(node, {
      ...focusTrapOptions,
      onActivate() {
        var _a;
        hasFocus.set(true);
        (_a = config.onActivate) == null ? void 0 : _a.call(config);
      },
      onDeactivate() {
        var _a;
        hasFocus.set(false);
        (_a = config.onDeactivate) == null ? void 0 : _a.call(config);
      }
    });
    if (immediate) {
      activate();
    }
    return {
      destroy() {
        deactivate();
        trap = void 0;
      }
    };
  };
  return {
    useFocusTrap,
    hasFocus: readonly(hasFocus),
    isPaused: readonly(isPaused),
    activate,
    deactivate,
    pause,
    unpause
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/actions/modal/action.js
var visibleModals = [];
var useModal = (node, config) => {
  let unsubInteractOutside = noop;
  function removeNodeFromVisibleModals() {
    const index = visibleModals.indexOf(node);
    if (index >= 0) {
      visibleModals.splice(index, 1);
    }
  }
  function update(config2) {
    unsubInteractOutside();
    const { open, onClose, shouldCloseOnInteractOutside, closeOnInteractOutside } = config2;
    sleep(100).then(() => {
      if (open) {
        visibleModals.push(node);
      } else {
        removeNodeFromVisibleModals();
      }
    });
    function isLastModal() {
      return last(visibleModals) === node;
    }
    function closeModal() {
      if (isLastModal() && onClose) {
        onClose();
        removeNodeFromVisibleModals();
      }
    }
    function onInteractOutsideStart(e) {
      const target = e.target;
      if (!isElement(target))
        return;
      if (target && isLastModal()) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    }
    function onInteractOutside(e) {
      if ((shouldCloseOnInteractOutside == null ? void 0 : shouldCloseOnInteractOutside(e)) && isLastModal()) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        closeModal();
      }
    }
    unsubInteractOutside = useInteractOutside(node, {
      onInteractOutsideStart,
      onInteractOutside: closeOnInteractOutside ? onInteractOutside : void 0,
      enabled: open
    }).destroy;
  }
  update(config);
  return {
    update,
    destroy() {
      removeNodeFromVisibleModals();
      unsubInteractOutside();
    }
  };
};

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/actions/popper/action.js
var defaultConfig2 = {
  floating: {},
  focusTrap: {},
  modal: {},
  escapeKeydown: {},
  portal: "body"
};
var usePopper = (popperElement, args) => {
  popperElement.dataset.escapee = "";
  const { anchorElement, open, options } = args;
  if (!anchorElement || !open || !options) {
    return { destroy: noop };
  }
  const opts = { ...defaultConfig2, ...options };
  const callbacks = [];
  if (opts.portal !== null) {
    callbacks.push(usePortal(popperElement, opts.portal).destroy);
  }
  callbacks.push(useFloating(anchorElement, popperElement, opts.floating).destroy);
  if (opts.focusTrap !== null) {
    const { useFocusTrap } = createFocusTrap2({
      immediate: true,
      escapeDeactivates: false,
      allowOutsideClick: true,
      returnFocusOnDeactivate: false,
      fallbackFocus: popperElement,
      ...opts.focusTrap
    });
    callbacks.push(useFocusTrap(popperElement).destroy);
  }
  if (opts.modal !== null) {
    callbacks.push(useModal(popperElement, {
      onClose: () => {
        if (isHTMLElement(anchorElement)) {
          open.set(false);
          anchorElement.focus();
        }
      },
      shouldCloseOnInteractOutside: (e) => {
        if (e.defaultPrevented)
          return false;
        if (isHTMLElement(anchorElement) && anchorElement.contains(e.target)) {
          return false;
        }
        return true;
      },
      ...opts.modal
    }).destroy);
  }
  if (opts.escapeKeydown !== null) {
    callbacks.push(useEscapeKeydown(popperElement, {
      enabled: open,
      handler: () => {
        open.set(false);
      },
      ...opts.escapeKeydown
    }).destroy);
  }
  const unsubscribe = executeCallbacks(...callbacks);
  return {
    destroy() {
      unsubscribe();
    }
  };
};

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/actions/portal.js
var usePortal = (el, target = "body") => {
  let targetEl;
  if (!isHTMLElement(target) && typeof target !== "string") {
    return {
      destroy: noop
    };
  }
  async function update(newTarget) {
    target = newTarget;
    if (typeof target === "string") {
      targetEl = document.querySelector(target);
      if (targetEl === null) {
        await tick();
        targetEl = document.querySelector(target);
      }
      if (targetEl === null) {
        throw new Error(`No element found matching css selector: "${target}"`);
      }
    } else if (target instanceof HTMLElement) {
      targetEl = target;
    } else {
      throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
    }
    el.dataset.portal = "";
    targetEl.appendChild(el);
    el.hidden = false;
  }
  function destroy() {
    el.remove();
  }
  update(target);
  return {
    update,
    destroy
  };
};

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/actions/interact-outside/action.js
var useInteractOutside = (node, config) => {
  let unsub = noop;
  let unsubClick = noop;
  let isPointerDown = false;
  let isPointerDownInside = false;
  let ignoreEmulatedMouseEvents = false;
  function update(config2) {
    unsub();
    unsubClick();
    const { onInteractOutside, onInteractOutsideStart, enabled } = config2;
    if (!enabled)
      return;
    function onPointerDown(e) {
      if (onInteractOutside && isValidEvent(e, node)) {
        onInteractOutsideStart == null ? void 0 : onInteractOutsideStart(e);
      }
      const target = e.target;
      if (isElement(target) && isOrContainsTarget(node, target)) {
        isPointerDownInside = true;
      }
      isPointerDown = true;
    }
    function triggerInteractOutside(e) {
      onInteractOutside == null ? void 0 : onInteractOutside(e);
    }
    const documentObj = getOwnerDocument(node);
    if (typeof PointerEvent !== "undefined") {
      const onPointerUp = (e) => {
        unsubClick();
        const handler = (e2) => {
          if (shouldTriggerInteractOutside(e2)) {
            triggerInteractOutside(e2);
          }
          resetPointerState();
        };
        if (e.pointerType === "touch") {
          unsubClick = addEventListener(documentObj, "click", handler, {
            capture: true,
            once: true
          });
          return;
        }
        handler(e);
      };
      unsub = executeCallbacks(addEventListener(documentObj, "pointerdown", onPointerDown, true), addEventListener(documentObj, "pointerup", onPointerUp, true));
    } else {
      const onMouseUp = (e) => {
        if (ignoreEmulatedMouseEvents) {
          ignoreEmulatedMouseEvents = false;
        } else if (shouldTriggerInteractOutside(e)) {
          triggerInteractOutside(e);
        }
        resetPointerState();
      };
      const onTouchEnd = (e) => {
        ignoreEmulatedMouseEvents = true;
        if (shouldTriggerInteractOutside(e)) {
          triggerInteractOutside(e);
        }
        resetPointerState();
      };
      unsub = executeCallbacks(addEventListener(documentObj, "mousedown", onPointerDown, true), addEventListener(documentObj, "mouseup", onMouseUp, true), addEventListener(documentObj, "touchstart", onPointerDown, true), addEventListener(documentObj, "touchend", onTouchEnd, true));
    }
  }
  function shouldTriggerInteractOutside(e) {
    if (isPointerDown && !isPointerDownInside && isValidEvent(e, node)) {
      return true;
    }
    return false;
  }
  function resetPointerState() {
    isPointerDown = false;
    isPointerDownInside = false;
  }
  update(config);
  return {
    update,
    destroy() {
      unsub();
      unsubClick();
    }
  };
};
function isValidEvent(e, node) {
  if ("button" in e && e.button > 0)
    return false;
  const target = e.target;
  if (!isElement(target))
    return false;
  const ownerDocument = target.ownerDocument;
  if (!ownerDocument || !ownerDocument.documentElement.contains(target)) {
    return false;
  }
  return node && !isOrContainsTarget(node, target);
}
function isOrContainsTarget(node, target) {
  return node === target || node.contains(target);
}
function getOwnerDocument(el) {
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/store/toReadableStores.js
function toReadableStores(properties) {
  const result = {};
  Object.keys(properties).forEach((key) => {
    const propertyKey = key;
    const value = properties[propertyKey];
    if (isReadable(value)) {
      result[propertyKey] = withGet(value);
    } else {
      result[propertyKey] = withGet(readable(value));
    }
  });
  return result;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/hidden-input/create.js
var defaults6 = {
  prefix: "",
  disabled: readable(false),
  required: readable(false),
  name: readable(void 0)
};
function createHiddenInput(props) {
  const withDefaults = {
    ...defaults6,
    ...removeUndefined(props)
  };
  const { name: elName } = createElHelpers(withDefaults.prefix);
  const { value, name: name27, disabled, required } = toReadableStores(omit(withDefaults, "prefix"));
  const nameStore = name27;
  const hiddenInput = makeElement(elName("hidden-input"), {
    stores: [value, nameStore, disabled, required],
    returned: ([$value, $name, $disabled, $required]) => {
      return {
        name: $name,
        value: $value == null ? void 0 : $value.toString(),
        "aria-hidden": "true",
        hidden: true,
        disabled: $disabled,
        required: $required,
        tabIndex: -1,
        style: styleToString({
          position: "absolute",
          opacity: 0,
          "pointer-events": "none",
          margin: 0,
          transform: "translateX(-100%)"
        })
      };
    },
    action: (node) => {
      const unsub = value.subscribe((newValue) => {
        node.value = newValue;
        node.dispatchEvent(new Event("change", { bubbles: true }));
      });
      return {
        destroy: unsub
      };
    }
  });
  return hiddenInput;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/label/create.js
function createLabel() {
  const root5 = makeElement("label", {
    action: (node) => {
      const mouseDown = addMeltEventListener(node, "mousedown", (e) => {
        if (!e.defaultPrevented && e.detail > 1) {
          e.preventDefault();
        }
      });
      return {
        destroy: mouseDown
      };
    }
  });
  return {
    elements: {
      root: root5
    }
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/listbox/create.js
var INTERACTION_KEYS = [kbd.ARROW_LEFT, kbd.ESCAPE, kbd.ARROW_RIGHT, kbd.SHIFT, kbd.CAPS_LOCK, kbd.CONTROL, kbd.ALT, kbd.META, kbd.ENTER, kbd.F1, kbd.F2, kbd.F3, kbd.F4, kbd.F5, kbd.F6, kbd.F7, kbd.F8, kbd.F9, kbd.F10, kbd.F11, kbd.F12];
var defaults7 = {
  positioning: {
    placement: "bottom",
    sameWidth: true
  },
  scrollAlignment: "nearest",
  loop: true,
  defaultOpen: false,
  closeOnOutsideClick: true,
  preventScroll: true,
  closeOnEscape: true,
  forceVisible: false,
  portal: void 0,
  builder: "listbox",
  disabled: false,
  required: false,
  name: void 0,
  typeahead: true,
  highlightOnHover: true,
  onOutsideClick: void 0
};
var listboxIdParts = ["trigger", "menu", "label"];
function createListbox(props) {
  const withDefaults = { ...defaults7, ...props };
  const activeTrigger = withGet(writable(null));
  const highlightedItem = withGet(writable(null));
  const selectedWritable = withDefaults.selected ?? writable(withDefaults.defaultSelected);
  const selected = overridable(selectedWritable, withDefaults == null ? void 0 : withDefaults.onSelectedChange);
  const highlighted = derived(highlightedItem, ($highlightedItem) => $highlightedItem ? getOptionProps($highlightedItem) : void 0);
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const options = toWritableStores({
    ...omit(withDefaults, "open", "defaultOpen", "builder", "ids"),
    multiple: withDefaults.multiple ?? false
  });
  const { scrollAlignment, loop, closeOnOutsideClick, closeOnEscape, preventScroll, portal, forceVisible, positioning, multiple, arrowSize, disabled, required, typeahead, name: nameProp, highlightOnHover, onOutsideClick } = options;
  const { name: name27, selector: selector10 } = createElHelpers(withDefaults.builder);
  const ids = toWritableStores({ ...generateIds(listboxIdParts), ...withDefaults.ids });
  const { handleTypeaheadSearch } = createTypeaheadSearch({
    onMatch: (element2) => {
      highlightedItem.set(element2);
      element2.scrollIntoView({ block: scrollAlignment.get() });
    },
    getCurrentItem() {
      return highlightedItem.get();
    }
  });
  function getOptionProps(el) {
    const value = el.getAttribute("data-value");
    const label2 = el.getAttribute("data-label");
    const disabled2 = el.hasAttribute("data-disabled");
    return {
      value: value ? JSON.parse(value) : value,
      label: label2 ?? el.textContent ?? void 0,
      disabled: disabled2 ? true : false
    };
  }
  const setOption = (newOption) => {
    selected.update(($option) => {
      const $multiple = multiple.get();
      if ($multiple) {
        const optionArr = Array.isArray($option) ? [...$option] : [];
        return toggle(newOption, optionArr, (itemA, itemB) => dequal(itemA.value, itemB.value));
      }
      return newOption;
    });
  };
  function selectItem(item) {
    const props2 = getOptionProps(item);
    setOption(props2);
  }
  async function openMenu() {
    open.set(true);
    const triggerEl = document.getElementById(ids.trigger.get());
    if (!triggerEl)
      return;
    if (triggerEl !== activeTrigger.get())
      activeTrigger.set(triggerEl);
    await tick();
    const menuElement = document.getElementById(ids.menu.get());
    if (!isHTMLElement(menuElement))
      return;
    const selectedItem = menuElement.querySelector("[aria-selected=true]");
    if (!isHTMLElement(selectedItem))
      return;
    highlightedItem.set(selectedItem);
  }
  function closeMenu() {
    open.set(false);
    highlightedItem.set(null);
  }
  const isVisible = derivedVisible({ open, forceVisible, activeTrigger });
  const isSelected = derived([selected], ([$selected]) => {
    return (value) => {
      if (Array.isArray($selected)) {
        return $selected.some((o) => dequal(o.value, value));
      }
      if (isObject(value)) {
        return dequal($selected == null ? void 0 : $selected.value, stripValues(value, void 0, true));
      }
      return dequal($selected == null ? void 0 : $selected.value, value);
    };
  });
  const isHighlighted = derived([highlighted], ([$value]) => {
    return (item) => {
      return dequal($value == null ? void 0 : $value.value, item);
    };
  });
  const trigger = makeElement(name27("trigger"), {
    stores: [open, highlightedItem, disabled, ids.menu, ids.trigger, ids.label],
    returned: ([$open, $highlightedItem, $disabled, $menuId, $triggerId, $labelId]) => {
      return {
        "aria-activedescendant": $highlightedItem == null ? void 0 : $highlightedItem.id,
        "aria-autocomplete": "list",
        "aria-controls": $menuId,
        "aria-expanded": $open,
        "aria-labelledby": $labelId,
        // autocomplete: 'off',
        id: $triggerId,
        role: "combobox",
        disabled: disabledAttr($disabled),
        type: withDefaults.builder === "select" ? "button" : void 0
      };
    },
    action: (node) => {
      const isInput = isHTMLInputElement(node);
      const unsubscribe = executeCallbacks(
        addMeltEventListener(node, "click", () => {
          node.focus();
          const $open = open.get();
          if ($open) {
            closeMenu();
          } else {
            openMenu();
          }
        }),
        // Handle all input key events including typing, meta, and navigation.
        addMeltEventListener(node, "keydown", (e) => {
          const $open = open.get();
          if (!$open) {
            if (INTERACTION_KEYS.includes(e.key)) {
              return;
            }
            if (e.key === kbd.TAB) {
              return;
            }
            if (e.key === kbd.BACKSPACE && isInput && node.value === "") {
              return;
            }
            if (e.key === kbd.SPACE && isHTMLButtonElement(node)) {
              return;
            }
            openMenu();
            tick().then(() => {
              const $selectedItem = selected.get();
              if ($selectedItem)
                return;
              const menuEl = document.getElementById(ids.menu.get());
              if (!isHTMLElement(menuEl))
                return;
              const enabledItems = Array.from(menuEl.querySelectorAll(`${selector10("item")}:not([data-disabled]):not([data-hidden])`)).filter((item) => isHTMLElement(item));
              if (!enabledItems.length)
                return;
              if (e.key === kbd.ARROW_DOWN) {
                highlightedItem.set(enabledItems[0]);
                enabledItems[0].scrollIntoView({ block: scrollAlignment.get() });
              } else if (e.key === kbd.ARROW_UP) {
                highlightedItem.set(last(enabledItems));
                last(enabledItems).scrollIntoView({ block: scrollAlignment.get() });
              }
            });
          }
          if (e.key === kbd.TAB) {
            closeMenu();
            return;
          }
          if (e.key === kbd.ENTER && !e.isComposing || e.key === kbd.SPACE && isHTMLButtonElement(node)) {
            e.preventDefault();
            const $highlightedItem = highlightedItem.get();
            if ($highlightedItem) {
              selectItem($highlightedItem);
            }
            if (!multiple.get()) {
              closeMenu();
            }
          }
          if (e.key === kbd.ARROW_UP && e.altKey) {
            closeMenu();
          }
          if (FIRST_LAST_KEYS.includes(e.key)) {
            e.preventDefault();
            const menuElement = document.getElementById(ids.menu.get());
            if (!isHTMLElement(menuElement))
              return;
            const itemElements = getOptions(menuElement);
            if (!itemElements.length)
              return;
            const candidateNodes = itemElements.filter((opt) => !isElementDisabled(opt) && opt.dataset.hidden === void 0);
            const $currentItem = highlightedItem.get();
            const currentIndex = $currentItem ? candidateNodes.indexOf($currentItem) : -1;
            const $loop = loop.get();
            const $scrollAlignment = scrollAlignment.get();
            let nextItem;
            switch (e.key) {
              case kbd.ARROW_DOWN:
                nextItem = next(candidateNodes, currentIndex, $loop);
                break;
              case kbd.ARROW_UP:
                nextItem = prev(candidateNodes, currentIndex, $loop);
                break;
              case kbd.PAGE_DOWN:
                nextItem = forward(candidateNodes, currentIndex, 10, $loop);
                break;
              case kbd.PAGE_UP:
                nextItem = back(candidateNodes, currentIndex, 10, $loop);
                break;
              case kbd.HOME:
                nextItem = candidateNodes[0];
                break;
              case kbd.END:
                nextItem = last(candidateNodes);
                break;
              default:
                return;
            }
            highlightedItem.set(nextItem);
            nextItem == null ? void 0 : nextItem.scrollIntoView({ block: $scrollAlignment });
          } else if (typeahead.get()) {
            const menuEl = document.getElementById(ids.menu.get());
            if (!isHTMLElement(menuEl))
              return;
            handleTypeaheadSearch(e.key, getOptions(menuEl));
          }
        })
      );
      let unsubEscapeKeydown = noop;
      const escape = useEscapeKeydown(node, {
        handler: closeMenu,
        enabled: derived([open, closeOnEscape], ([$open, $closeOnEscape]) => {
          return $open && $closeOnEscape;
        })
      });
      if (escape && escape.destroy) {
        unsubEscapeKeydown = escape.destroy;
      }
      return {
        destroy() {
          unsubscribe();
          unsubEscapeKeydown();
        }
      };
    }
  });
  const menu = makeElement(name27("menu"), {
    stores: [isVisible, ids.menu],
    returned: ([$isVisible, $menuId]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        id: $menuId,
        role: "listbox",
        style: styleToString({ display: $isVisible ? void 0 : "none" })
      };
    },
    action: (node) => {
      let unsubPopper = noop;
      const unsubscribe = executeCallbacks(
        // Bind the popper portal to the input element.
        effect([isVisible, portal, closeOnOutsideClick, positioning, activeTrigger], ([$isVisible, $portal, $closeOnOutsideClick, $positioning, $activeTrigger]) => {
          unsubPopper();
          if (!$isVisible || !$activeTrigger)
            return;
          tick().then(() => {
            unsubPopper();
            const ignoreHandler = createClickOutsideIgnore(ids.trigger.get());
            unsubPopper = usePopper(node, {
              anchorElement: $activeTrigger,
              open,
              options: {
                floating: $positioning,
                focusTrap: null,
                modal: {
                  closeOnInteractOutside: $closeOnOutsideClick,
                  onClose: closeMenu,
                  open: $isVisible,
                  shouldCloseOnInteractOutside: (e) => {
                    var _a;
                    (_a = onOutsideClick.get()) == null ? void 0 : _a(e);
                    if (e.defaultPrevented)
                      return false;
                    const target = e.target;
                    if (!isElement(target))
                      return false;
                    if (target === $activeTrigger || $activeTrigger.contains(target)) {
                      return false;
                    }
                    if (ignoreHandler(e))
                      return false;
                    return true;
                  }
                },
                escapeKeydown: null,
                portal: getPortalDestination(node, $portal)
              }
            }).destroy;
          });
        })
      );
      return {
        destroy: () => {
          unsubscribe();
          unsubPopper();
        }
      };
    }
  });
  const { elements: { root: labelBuilder } } = createLabel();
  const { action: labelAction } = get(labelBuilder);
  const label = makeElement(name27("label"), {
    stores: [ids.label, ids.trigger],
    returned: ([$labelId, $triggerId]) => {
      return {
        id: $labelId,
        for: $triggerId
      };
    },
    action: labelAction
  });
  const option = makeElement(name27("option"), {
    stores: [isSelected],
    returned: ([$isSelected]) => (props2) => {
      const selected2 = $isSelected(props2.value);
      return {
        "data-value": JSON.stringify(props2.value),
        "data-label": props2.label,
        "data-disabled": disabledAttr(props2.disabled),
        "aria-disabled": props2.disabled ? true : void 0,
        "aria-selected": selected2,
        "data-selected": selected2 ? "" : void 0,
        id: generateId(),
        role: "option"
      };
    },
    action: (node) => {
      const unsubscribe = executeCallbacks(addMeltEventListener(node, "click", (e) => {
        if (isElementDisabled(node)) {
          e.preventDefault();
          return;
        }
        selectItem(node);
        if (!multiple.get()) {
          closeMenu();
        }
      }), effect(highlightOnHover, ($highlightOnHover) => {
        if (!$highlightOnHover)
          return;
        const unsub = executeCallbacks(addMeltEventListener(node, "mouseover", () => {
          highlightedItem.set(node);
        }), addMeltEventListener(node, "mouseleave", () => {
          highlightedItem.set(null);
        }));
        return unsub;
      }));
      return { destroy: unsubscribe };
    }
  });
  const group = makeElement(name27("group"), {
    returned: () => {
      return (groupId) => ({
        role: "group",
        "aria-labelledby": groupId
      });
    }
  });
  const groupLabel = makeElement(name27("group-label"), {
    returned: () => {
      return (groupId) => ({
        id: groupId
      });
    }
  });
  const hiddenInput = createHiddenInput({
    value: derived([selected], ([$selected]) => {
      const value = Array.isArray($selected) ? $selected.map((o) => o.value) : $selected == null ? void 0 : $selected.value;
      return typeof value === "string" ? value : JSON.stringify(value);
    }),
    name: readonly(nameProp),
    required,
    prefix: withDefaults.builder
  });
  const arrow2 = makeElement(name27("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  safeOnMount(() => {
    if (!isBrowser)
      return;
    const menuEl = document.getElementById(ids.menu.get());
    const triggerEl = document.getElementById(ids.trigger.get());
    if (triggerEl) {
      activeTrigger.set(triggerEl);
    }
    if (!menuEl)
      return;
    const selectedEl = menuEl.querySelector("[data-selected]");
    if (!isHTMLElement(selectedEl))
      return;
  });
  effect([highlightedItem], ([$highlightedItem]) => {
    if (!isBrowser)
      return;
    const menuElement = document.getElementById(ids.menu.get());
    if (!isHTMLElement(menuElement))
      return;
    getOptions(menuElement).forEach((node) => {
      if (node === $highlightedItem) {
        addHighlight(node);
      } else {
        removeHighlight(node);
      }
    });
  });
  effect([open], ([$open]) => {
    if (!isBrowser)
      return;
    let unsubScroll = noop;
    if (preventScroll.get() && $open) {
      unsubScroll = removeScroll();
    }
    return () => {
      unsubScroll();
    };
  });
  return {
    ids,
    elements: {
      trigger,
      group,
      option,
      menu,
      groupLabel,
      label,
      hiddenInput,
      arrow: arrow2
    },
    states: {
      open,
      selected,
      highlighted,
      highlightedItem
    },
    helpers: {
      isSelected,
      isHighlighted,
      closeMenu
    },
    options
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/combobox/create.js
var INTERACTION_KEYS2 = [kbd.ARROW_LEFT, kbd.ESCAPE, kbd.ARROW_RIGHT, kbd.SHIFT, kbd.CAPS_LOCK, kbd.CONTROL, kbd.ALT, kbd.META, kbd.ENTER, kbd.F1, kbd.F2, kbd.F3, kbd.F4, kbd.F5, kbd.F6, kbd.F7, kbd.F8, kbd.F9, kbd.F10, kbd.F11, kbd.F12];
var { name: name3 } = createElHelpers("combobox");
function createCombobox(props) {
  const listbox = createListbox({ ...props, builder: "combobox", typeahead: false });
  const inputValue = writable("");
  const touchedInput = writable(false);
  const input = makeElement(name3("input"), {
    stores: [listbox.elements.trigger, inputValue],
    returned: ([$trigger, $inputValue]) => {
      return {
        ...omit($trigger, "action"),
        role: "combobox",
        value: $inputValue,
        autocomplete: "off"
      };
    },
    action: (node) => {
      const unsubscribe = executeCallbacks(
        addMeltEventListener(node, "input", (e) => {
          if (!isHTMLInputElement(e.target) && !isContentEditable(e.target))
            return;
          touchedInput.set(true);
        }),
        // This shouldn't be cancelled ever, so we don't use addMeltEventListener.
        addEventListener(node, "input", (e) => {
          if (isHTMLInputElement(e.target)) {
            inputValue.set(e.target.value);
          }
          if (isContentEditable(e.target)) {
            inputValue.set(e.target.innerText);
          }
        })
      );
      let unsubEscapeKeydown = noop;
      const escape = useEscapeKeydown(node, {
        handler: () => {
          listbox.helpers.closeMenu();
        }
      });
      if (escape && escape.destroy) {
        unsubEscapeKeydown = escape.destroy;
      }
      const { destroy } = listbox.elements.trigger(node);
      return {
        destroy() {
          destroy == null ? void 0 : destroy();
          unsubscribe();
          unsubEscapeKeydown();
        }
      };
    }
  });
  effect(listbox.states.open, ($open) => {
    if (!$open) {
      touchedInput.set(false);
    }
  });
  return {
    ...listbox,
    elements: {
      ...omit(listbox.elements, "trigger"),
      input
    },
    states: {
      ...listbox.states,
      touchedInput,
      inputValue
    }
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/menu/create.js
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, kbd.ARROW_RIGHT],
  rtl: [...SELECTION_KEYS, kbd.ARROW_LEFT]
};
var SUB_CLOSE_KEYS = {
  ltr: [kbd.ARROW_LEFT],
  rtl: [kbd.ARROW_RIGHT]
};
var menuIdParts = ["menu", "trigger"];
var defaults8 = {
  arrowSize: 8,
  positioning: {
    placement: "bottom"
  },
  preventScroll: true,
  closeOnEscape: true,
  closeOnOutsideClick: true,
  portal: void 0,
  loop: false,
  dir: "ltr",
  defaultOpen: false,
  typeahead: true,
  closeOnItemClick: true,
  onOutsideClick: void 0
};
function createMenuBuilder(opts) {
  const { name: name27, selector: selector10 } = createElHelpers(opts.selector);
  const { preventScroll, arrowSize, positioning, closeOnEscape, closeOnOutsideClick, portal, forceVisible, typeahead, loop, closeFocus, disableFocusFirstItem, closeOnItemClick, onOutsideClick } = opts.rootOptions;
  const rootOpen = opts.rootOpen;
  const rootActiveTrigger = opts.rootActiveTrigger;
  const nextFocusable = opts.nextFocusable;
  const prevFocusable = opts.prevFocusable;
  const isUsingKeyboard = withGet.writable(false);
  const lastPointerX = withGet(writable(0));
  const pointerGraceIntent = withGet(writable(null));
  const pointerDir = withGet(writable("right"));
  const currentFocusedItem = withGet(writable(null));
  const pointerMovingToSubmenu = withGet(derived([pointerDir, pointerGraceIntent], ([$pointerDir, $pointerGraceIntent]) => {
    return (e) => {
      const isMovingTowards = $pointerDir === ($pointerGraceIntent == null ? void 0 : $pointerGraceIntent.side);
      return isMovingTowards && isPointerInGraceArea(e, $pointerGraceIntent == null ? void 0 : $pointerGraceIntent.area);
    };
  }));
  const { typed, handleTypeaheadSearch } = createTypeaheadSearch();
  const rootIds = toWritableStores({ ...generateIds(menuIdParts), ...opts.ids });
  const isVisible = derivedVisible({
    open: rootOpen,
    forceVisible,
    activeTrigger: rootActiveTrigger
  });
  const rootMenu = makeElement(name27(), {
    stores: [isVisible, portal, rootIds.menu, rootIds.trigger],
    returned: ([$isVisible, $portal, $rootMenuId, $rootTriggerId]) => {
      return {
        role: "menu",
        hidden: $isVisible ? void 0 : true,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        id: $rootMenuId,
        "aria-labelledby": $rootTriggerId,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": portalAttr($portal),
        tabindex: -1
      };
    },
    action: (node) => {
      let unsubPopper = noop;
      const unsubDerived = effect([isVisible, rootActiveTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $rootActiveTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape]) => {
        unsubPopper();
        if (!$isVisible || !$rootActiveTrigger)
          return;
        tick().then(() => {
          unsubPopper();
          setMeltMenuAttribute(node, selector10);
          unsubPopper = usePopper(node, {
            anchorElement: $rootActiveTrigger,
            open: rootOpen,
            options: {
              floating: $positioning,
              modal: {
                closeOnInteractOutside: $closeOnOutsideClick,
                shouldCloseOnInteractOutside: (e) => {
                  var _a;
                  (_a = onOutsideClick.get()) == null ? void 0 : _a(e);
                  if (e.defaultPrevented)
                    return false;
                  if (isHTMLElement($rootActiveTrigger) && $rootActiveTrigger.contains(e.target)) {
                    return false;
                  }
                  return true;
                },
                onClose: () => {
                  rootOpen.set(false);
                  $rootActiveTrigger.focus();
                },
                open: $isVisible
              },
              portal: getPortalDestination(node, $portal),
              escapeKeydown: $closeOnEscape ? void 0 : null
            }
          }).destroy;
        });
      });
      const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => {
        const target = e.target;
        const menuEl = e.currentTarget;
        if (!isHTMLElement(target) || !isHTMLElement(menuEl))
          return;
        const isKeyDownInside = target.closest('[role="menu"]') === menuEl;
        if (!isKeyDownInside)
          return;
        if (FIRST_LAST_KEYS.includes(e.key)) {
          handleMenuNavigation(e, loop.get() ?? false);
        }
        if (e.key === kbd.TAB) {
          e.preventDefault();
          rootOpen.set(false);
          handleTabNavigation(e, nextFocusable, prevFocusable);
          return;
        }
        const isCharacterKey = e.key.length === 1;
        const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
        if (!isModifierKey && isCharacterKey && typeahead.get() === true) {
          handleTypeaheadSearch(e.key, getMenuItems(menuEl));
        }
      }));
      return {
        destroy() {
          unsubDerived();
          unsubEvents();
          unsubPopper();
        }
      };
    }
  });
  const rootTrigger = makeElement(name27("trigger"), {
    stores: [rootOpen, rootIds.menu, rootIds.trigger],
    returned: ([$rootOpen, $rootMenuId, $rootTriggerId]) => {
      return {
        "aria-controls": $rootMenuId,
        "aria-expanded": $rootOpen,
        "data-state": $rootOpen ? "open" : "closed",
        id: $rootTriggerId,
        tabindex: 0
      };
    },
    action: (node) => {
      applyAttrsIfDisabled(node);
      rootActiveTrigger.update((p) => {
        if (p)
          return p;
        return node;
      });
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e) => {
        const $rootOpen = rootOpen.get();
        const triggerEl = e.currentTarget;
        if (!isHTMLElement(triggerEl))
          return;
        handleOpen(triggerEl);
        if (!$rootOpen)
          e.preventDefault();
      }), addMeltEventListener(node, "keydown", (e) => {
        const triggerEl = e.currentTarget;
        if (!isHTMLElement(triggerEl))
          return;
        if (!(SELECTION_KEYS.includes(e.key) || e.key === kbd.ARROW_DOWN))
          return;
        e.preventDefault();
        handleOpen(triggerEl);
        const menuId = triggerEl.getAttribute("aria-controls");
        if (!menuId)
          return;
        const menu = document.getElementById(menuId);
        if (!menu)
          return;
        const menuItems = getMenuItems(menu);
        if (!menuItems.length)
          return;
        handleRovingFocus(menuItems[0]);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const rootArrow = makeElement(name27("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  const overlay = makeElement(name27("overlay"), {
    stores: [isVisible],
    returned: ([$isVisible]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        "aria-hidden": "true",
        "data-state": stateAttr($isVisible)
      };
    },
    action: (node) => {
      let unsubEscapeKeydown = noop;
      if (closeOnEscape.get()) {
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            rootOpen.set(false);
            const $rootActiveTrigger = rootActiveTrigger.get();
            if ($rootActiveTrigger)
              $rootActiveTrigger.focus();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          unsubEscapeKeydown = escapeKeydown.destroy;
        }
      }
      const unsubPortal = effect([portal], ([$portal]) => {
        if ($portal === null)
          return noop;
        const portalDestination = getPortalDestination(node, $portal);
        if (portalDestination === null)
          return noop;
        return usePortal(node, portalDestination).destroy;
      });
      return {
        destroy() {
          unsubEscapeKeydown();
          unsubPortal();
        }
      };
    }
  });
  const item = makeElement(name27("item"), {
    returned: () => {
      return {
        role: "menuitem",
        tabindex: -1,
        "data-orientation": "vertical"
      };
    },
    action: (node) => {
      setMeltMenuAttribute(node, selector10);
      applyAttrsIfDisabled(node);
      const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e) => {
        const itemEl = e.currentTarget;
        if (!isHTMLElement(itemEl))
          return;
        if (isElementDisabled(itemEl)) {
          e.preventDefault();
          return;
        }
      }), addMeltEventListener(node, "click", (e) => {
        const itemEl = e.currentTarget;
        if (!isHTMLElement(itemEl))
          return;
        if (isElementDisabled(itemEl)) {
          e.preventDefault();
          return;
        }
        if (e.defaultPrevented) {
          handleRovingFocus(itemEl);
          return;
        }
        if (closeOnItemClick.get()) {
          sleep(1).then(() => {
            rootOpen.set(false);
          });
        }
      }), addMeltEventListener(node, "keydown", (e) => {
        onItemKeyDown(e);
      }), addMeltEventListener(node, "pointermove", (e) => {
        onMenuItemPointerMove(e);
      }), addMeltEventListener(node, "pointerleave", (e) => {
        onMenuItemPointerLeave(e);
      }), addMeltEventListener(node, "focusin", (e) => {
        onItemFocusIn(e);
      }), addMeltEventListener(node, "focusout", (e) => {
        onItemFocusOut(e);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const group = makeElement(name27("group"), {
    returned: () => {
      return (groupId) => ({
        role: "group",
        "aria-labelledby": groupId
      });
    }
  });
  const groupLabel = makeElement(name27("group-label"), {
    returned: () => {
      return (groupId) => ({
        id: groupId
      });
    }
  });
  const checkboxItemDefaults = {
    defaultChecked: false,
    disabled: false
  };
  const createCheckboxItem = (props) => {
    const withDefaults = { ...checkboxItemDefaults, ...props };
    const checkedWritable = withDefaults.checked ?? writable(withDefaults.defaultChecked ?? null);
    const checked = overridable(checkedWritable, withDefaults.onCheckedChange);
    const disabled = writable(withDefaults.disabled);
    const checkboxItem = makeElement(name27("checkbox-item"), {
      stores: [checked, disabled],
      returned: ([$checked, $disabled]) => {
        return {
          role: "menuitemcheckbox",
          tabindex: -1,
          "data-orientation": "vertical",
          "aria-checked": isIndeterminate($checked) ? "mixed" : $checked ? "true" : "false",
          "data-disabled": disabledAttr($disabled),
          "data-state": getCheckedState($checked)
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector10);
        applyAttrsIfDisabled(node);
        const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            e.preventDefault();
            return;
          }
        }), addMeltEventListener(node, "click", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            e.preventDefault();
            return;
          }
          if (e.defaultPrevented) {
            handleRovingFocus(itemEl);
            return;
          }
          checked.update((prev2) => {
            if (isIndeterminate(prev2))
              return true;
            return !prev2;
          });
          if (closeOnItemClick.get()) {
            tick().then(() => {
              rootOpen.set(false);
            });
          }
        }), addMeltEventListener(node, "keydown", (e) => {
          onItemKeyDown(e);
        }), addMeltEventListener(node, "pointermove", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            onItemLeave(e);
            return;
          }
          onMenuItemPointerMove(e, itemEl);
        }), addMeltEventListener(node, "pointerleave", (e) => {
          onMenuItemPointerLeave(e);
        }), addMeltEventListener(node, "focusin", (e) => {
          onItemFocusIn(e);
        }), addMeltEventListener(node, "focusout", (e) => {
          onItemFocusOut(e);
        }));
        return {
          destroy: unsub
        };
      }
    });
    const isChecked = derived(checked, ($checked) => $checked === true);
    const _isIndeterminate = derived(checked, ($checked) => $checked === "indeterminate");
    return {
      elements: {
        checkboxItem
      },
      states: {
        checked
      },
      helpers: {
        isChecked,
        isIndeterminate: _isIndeterminate
      },
      options: {
        disabled
      }
    };
  };
  const createMenuRadioGroup = (args = {}) => {
    const valueWritable = args.value ?? writable(args.defaultValue ?? null);
    const value = overridable(valueWritable, args.onValueChange);
    const radioGroup = makeElement(name27("radio-group"), {
      returned: () => ({
        role: "group"
      })
    });
    const radioItemDefaults = {
      disabled: false
    };
    const radioItem = makeElement(name27("radio-item"), {
      stores: [value],
      returned: ([$value]) => {
        return (itemProps) => {
          const { value: itemValue, disabled } = { ...radioItemDefaults, ...itemProps };
          const checked = $value === itemValue;
          return {
            disabled,
            role: "menuitemradio",
            "data-state": checked ? "checked" : "unchecked",
            "aria-checked": checked,
            "data-disabled": disabledAttr(disabled),
            "data-value": itemValue,
            "data-orientation": "vertical",
            tabindex: -1
          };
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector10);
        const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            e.preventDefault();
            return;
          }
        }), addMeltEventListener(node, "click", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            e.preventDefault();
            return;
          }
          if (e.defaultPrevented) {
            if (!isHTMLElement(itemEl))
              return;
            handleRovingFocus(itemEl);
            return;
          }
          value.set(itemValue);
          if (closeOnItemClick.get()) {
            tick().then(() => {
              rootOpen.set(false);
            });
          }
        }), addMeltEventListener(node, "keydown", (e) => {
          onItemKeyDown(e);
        }), addMeltEventListener(node, "pointermove", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            onItemLeave(e);
            return;
          }
          onMenuItemPointerMove(e, itemEl);
        }), addMeltEventListener(node, "pointerleave", (e) => {
          onMenuItemPointerLeave(e);
        }), addMeltEventListener(node, "focusin", (e) => {
          onItemFocusIn(e);
        }), addMeltEventListener(node, "focusout", (e) => {
          onItemFocusOut(e);
        }));
        return {
          destroy: unsub
        };
      }
    });
    const isChecked = derived(value, ($value) => {
      return (itemValue) => {
        return $value === itemValue;
      };
    });
    return {
      elements: {
        radioGroup,
        radioItem
      },
      states: {
        value
      },
      helpers: {
        isChecked
      }
    };
  };
  const { elements: { root: separator } } = createSeparator({
    orientation: "horizontal"
  });
  const subMenuDefaults = {
    ...defaults8,
    disabled: false,
    positioning: {
      placement: "right-start",
      gutter: 8
    }
  };
  const createSubmenu = (args) => {
    const withDefaults = { ...subMenuDefaults, ...args };
    const subOpenWritable = withDefaults.open ?? writable(false);
    const subOpen = overridable(subOpenWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
    const options = toWritableStores(omit(withDefaults, "ids"));
    const { positioning: positioning2, arrowSize: arrowSize2, disabled } = options;
    const subActiveTrigger = withGet(writable(null));
    const subOpenTimer = withGet(writable(null));
    const pointerGraceTimer = withGet(writable(0));
    const subIds = toWritableStores({ ...generateIds(menuIdParts), ...withDefaults.ids });
    safeOnMount(() => {
      const subTrigger2 = document.getElementById(subIds.trigger.get());
      if (subTrigger2) {
        subActiveTrigger.set(subTrigger2);
      }
    });
    const subIsVisible = derivedVisible({
      open: subOpen,
      forceVisible,
      activeTrigger: subActiveTrigger
    });
    const subMenu = makeElement(name27("submenu"), {
      stores: [subIsVisible, subIds.menu, subIds.trigger],
      returned: ([$subIsVisible, $subMenuId, $subTriggerId]) => {
        return {
          role: "menu",
          hidden: $subIsVisible ? void 0 : true,
          style: styleToString({
            display: $subIsVisible ? void 0 : "none"
          }),
          id: $subMenuId,
          "aria-labelledby": $subTriggerId,
          "data-state": $subIsVisible ? "open" : "closed",
          // unit tests fail on `.closest` if the id starts with a number
          // so using a data attribute
          "data-id": $subMenuId,
          tabindex: -1
        };
      },
      action: (node) => {
        let unsubPopper = noop;
        const unsubDerived = effect([subIsVisible, positioning2], ([$subIsVisible, $positioning]) => {
          unsubPopper();
          if (!$subIsVisible)
            return;
          const activeTrigger = subActiveTrigger.get();
          if (!activeTrigger)
            return;
          tick().then(() => {
            unsubPopper();
            const parentMenuEl = getParentMenu(activeTrigger);
            unsubPopper = usePopper(node, {
              anchorElement: activeTrigger,
              open: subOpen,
              options: {
                floating: $positioning,
                portal: isHTMLElement(parentMenuEl) ? parentMenuEl : void 0,
                modal: null,
                focusTrap: null,
                escapeKeydown: null
              }
            }).destroy;
          });
        });
        const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => {
          if (e.key === kbd.ESCAPE) {
            return;
          }
          const target = e.target;
          const menuEl = e.currentTarget;
          if (!isHTMLElement(target) || !isHTMLElement(menuEl))
            return;
          const isKeyDownInside = target.closest('[role="menu"]') === menuEl;
          if (!isKeyDownInside)
            return;
          if (FIRST_LAST_KEYS.includes(e.key)) {
            e.stopImmediatePropagation();
            handleMenuNavigation(e, loop.get() ?? false);
            return;
          }
          const isCloseKey = SUB_CLOSE_KEYS["ltr"].includes(e.key);
          const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
          const isCharacterKey = e.key.length === 1;
          if (isCloseKey) {
            const $subActiveTrigger = subActiveTrigger.get();
            e.preventDefault();
            subOpen.update(() => {
              if ($subActiveTrigger) {
                handleRovingFocus($subActiveTrigger);
              }
              return false;
            });
            return;
          }
          if (e.key === kbd.TAB) {
            e.preventDefault();
            rootOpen.set(false);
            handleTabNavigation(e, nextFocusable, prevFocusable);
            return;
          }
          if (!isModifierKey && isCharacterKey && typeahead.get() === true) {
            handleTypeaheadSearch(e.key, getMenuItems(menuEl));
          }
        }), addMeltEventListener(node, "pointermove", (e) => {
          onMenuPointerMove(e);
        }), addMeltEventListener(node, "focusout", (e) => {
          const $subActiveTrigger = subActiveTrigger.get();
          if (isUsingKeyboard.get()) {
            const target = e.target;
            const submenuEl = document.getElementById(subIds.menu.get());
            if (!isHTMLElement(submenuEl) || !isHTMLElement(target))
              return;
            if (!submenuEl.contains(target) && target !== $subActiveTrigger) {
              subOpen.set(false);
            }
          } else {
            const menuEl = e.currentTarget;
            const relatedTarget = e.relatedTarget;
            if (!isHTMLElement(relatedTarget) || !isHTMLElement(menuEl))
              return;
            if (!menuEl.contains(relatedTarget) && relatedTarget !== $subActiveTrigger) {
              subOpen.set(false);
            }
          }
        }));
        return {
          destroy() {
            unsubDerived();
            unsubPopper();
            unsubEvents();
          }
        };
      }
    });
    const subTrigger = makeElement(name27("subtrigger"), {
      stores: [subOpen, disabled, subIds.menu, subIds.trigger],
      returned: ([$subOpen, $disabled, $subMenuId, $subTriggerId]) => {
        return {
          role: "menuitem",
          id: $subTriggerId,
          tabindex: -1,
          "aria-controls": $subMenuId,
          "aria-expanded": $subOpen,
          "data-state": $subOpen ? "open" : "closed",
          "data-disabled": disabledAttr($disabled),
          "aria-haspopop": "menu"
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector10);
        applyAttrsIfDisabled(node);
        subActiveTrigger.update((p) => {
          if (p)
            return p;
          return node;
        });
        const unsubTimer = () => {
          clearTimerStore(subOpenTimer);
          window.clearTimeout(pointerGraceTimer.get());
          pointerGraceIntent.set(null);
        };
        const unsubEvents = executeCallbacks(addMeltEventListener(node, "click", (e) => {
          if (e.defaultPrevented)
            return;
          const triggerEl = e.currentTarget;
          if (!isHTMLElement(triggerEl) || isElementDisabled(triggerEl))
            return;
          handleRovingFocus(triggerEl);
          if (!subOpen.get()) {
            subOpen.update((prev2) => {
              const isAlreadyOpen = prev2;
              if (!isAlreadyOpen) {
                subActiveTrigger.set(triggerEl);
                return !prev2;
              }
              return prev2;
            });
          }
        }), addMeltEventListener(node, "keydown", (e) => {
          const $typed = typed.get();
          const triggerEl = e.currentTarget;
          if (!isHTMLElement(triggerEl) || isElementDisabled(triggerEl))
            return;
          const isTypingAhead = $typed.length > 0;
          if (isTypingAhead && e.key === kbd.SPACE)
            return;
          if (SUB_OPEN_KEYS["ltr"].includes(e.key)) {
            if (!subOpen.get()) {
              triggerEl.click();
              e.preventDefault();
              return;
            }
            const menuId = triggerEl.getAttribute("aria-controls");
            if (!menuId)
              return;
            const menuEl = document.getElementById(menuId);
            if (!isHTMLElement(menuEl))
              return;
            const firstItem = getMenuItems(menuEl)[0];
            handleRovingFocus(firstItem);
          }
        }), addMeltEventListener(node, "pointermove", (e) => {
          if (!isMouse(e))
            return;
          onItemEnter(e);
          if (e.defaultPrevented)
            return;
          const triggerEl = e.currentTarget;
          if (!isHTMLElement(triggerEl))
            return;
          if (!isFocusWithinSubmenu(subIds.menu.get())) {
            handleRovingFocus(triggerEl);
          }
          const openTimer = subOpenTimer.get();
          if (!subOpen.get() && !openTimer && !isElementDisabled(triggerEl)) {
            subOpenTimer.set(window.setTimeout(() => {
              subOpen.update(() => {
                subActiveTrigger.set(triggerEl);
                return true;
              });
              clearTimerStore(subOpenTimer);
            }, 100));
          }
        }), addMeltEventListener(node, "pointerleave", (e) => {
          if (!isMouse(e))
            return;
          clearTimerStore(subOpenTimer);
          const submenuEl = document.getElementById(subIds.menu.get());
          const contentRect = submenuEl == null ? void 0 : submenuEl.getBoundingClientRect();
          if (contentRect) {
            const side = submenuEl == null ? void 0 : submenuEl.dataset.side;
            const rightSide = side === "right";
            const bleed = rightSide ? -5 : 5;
            const contentNearEdge = contentRect[rightSide ? "left" : "right"];
            const contentFarEdge = contentRect[rightSide ? "right" : "left"];
            pointerGraceIntent.set({
              area: [
                // Apply a bleed on clientX to ensure that our exit point is
                // consistently within polygon bounds
                { x: e.clientX + bleed, y: e.clientY },
                { x: contentNearEdge, y: contentRect.top },
                { x: contentFarEdge, y: contentRect.top },
                { x: contentFarEdge, y: contentRect.bottom },
                { x: contentNearEdge, y: contentRect.bottom }
              ],
              side
            });
            window.clearTimeout(pointerGraceTimer.get());
            pointerGraceTimer.set(window.setTimeout(() => {
              pointerGraceIntent.set(null);
            }, 300));
          } else {
            onTriggerLeave(e);
            if (e.defaultPrevented)
              return;
            pointerGraceIntent.set(null);
          }
        }), addMeltEventListener(node, "focusout", (e) => {
          const triggerEl = e.currentTarget;
          if (!isHTMLElement(triggerEl))
            return;
          removeHighlight(triggerEl);
          const relatedTarget = e.relatedTarget;
          if (!isHTMLElement(relatedTarget))
            return;
          const menuId = triggerEl.getAttribute("aria-controls");
          if (!menuId)
            return;
          const menu = document.getElementById(menuId);
          if (menu && !menu.contains(relatedTarget)) {
            subOpen.set(false);
          }
        }), addMeltEventListener(node, "focusin", (e) => {
          onItemFocusIn(e);
        }));
        return {
          destroy() {
            unsubTimer();
            unsubEvents();
          }
        };
      }
    });
    const subArrow = makeElement(name27("subarrow"), {
      stores: arrowSize2,
      returned: ($arrowSize) => ({
        "data-arrow": true,
        style: styleToString({
          position: "absolute",
          width: `var(--arrow-size, ${$arrowSize}px)`,
          height: `var(--arrow-size, ${$arrowSize}px)`
        })
      })
    });
    effect([rootOpen], ([$rootOpen]) => {
      if (!$rootOpen) {
        subActiveTrigger.set(null);
        subOpen.set(false);
      }
    });
    effect([pointerGraceIntent], ([$pointerGraceIntent]) => {
      if (!isBrowser || $pointerGraceIntent)
        return;
      window.clearTimeout(pointerGraceTimer.get());
    });
    effect([subOpen], ([$subOpen]) => {
      if (!isBrowser)
        return;
      if ($subOpen && isUsingKeyboard.get()) {
        sleep(1).then(() => {
          const menuEl = document.getElementById(subIds.menu.get());
          if (!menuEl)
            return;
          const menuItems = getMenuItems(menuEl);
          if (!menuItems.length)
            return;
          handleRovingFocus(menuItems[0]);
        });
      }
      if (!$subOpen) {
        const focusedItem = currentFocusedItem.get();
        const subTriggerEl = document.getElementById(subIds.trigger.get());
        if (focusedItem) {
          sleep(1).then(() => {
            const menuEl = document.getElementById(subIds.menu.get());
            if (!menuEl)
              return;
            if (menuEl.contains(focusedItem)) {
              removeHighlight(focusedItem);
            }
          });
        }
        if (!subTriggerEl || document.activeElement === subTriggerEl)
          return;
        removeHighlight(subTriggerEl);
      }
    });
    return {
      ids: subIds,
      elements: {
        subTrigger,
        subMenu,
        subArrow
      },
      states: {
        subOpen
      },
      options
    };
  };
  safeOnMount(() => {
    const triggerEl = document.getElementById(rootIds.trigger.get());
    if (isHTMLElement(triggerEl) && rootOpen.get()) {
      rootActiveTrigger.set(triggerEl);
    }
    const unsubs = [];
    const handlePointer = () => isUsingKeyboard.set(false);
    const handleKeyDown = () => {
      isUsingKeyboard.set(true);
      unsubs.push(executeCallbacks(addEventListener(document, "pointerdown", handlePointer, { capture: true, once: true }), addEventListener(document, "pointermove", handlePointer, { capture: true, once: true })));
    };
    const keydownListener = (e) => {
      if (e.key === kbd.ESCAPE && closeOnEscape.get()) {
        rootOpen.set(false);
        return;
      }
    };
    unsubs.push(addEventListener(document, "keydown", handleKeyDown, { capture: true }));
    unsubs.push(addEventListener(document, "keydown", keydownListener));
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  effect([rootOpen, currentFocusedItem], ([$rootOpen, $currentFocusedItem]) => {
    if (!$rootOpen && $currentFocusedItem) {
      removeHighlight($currentFocusedItem);
    }
  });
  effect([rootOpen], ([$rootOpen]) => {
    if (!isBrowser)
      return;
    if (!$rootOpen) {
      const $rootActiveTrigger = rootActiveTrigger.get();
      if (!$rootActiveTrigger)
        return;
      const $closeFocus = closeFocus.get();
      if (!$rootOpen && $rootActiveTrigger) {
        handleFocus({ prop: $closeFocus, defaultEl: $rootActiveTrigger });
      }
    }
  });
  effect([rootOpen, preventScroll], ([$rootOpen, $preventScroll]) => {
    if (!isBrowser)
      return;
    const unsubs = [];
    if (opts.removeScroll && $rootOpen && $preventScroll) {
      unsubs.push(removeScroll());
    }
    sleep(1).then(() => {
      const menuEl = document.getElementById(rootIds.menu.get());
      if (menuEl && $rootOpen && isUsingKeyboard.get()) {
        if (disableFocusFirstItem.get()) {
          handleRovingFocus(menuEl);
          return;
        }
        const menuItems = getMenuItems(menuEl);
        if (!menuItems.length)
          return;
        handleRovingFocus(menuItems[0]);
      }
    });
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  effect(rootOpen, ($rootOpen) => {
    if (!isBrowser)
      return;
    const handlePointer = () => isUsingKeyboard.set(false);
    const handleKeyDown = (e) => {
      isUsingKeyboard.set(true);
      if (e.key === kbd.ESCAPE && $rootOpen && closeOnEscape.get()) {
        rootOpen.set(false);
        return;
      }
    };
    return executeCallbacks(addEventListener(document, "pointerdown", handlePointer, { capture: true, once: true }), addEventListener(document, "pointermove", handlePointer, { capture: true, once: true }), addEventListener(document, "keydown", handleKeyDown, { capture: true }));
  });
  function handleOpen(triggerEl) {
    rootOpen.update((prev2) => {
      const isOpen = !prev2;
      if (isOpen) {
        nextFocusable.set(getNextFocusable(triggerEl));
        prevFocusable.set(getPreviousFocusable(triggerEl));
        rootActiveTrigger.set(triggerEl);
      }
      return isOpen;
    });
  }
  function onItemFocusIn(e) {
    const itemEl = e.currentTarget;
    if (!isHTMLElement(itemEl))
      return;
    const $currentFocusedItem = currentFocusedItem.get();
    if ($currentFocusedItem) {
      removeHighlight($currentFocusedItem);
    }
    addHighlight(itemEl);
    currentFocusedItem.set(itemEl);
  }
  function onItemFocusOut(e) {
    const itemEl = e.currentTarget;
    if (!isHTMLElement(itemEl))
      return;
    removeHighlight(itemEl);
  }
  function onItemEnter(e) {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  }
  function onItemLeave(e) {
    if (isPointerMovingToSubmenu(e)) {
      return;
    }
    const target = e.target;
    if (!isHTMLElement(target))
      return;
    const parentMenuEl = getParentMenu(target);
    if (!parentMenuEl)
      return;
    handleRovingFocus(parentMenuEl);
  }
  function onTriggerLeave(e) {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  }
  function onMenuPointerMove(e) {
    if (!isMouse(e))
      return;
    const target = e.target;
    const currentTarget = e.currentTarget;
    if (!isHTMLElement(currentTarget) || !isHTMLElement(target))
      return;
    const $lastPointerX = lastPointerX.get();
    const pointerXHasChanged = $lastPointerX !== e.clientX;
    if (currentTarget.contains(target) && pointerXHasChanged) {
      const newDir = e.clientX > $lastPointerX ? "right" : "left";
      pointerDir.set(newDir);
      lastPointerX.set(e.clientX);
    }
  }
  function onMenuItemPointerMove(e, currTarget = null) {
    if (!isMouse(e))
      return;
    onItemEnter(e);
    if (e.defaultPrevented)
      return;
    if (currTarget) {
      handleRovingFocus(currTarget);
      return;
    }
    const currentTarget = e.currentTarget;
    if (!isHTMLElement(currentTarget))
      return;
    handleRovingFocus(currentTarget);
  }
  function onMenuItemPointerLeave(e) {
    if (!isMouse(e))
      return;
    onItemLeave(e);
  }
  function onItemKeyDown(e) {
    const $typed = typed.get();
    const isTypingAhead = $typed.length > 0;
    if (isTypingAhead && e.key === kbd.SPACE) {
      e.preventDefault();
      return;
    }
    if (SELECTION_KEYS.includes(e.key)) {
      e.preventDefault();
      const itemEl = e.currentTarget;
      if (!isHTMLElement(itemEl))
        return;
      itemEl.click();
    }
  }
  function isIndeterminate(checked) {
    return checked === "indeterminate";
  }
  function getCheckedState(checked) {
    return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
  }
  function isPointerMovingToSubmenu(e) {
    return pointerMovingToSubmenu.get()(e);
  }
  function getParentMenu(element2) {
    const parentMenuEl = element2.closest('[role="menu"]');
    if (!isHTMLElement(parentMenuEl))
      return null;
    return parentMenuEl;
  }
  return {
    elements: {
      trigger: rootTrigger,
      menu: rootMenu,
      overlay,
      item,
      group,
      groupLabel,
      arrow: rootArrow,
      separator
    },
    builders: {
      createCheckboxItem,
      createSubmenu,
      createMenuRadioGroup
    },
    states: {
      open: rootOpen
    },
    helpers: {
      handleTypeaheadSearch
    },
    ids: rootIds,
    options: opts.rootOptions
  };
}
function handleTabNavigation(e, nextFocusable, prevFocusable) {
  if (e.shiftKey) {
    const $prevFocusable = prevFocusable.get();
    if ($prevFocusable) {
      e.preventDefault();
      sleep(1).then(() => $prevFocusable.focus());
      prevFocusable.set(null);
    }
  } else {
    const $nextFocusable = nextFocusable.get();
    if ($nextFocusable) {
      e.preventDefault();
      sleep(1).then(() => $nextFocusable.focus());
      nextFocusable.set(null);
    }
  }
}
function getMenuItems(menuElement) {
  return Array.from(menuElement.querySelectorAll(`[data-melt-menu-id="${menuElement.id}"]`)).filter((item) => isHTMLElement(item));
}
function applyAttrsIfDisabled(element2) {
  if (!element2 || !isElementDisabled(element2))
    return;
  element2.setAttribute("data-disabled", "");
  element2.setAttribute("aria-disabled", "true");
}
function clearTimerStore(timerStore) {
  if (!isBrowser)
    return;
  const timer = timerStore.get();
  if (timer) {
    window.clearTimeout(timer);
    timerStore.set(null);
  }
}
function isMouse(e) {
  return e.pointerType === "mouse";
}
function setMeltMenuAttribute(element2, selector10) {
  if (!element2)
    return;
  const menuEl = element2.closest(`${selector10()}, ${selector10("submenu")}`);
  if (!isHTMLElement(menuEl))
    return;
  element2.setAttribute("data-melt-menu-id", menuEl.id);
}
function handleMenuNavigation(e, loop) {
  e.preventDefault();
  const currentFocusedItem = document.activeElement;
  const currentTarget = e.currentTarget;
  if (!isHTMLElement(currentFocusedItem) || !isHTMLElement(currentTarget))
    return;
  const menuItems = getMenuItems(currentTarget);
  if (!menuItems.length)
    return;
  const candidateNodes = menuItems.filter((item) => {
    if (item.hasAttribute("data-disabled") || item.getAttribute("disabled") === "true") {
      return false;
    }
    return true;
  });
  const currentIndex = candidateNodes.indexOf(currentFocusedItem);
  let nextIndex;
  switch (e.key) {
    case kbd.ARROW_DOWN:
      if (loop) {
        nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : 0;
      } else {
        nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : currentIndex;
      }
      break;
    case kbd.ARROW_UP:
      if (loop) {
        nextIndex = currentIndex > 0 ? currentIndex - 1 : candidateNodes.length - 1;
      } else {
        nextIndex = currentIndex < 0 ? candidateNodes.length - 1 : currentIndex > 0 ? currentIndex - 1 : 0;
      }
      break;
    case kbd.HOME:
      nextIndex = 0;
      break;
    case kbd.END:
      nextIndex = candidateNodes.length - 1;
      break;
    default:
      return;
  }
  handleRovingFocus(candidateNodes[nextIndex]);
}
function isPointerInGraceArea(e, area) {
  if (!area)
    return false;
  const cursorPos = { x: e.clientX, y: e.clientY };
  return isPointInPolygon(cursorPos, area);
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function isFocusWithinSubmenu(submenuId) {
  const activeEl = document.activeElement;
  if (!isHTMLElement(activeEl))
    return false;
  const submenuEl = activeEl.closest(`[data-id="${submenuId}"]`);
  return isHTMLElement(submenuEl);
}
function stateAttr(open) {
  return open ? "open" : "closed";
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/context-menu/create.js
var defaults9 = {
  arrowSize: 8,
  positioning: {
    placement: "bottom-start"
  },
  preventScroll: true,
  closeOnEscape: true,
  closeOnOutsideClick: true,
  portal: void 0,
  loop: false,
  dir: "ltr",
  defaultOpen: false,
  forceVisible: false,
  typeahead: true,
  disableFocusFirstItem: true,
  closeFocus: void 0,
  closeOnItemClick: true,
  onOutsideClick: void 0
};
var { name: name4, selector: selector2 } = createElHelpers("context-menu");
function createContextMenu(props) {
  const withDefaults = { ...defaults9, ...props };
  const rootOptions = toWritableStores(omit(withDefaults, "ids"));
  const { positioning, closeOnOutsideClick, portal, forceVisible, closeOnEscape, loop } = rootOptions;
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const rootOpen = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const rootActiveTrigger = writable(null);
  const nextFocusable = withGet.writable(null);
  const prevFocusable = withGet.writable(null);
  const { elements, builders, ids, options, helpers, states } = createMenuBuilder({
    rootOpen,
    rootOptions,
    rootActiveTrigger: withGet(rootActiveTrigger),
    nextFocusable: withGet(nextFocusable),
    prevFocusable: withGet(prevFocusable),
    selector: "context-menu",
    removeScroll: true,
    ids: withDefaults.ids
  });
  const { handleTypeaheadSearch } = helpers;
  const point = writable(null);
  const virtual = withGet(derived([point], ([$point]) => {
    if ($point === null)
      return null;
    return {
      getBoundingClientRect: () => DOMRect.fromRect({
        width: 0,
        height: 0,
        ...$point
      })
    };
  }));
  const longPressTimer = withGet.writable(0);
  function handleClickOutside(e) {
    var _a;
    (_a = rootOptions.onOutsideClick.get()) == null ? void 0 : _a(e);
    if (e.defaultPrevented)
      return false;
    const target = e.target;
    if (!(target instanceof Element))
      return false;
    const isClickInsideTrigger = target.closest(`[data-id="${ids.trigger.get()}"]`) !== null;
    if (!isClickInsideTrigger || isLeftClick(e)) {
      return true;
    }
    return false;
  }
  const isVisible = derivedVisible({
    open: rootOpen,
    forceVisible,
    activeTrigger: rootActiveTrigger
  });
  const menu = makeElement(name4(), {
    stores: [isVisible, portal, ids.menu, ids.trigger],
    returned: ([$isVisible, $portal, $menuId, $triggerId]) => {
      return {
        role: "menu",
        hidden: $isVisible ? void 0 : true,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        id: $menuId,
        "aria-labelledby": $triggerId,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": portalAttr($portal),
        tabindex: -1
      };
    },
    action: (node) => {
      let unsubPopper = noop;
      const unsubDerived = effect([isVisible, rootActiveTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $rootActiveTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape]) => {
        unsubPopper();
        if (!$isVisible || !$rootActiveTrigger)
          return;
        tick().then(() => {
          unsubPopper();
          setMeltMenuAttribute(node, selector2);
          const $virtual = virtual.get();
          unsubPopper = usePopper(node, {
            anchorElement: $virtual ? $virtual : $rootActiveTrigger,
            open: rootOpen,
            options: {
              floating: $positioning,
              modal: {
                closeOnInteractOutside: $closeOnOutsideClick,
                onClose: () => {
                  rootOpen.set(false);
                },
                shouldCloseOnInteractOutside: handleClickOutside,
                open: $isVisible
              },
              portal: getPortalDestination(node, $portal),
              escapeKeydown: $closeOnEscape ? void 0 : null
            }
          }).destroy;
        });
      });
      const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => {
        const target = e.target;
        const menuEl = e.currentTarget;
        if (!isHTMLElement(target) || !isHTMLElement(menuEl))
          return;
        const isKeyDownInside = target.closest("[role='menu']") === menuEl;
        if (!isKeyDownInside)
          return;
        if (FIRST_LAST_KEYS.includes(e.key)) {
          handleMenuNavigation(e, loop.get());
        }
        if (e.key === kbd.TAB) {
          e.preventDefault();
          rootOpen.set(false);
          handleTabNavigation(e, nextFocusable, prevFocusable);
          return;
        }
        const isCharacterKey = e.key.length === 1;
        const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
        if (!isModifierKey && isCharacterKey) {
          handleTypeaheadSearch(e.key, getMenuItems(menuEl));
        }
      }));
      return {
        destroy() {
          unsubDerived();
          unsubEvents();
          unsubPopper();
        }
      };
    }
  });
  const trigger = makeElement(name4("trigger"), {
    stores: [rootOpen, ids.trigger],
    returned: ([$rootOpen, $triggerId]) => {
      return {
        "data-state": $rootOpen ? "open" : "closed",
        id: $triggerId,
        style: styleToString({
          WebkitTouchCallout: "none"
        }),
        "data-id": $triggerId
      };
    },
    action: (node) => {
      applyAttrsIfDisabled(node);
      const handleOpen = (e) => {
        point.set({
          x: e.clientX,
          y: e.clientY
        });
        nextFocusable.set(getNextFocusable(node));
        prevFocusable.set(getPreviousFocusable(node));
        rootActiveTrigger.set(node);
        rootOpen.set(true);
      };
      const unsubTimer = () => {
        clearTimerStore(longPressTimer);
      };
      const unsub = executeCallbacks(addMeltEventListener(node, "contextmenu", (e) => {
        clearTimerStore(longPressTimer);
        handleOpen(e);
        e.preventDefault();
      }), addMeltEventListener(node, "pointerdown", (e) => {
        if (!isTouchOrPen(e))
          return;
        clearTimerStore(longPressTimer);
        longPressTimer.set(window.setTimeout(() => handleOpen(e), 700));
      }), addMeltEventListener(node, "pointermove", (e) => {
        if (!isTouchOrPen(e))
          return;
        clearTimerStore(longPressTimer);
      }), addMeltEventListener(node, "pointercancel", (e) => {
        if (!isTouchOrPen(e))
          return;
        clearTimerStore(longPressTimer);
      }), addMeltEventListener(node, "pointerup", (e) => {
        if (!isTouchOrPen(e))
          return;
        clearTimerStore(longPressTimer);
      }));
      return {
        destroy() {
          unsubTimer();
          unsub();
        }
      };
    }
  });
  return {
    ids,
    elements: {
      ...elements,
      menu,
      trigger
    },
    states,
    builders,
    options
  };
}
function isTouchOrPen(e) {
  return e.pointerType !== "mouse";
}
function isLeftClick(event2) {
  if ("button" in event2) {
    return event2.button === 0 && event2.ctrlKey === false && event2.metaKey === false;
  }
  return true;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/date/utils.js
var defaultDateDefaults = {
  defaultValue: void 0,
  defaultPlaceholder: void 0,
  granularity: "day"
};
function getDefaultDate(props) {
  const withDefaults = { ...defaultDateDefaults, ...props };
  const { defaultValue, defaultPlaceholder, granularity } = withDefaults;
  if (Array.isArray(defaultValue) && defaultValue.length) {
    return defaultValue[defaultValue.length - 1];
  }
  if (defaultValue && !Array.isArray(defaultValue)) {
    return defaultValue;
  } else if (defaultPlaceholder) {
    return defaultPlaceholder;
  } else {
    const date = /* @__PURE__ */ new Date();
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const calendarDateTimeGranularities = ["hour", "minute", "second"];
    if (calendarDateTimeGranularities.includes(granularity ?? "day")) {
      return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(year, month, day, 0, 0, 0);
    }
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(year, month, day);
  }
}
function parseStringToDateValue(dateStr, referenceVal) {
  let dateValue;
  if (referenceVal instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea) {
    dateValue = $fae977aafc393c5c$export$fd7893f06e92a6a4(dateStr);
  } else if (referenceVal instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f) {
    dateValue = $fae977aafc393c5c$export$588937bcd60ade55(dateStr);
  } else {
    dateValue = $fae977aafc393c5c$export$6b862160d295c8e(dateStr);
  }
  return dateValue.calendar !== referenceVal.calendar ? $11d87f3f76e88657$export$b4a036af3fc0b032(dateValue, referenceVal.calendar) : dateValue;
}
function toDate(dateValue, tz = $14e0f24ef4ac5c92$export$aa8b41735afcabd2()) {
  if (dateValue instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea) {
    return dateValue.toDate();
  } else {
    return dateValue.toDate(tz);
  }
}
function isCalendarDateTime(dateValue) {
  return dateValue instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f;
}
function isZonedDateTime(dateValue) {
  return dateValue instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea;
}
function hasTime(dateValue) {
  return isCalendarDateTime(dateValue) || isZonedDateTime(dateValue);
}
function getDaysInMonth(date) {
  if (date instanceof Date) {
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    return new Date(year, month, 0).getDate();
  } else {
    return date.set({ day: 100 }).day;
  }
}
function isBefore(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) < 0;
}
function isAfter(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) > 0;
}
function isBeforeOrSame(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) <= 0;
}
function isAfterOrSame(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) >= 0;
}
function isBetweenInclusive(date, start, end) {
  return isAfterOrSame(date, start) && isBeforeOrSame(date, end);
}
function getLastFirstDayOfWeek(date, firstDayOfWeek, locale) {
  const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
  if (firstDayOfWeek > day) {
    return date.subtract({ days: day + 7 - firstDayOfWeek });
  }
  if (firstDayOfWeek === day) {
    return date;
  }
  return date.subtract({ days: day - firstDayOfWeek });
}
function getNextLastDayOfWeek(date, firstDayOfWeek, locale) {
  const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
  const lastDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
  if (day === lastDayOfWeek) {
    return date;
  }
  if (day > lastDayOfWeek) {
    return date.add({ days: 7 - day + lastDayOfWeek });
  }
  return date.add({ days: lastDayOfWeek - day });
}
function areAllDaysBetweenValid(start, end, isUnavailable, isDisabled) {
  if (isUnavailable === void 0 && isDisabled === void 0) {
    return true;
  }
  let dCurrent = start.add({ days: 1 });
  if ((isDisabled == null ? void 0 : isDisabled(dCurrent)) || (isUnavailable == null ? void 0 : isUnavailable(dCurrent))) {
    return false;
  }
  const dEnd = end;
  while (dCurrent.compare(dEnd) < 0) {
    dCurrent = dCurrent.add({ days: 1 });
    if ((isDisabled == null ? void 0 : isDisabled(dCurrent)) || (isUnavailable == null ? void 0 : isUnavailable(dCurrent))) {
      return false;
    }
  }
  return true;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/date/formatter.js
function createFormatter(initialLocale) {
  let locale = initialLocale;
  function setLocale(newLocale) {
    locale = newLocale;
  }
  function getLocale() {
    return locale;
  }
  function custom(date, options) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).format(date);
  }
  function selectedDate(date, includeTime = true) {
    if (hasTime(date) && includeTime) {
      return custom(toDate(date), {
        dateStyle: "long",
        timeStyle: "long"
      });
    } else {
      return custom(toDate(date), {
        dateStyle: "long"
      });
    }
  }
  function fullMonthAndYear(date) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { month: "long", year: "numeric" }).format(date);
  }
  function fullMonth(date) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { month: "long" }).format(date);
  }
  function fullYear(date) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { year: "numeric" }).format(date);
  }
  function toParts(date, options) {
    if (isZonedDateTime(date)) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
        ...options,
        timeZone: date.timeZone
      }).formatToParts(toDate(date));
    } else {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).formatToParts(toDate(date));
    }
  }
  function dayOfWeek(date, length = "narrow") {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: length }).format(date);
  }
  function dayPeriod(date) {
    var _a;
    const parts = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
      hour: "numeric",
      minute: "numeric"
    }).formatToParts(date);
    const value = (_a = parts.find((p) => p.type === "dayPeriod")) == null ? void 0 : _a.value;
    if (value === "PM") {
      return "PM";
    }
    return "AM";
  }
  const defaultPartOptions = {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  };
  function part(dateObj, type, options = {}) {
    const opts = { ...defaultPartOptions, ...options };
    const parts = toParts(dateObj, opts);
    const part2 = parts.find((p) => p.type === type);
    return part2 ? part2.value : "";
  }
  return {
    setLocale,
    getLocale,
    fullMonth,
    fullYear,
    fullMonthAndYear,
    toParts,
    custom,
    part,
    dayPeriod,
    selectedDate,
    dayOfWeek
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/date/store.js
function dateStore(store, defaultValue) {
  const { set: set2, update, subscribe, get: get3 } = withGet(store);
  function add(duration) {
    update((d) => {
      return d.add(duration);
    });
  }
  function nextPage(amount) {
    update((d) => {
      return d.set({ day: 1 }).add({ months: amount });
    });
  }
  function prevPage(amount) {
    update((d) => {
      return d.set({ day: 1 }).subtract({ months: amount });
    });
  }
  function subtract(duration) {
    update((d) => {
      return d.subtract(duration);
    });
  }
  function setDate(fields, disambiguation) {
    if (disambiguation) {
      update((d) => {
        return d.set(fields, disambiguation);
      });
      return;
    }
    update((d) => {
      return d.set(fields);
    });
  }
  function reset2() {
    update(() => {
      return defaultValue;
    });
  }
  function toWritable() {
    return {
      set: set2,
      subscribe,
      update,
      get: get3
    };
  }
  return {
    get: get3,
    set: set2,
    update,
    subscribe,
    add,
    subtract,
    setDate,
    reset: reset2,
    toWritable,
    nextPage,
    prevPage
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/date/placeholders.js
var supportedLocales = [
  "ach",
  "af",
  "am",
  "an",
  "ar",
  "ast",
  "az",
  "be",
  "bg",
  "bn",
  "br",
  "bs",
  "ca",
  "cak",
  "ckb",
  "cs",
  "cy",
  "da",
  "de",
  "dsb",
  "el",
  "en",
  "eo",
  "es",
  "et",
  "eu",
  "fa",
  "ff",
  "fi",
  "fr",
  "fy",
  "ga",
  "gd",
  "gl",
  "he",
  "hr",
  "hsb",
  "hu",
  "ia",
  "id",
  "it",
  "ja",
  "ka",
  "kk",
  "kn",
  "ko",
  "lb",
  "lo",
  "lt",
  "lv",
  "meh",
  "ml",
  "ms",
  "nl",
  "nn",
  "no",
  "oc",
  "pl",
  "pt",
  "rm",
  "ro",
  "ru",
  "sc",
  "scn",
  "sk",
  "sl",
  "sr",
  "sv",
  "szl",
  "tg",
  "th",
  "tr",
  "uk",
  "zh-CN",
  "zh-TW"
];
var placeholderFields = ["year", "month", "day"];
var placeholders = {
  ach: { year: "mwaka", month: "dwe", day: "nino" },
  af: { year: "jjjj", month: "mm", day: "dd" },
  am: { year: "", month: "", day: "" },
  an: { year: "aaaa", month: "mm", day: "dd" },
  ar: { year: "", month: "", day: "" },
  ast: { year: "aaaa", month: "mm", day: "dd" },
  az: { year: "iiii", month: "aa", day: "gg" },
  be: { year: "", month: "", day: "" },
  bg: { year: "", month: "", day: "" },
  bn: { year: "yyyy", month: "", day: "dd" },
  br: { year: "bbbb", month: "mm", day: "dd" },
  bs: { year: "gggg", month: "mm", day: "dd" },
  ca: { year: "aaaa", month: "mm", day: "dd" },
  cak: { year: "jjjj", month: "ii", day: "q'q'" },
  ckb: { year: "", month: "", day: "" },
  cs: { year: "rrrr", month: "mm", day: "dd" },
  cy: { year: "bbbb", month: "mm", day: "dd" },
  da: { year: "", month: "mm", day: "dd" },
  de: { year: "jjjj", month: "mm", day: "tt" },
  dsb: { year: "llll", month: "mm", day: "" },
  el: { year: "", month: "", day: "" },
  en: { year: "yyyy", month: "mm", day: "dd" },
  eo: { year: "jjjj", month: "mm", day: "tt" },
  es: { year: "aaaa", month: "mm", day: "dd" },
  et: { year: "aaaa", month: "kk", day: "pp" },
  eu: { year: "uuuu", month: "hh", day: "ee" },
  fa: { year: "", month: "", day: "" },
  ff: { year: "hhhh", month: "ll", day: "" },
  fi: { year: "vvvv", month: "kk", day: "pp" },
  fr: { year: "aaaa", month: "mm", day: "jj" },
  fy: { year: "jjjj", month: "mm", day: "dd" },
  ga: { year: "bbbb", month: "mm", day: "ll" },
  gd: { year: "bbbb", month: "mm", day: "ll" },
  gl: { year: "aaaa", month: "mm", day: "dd" },
  he: { year: "", month: "", day: "" },
  hr: { year: "gggg", month: "mm", day: "dd" },
  hsb: { year: "llll", month: "mm", day: "dd" },
  hu: { year: "", month: "hh", day: "nn" },
  ia: { year: "aaaa", month: "mm", day: "dd" },
  id: { year: "tttt", month: "bb", day: "hh" },
  it: { year: "aaaa", month: "mm", day: "gg" },
  ja: { year: "  ", month: "", day: "" },
  ka: { year: "", month: "", day: "" },
  kk: { year: "", month: "", day: "" },
  kn: { year: "", month: "", day: "" },
  ko: { year: "", month: "", day: "" },
  lb: { year: "jjjj", month: "mm", day: "dd" },
  lo: { year: "", month: "", day: "" },
  lt: { year: "mmmm", month: "mm", day: "dd" },
  lv: { year: "gggg", month: "mm", day: "dd" },
  meh: { year: "aaaa", month: "mm", day: "dd" },
  ml: { year: "", month: "", day: "" },
  ms: { year: "tttt", month: "mm", day: "hh" },
  nl: { year: "jjjj", month: "mm", day: "dd" },
  nn: { year: "", month: "mm", day: "dd" },
  no: { year: "", month: "mm", day: "dd" },
  oc: { year: "aaaa", month: "mm", day: "jj" },
  pl: { year: "rrrr", month: "mm", day: "dd" },
  pt: { year: "aaaa", month: "mm", day: "dd" },
  rm: { year: "oooo", month: "mm", day: "dd" },
  ro: { year: "aaaa", month: "ll", day: "zz" },
  ru: { year: "", month: "", day: "" },
  sc: { year: "aaaa", month: "mm", day: "dd" },
  scn: { year: "aaaa", month: "mm", day: "jj" },
  sk: { year: "rrrr", month: "mm", day: "dd" },
  sl: { year: "llll", month: "mm", day: "dd" },
  sr: { year: "", month: "", day: "" },
  sv: { year: "", month: "mm", day: "dd" },
  szl: { year: "rrrr", month: "mm", day: "dd" },
  tg: { year: "", month: "", day: "" },
  th: { year: "", month: "", day: "" },
  tr: { year: "yyyy", month: "aa", day: "gg" },
  uk: { year: "", month: "", day: "" },
  "zh-CN": { year: "", month: "", day: "" },
  "zh-TW": { year: "", month: "", day: "" }
};
function getPlaceholderObj(locale) {
  if (!isSupportedLocale(locale)) {
    const localeLanguage = getLocaleLanguage(locale);
    if (!isSupportedLocale(localeLanguage)) {
      return placeholders.en;
    } else {
      return placeholders[localeLanguage];
    }
  } else {
    return placeholders[locale];
  }
}
function getPlaceholder(field, value, locale) {
  if (isPlaceholderField(field)) {
    return getPlaceholderObj(locale)[field];
  }
  if (isDefaultField(field)) {
    return value;
  }
  if (isTimeField(field)) {
    return "";
  }
  return "";
}
function isSupportedLocale(locale) {
  return supportedLocales.includes(locale);
}
function isPlaceholderField(field) {
  return placeholderFields.includes(field);
}
function isTimeField(field) {
  return field === "hour" || field === "minute" || field === "second";
}
function isDefaultField(field) {
  return field === "era" || field === "dayPeriod";
}
function getLocaleLanguage(locale) {
  if (Intl.Locale) {
    return new Intl.Locale(locale).language;
  }
  return locale.split("-")[0];
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/date/announcer.js
function initAnnouncer() {
  if (!isBrowser)
    return null;
  let el = document.querySelector("[data-melt-announcer]");
  if (!isHTMLElement(el)) {
    const div = document.createElement("div");
    div.style.cssText = styleToString({
      border: "0px",
      clip: "rect(0px, 0px, 0px, 0px)",
      "clip-path": "inset(50%)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: "0px",
      position: "absolute",
      "white-space": "nowrap",
      width: "1px"
    });
    div.setAttribute("data-melt-announcer", "");
    div.appendChild(createLog("assertive"));
    div.appendChild(createLog("polite"));
    el = div;
    document.body.insertBefore(el, document.body.firstChild);
  }
  function createLog(kind) {
    const log = document.createElement("div");
    log.role = "log";
    log.ariaLive = kind;
    log.setAttribute("aria-relevant", "additions");
    return log;
  }
  function getLog(kind) {
    if (!isHTMLElement(el))
      return null;
    const log = el.querySelector(`[aria-live="${kind}"]`);
    if (!isHTMLElement(log))
      return null;
    return log;
  }
  return {
    getLog
  };
}
function getAnnouncer() {
  const announcer = initAnnouncer();
  function announce(value, kind = "assertive", timeout = 7500) {
    if (!announcer || !isBrowser)
      return;
    const log = announcer.getLog(kind);
    const content = document.createElement("div");
    if (typeof value === "number") {
      value = value.toString();
    } else if (value === null) {
      value = "Empty";
    } else {
      value = value.trim();
    }
    content.innerText = value;
    if (kind === "assertive") {
      log == null ? void 0 : log.replaceChildren(content);
    } else {
      log == null ? void 0 : log.appendChild(content);
    }
    return setTimeout(() => {
      content.remove();
    }, timeout);
  }
  return {
    announce
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/date-field/_internal/parts.js
var DATE_SEGMENT_PARTS = ["day", "month", "year"];
var TIME_SEGMENT_PARTS = ["hour", "minute", "second", "dayPeriod"];
var NON_EDITABLE_SEGMENT_PARTS = ["literal", "timeZoneName"];
var EDITABLE_SEGMENT_PARTS = [...DATE_SEGMENT_PARTS, ...TIME_SEGMENT_PARTS];
var ALL_SEGMENT_PARTS = [
  ...EDITABLE_SEGMENT_PARTS,
  ...NON_EDITABLE_SEGMENT_PARTS
];
var ALL_EXCEPT_LITERAL_PARTS = ALL_SEGMENT_PARTS.filter((part) => part !== "literal");

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/date-field/_internal/helpers.js
function initializeSegmentValues(granularity) {
  const calendarDateTimeGranularities = ["hour", "minute", "second"];
  const initialParts = EDITABLE_SEGMENT_PARTS.map((part) => {
    if (part === "dayPeriod") {
      return [part, "AM"];
    }
    return [part, null];
  }).filter(([key]) => {
    if (key === "literal" || key === null)
      return false;
    if (granularity === "day") {
      return !calendarDateTimeGranularities.includes(key);
    } else {
      return true;
    }
  });
  return Object.fromEntries(initialParts);
}
function createContentObj(props) {
  const { segmentValues, formatter, locale, dateRef } = props;
  const content = Object.keys(segmentValues).reduce((obj, part) => {
    if (!isSegmentPart(part))
      return obj;
    if ("hour" in segmentValues && part === "dayPeriod") {
      const value = segmentValues[part];
      if (!isNull(value)) {
        obj[part] = value;
      } else {
        obj[part] = getPlaceholder(part, "AM", locale);
      }
    } else {
      obj[part] = getPartContent(part);
    }
    return obj;
  }, {});
  function getPartContent(part) {
    if ("hour" in segmentValues) {
      const value = segmentValues[part];
      if (!isNull(value)) {
        return formatter.part(dateRef.set({ [part]: value }), part, {
          hourCycle: props.hourCycle === 24 ? "h24" : void 0
        });
      } else {
        return getPlaceholder(part, "", locale);
      }
    } else {
      if (isDateSegmentPart(part)) {
        const value = segmentValues[part];
        if (!isNull(value)) {
          return formatter.part(dateRef.set({ [part]: value }), part);
        } else {
          return getPlaceholder(part, "", locale);
        }
      }
      return "";
    }
  }
  return content;
}
function createContentArr(props) {
  const { granularity, dateRef, formatter, contentObj, hideTimeZone, hourCycle } = props;
  const parts = formatter.toParts(dateRef, getOptsByGranularity(granularity, hourCycle));
  const segmentContentArr = parts.map((part) => {
    const defaultParts = ["literal", "dayPeriod", "timeZoneName", null];
    if (defaultParts.includes(part.type) || !isSegmentPart(part.type)) {
      return {
        part: part.type,
        value: part.value
      };
    }
    return {
      part: part.type,
      value: contentObj[part.type]
    };
  }).filter((segment) => {
    if (isNull(segment.part) || isNull(segment.value))
      return false;
    if (segment.part === "timeZoneName" && (!isZonedDateTime(dateRef) || hideTimeZone)) {
      return false;
    }
    return true;
  });
  return segmentContentArr;
}
function createContent(props) {
  const contentObj = createContentObj(props);
  const contentArr = createContentArr({
    contentObj,
    ...props
  });
  return {
    obj: contentObj,
    arr: contentArr
  };
}
function getOptsByGranularity(granularity, hourCycle) {
  const opts = {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    timeZoneName: "short",
    hourCycle: hourCycle === 24 ? "h24" : void 0,
    hour12: hourCycle === 24 ? false : void 0
  };
  if (granularity === "day") {
    delete opts.second;
    delete opts.hour;
    delete opts.minute;
    delete opts.timeZoneName;
  }
  if (granularity === "hour") {
    delete opts.minute;
  }
  if (granularity === "minute") {
    delete opts.second;
  }
  return opts;
}
function initSegmentStates() {
  return EDITABLE_SEGMENT_PARTS.reduce((acc, key) => {
    acc[key] = {
      lastKeyZero: false,
      hasLeftFocus: true,
      hasTouched: false
    };
    return acc;
  }, {});
}
function isDateSegmentPart(part) {
  return DATE_SEGMENT_PARTS.includes(part);
}
function isSegmentPart(part) {
  return EDITABLE_SEGMENT_PARTS.includes(part);
}
function isAnySegmentPart(part) {
  return ALL_SEGMENT_PARTS.includes(part);
}
function getUsedSegments(id) {
  if (!isBrowser)
    return [];
  const usedSegments = getSegments(id).map((el) => el.dataset.segment).filter((part) => {
    return EDITABLE_SEGMENT_PARTS.includes(part);
  });
  return usedSegments;
}
function getValueFromSegments(props) {
  const { segmentObj, id, dateRef } = props;
  const usedSegments = getUsedSegments(id);
  let date = dateRef;
  usedSegments.forEach((part) => {
    if ("hour" in segmentObj) {
      const value = segmentObj[part];
      if (isNull(value))
        return;
      date = date.set({ [part]: segmentObj[part] });
      return;
    } else if (isDateSegmentPart(part)) {
      const value = segmentObj[part];
      if (isNull(value))
        return;
      date = date.set({ [part]: segmentObj[part] });
      return;
    }
  });
  return date;
}
function areAllSegmentsFilled(segmentValues, id) {
  const usedSegments = getUsedSegments(id);
  return usedSegments.every((part) => {
    if ("hour" in segmentValues) {
      return segmentValues[part] !== null;
    } else if (isDateSegmentPart(part)) {
      return segmentValues[part] !== null;
    }
  });
}
function getPartFromNode(node) {
  const part = node.dataset.segment;
  if (!isAnySegmentPart(part))
    return null;
  return part;
}
function isDateAndTimeSegmentObj(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  return Object.entries(obj).every(([key, value]) => {
    const validKey = TIME_SEGMENT_PARTS.includes(key) || DATE_SEGMENT_PARTS.includes(key);
    const validValue = key === "dayPeriod" ? value === "AM" || value === "PM" || value === null : typeof value === "number" || value === null;
    return validKey && validValue;
  });
}
function inferGranularity(value, granularity) {
  if (granularity) {
    return granularity;
  }
  if (hasTime(value)) {
    return "minute";
  }
  return "day";
}
function isAcceptableSegmentKey(key) {
  const acceptableSegmentKeys = [
    kbd.ENTER,
    kbd.ARROW_UP,
    kbd.ARROW_DOWN,
    kbd.ARROW_LEFT,
    kbd.ARROW_RIGHT,
    kbd.BACKSPACE,
    kbd.SPACE
  ];
  if (acceptableSegmentKeys.includes(key))
    return true;
  if (isNumberString(key))
    return true;
  return false;
}
function syncSegmentValues(props) {
  const { value, updatingDayPeriod, segmentValues, formatter } = props;
  const dateValues = DATE_SEGMENT_PARTS.map((part) => {
    return [part, value[part]];
  });
  if ("hour" in value) {
    const timeValues = TIME_SEGMENT_PARTS.map((part) => {
      if (part === "dayPeriod") {
        const $updatingDayPeriod = get(updatingDayPeriod);
        if ($updatingDayPeriod) {
          return [part, $updatingDayPeriod];
        } else {
          return [part, formatter.dayPeriod(toDate(value))];
        }
      }
      return [part, value[part]];
    });
    const mergedSegmentValues = [...dateValues, ...timeValues];
    segmentValues.set(Object.fromEntries(mergedSegmentValues));
    updatingDayPeriod.set(null);
    return;
  }
  segmentValues.set(Object.fromEntries(dateValues));
}
function isFirstSegment(id, fieldId) {
  if (!isBrowser)
    return false;
  const segments = getSegments(fieldId);
  return segments.length ? segments[0].id === id : false;
}
function setDescription(id, formatter, value) {
  if (!isBrowser)
    return;
  const valueString = formatter.selectedDate(value);
  const el = document.getElementById(id);
  if (!el) {
    const div = document.createElement("div");
    div.style.cssText = styleToString({
      display: "none"
    });
    div.id = id;
    div.innerText = `Selected Date: ${valueString}`;
    document.body.appendChild(div);
  } else {
    el.innerText = `Selected Date: ${valueString}`;
  }
}
function removeDescriptionElement(id) {
  if (!isBrowser)
    return;
  const el = document.getElementById(id);
  if (!el)
    return;
  document.body.removeChild(el);
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/date/field.js
function handleSegmentNavigation(e, fieldId) {
  const currentTarget = e.currentTarget;
  if (!isHTMLElement(currentTarget))
    return;
  const { prev: prev2, next: next2 } = getPrevNextSegments(currentTarget, fieldId);
  if (e.key === kbd.ARROW_LEFT) {
    if (!prev2)
      return;
    prev2.focus();
  } else if (e.key === kbd.ARROW_RIGHT) {
    if (!next2)
      return;
    next2.focus();
  }
}
function getNextSegment(node, segments) {
  const index = segments.indexOf(node);
  if (index === segments.length - 1 || index === -1)
    return null;
  const nextIndex = index + 1;
  const nextSegment = segments[nextIndex];
  return nextSegment;
}
function getPrevSegment(node, segments) {
  const index = segments.indexOf(node);
  if (index === 0 || index === -1)
    return null;
  const prevIndex = index - 1;
  const prevSegment = segments[prevIndex];
  return prevSegment;
}
function getPrevNextSegments(node, fieldId) {
  const segments = getSegments(fieldId);
  if (!segments.length) {
    return {
      next: null,
      prev: null
    };
  }
  return {
    next: getNextSegment(node, segments),
    prev: getPrevSegment(node, segments)
  };
}
function moveToNextSegment(e, fieldId) {
  const node = e.currentTarget;
  if (!isHTMLElement(node))
    return;
  const { next: next2 } = getPrevNextSegments(node, fieldId);
  if (!next2)
    return;
  next2.focus();
}
function isSegmentNavigationKey(key) {
  if (key === kbd.ARROW_RIGHT || key === kbd.ARROW_LEFT)
    return true;
  return false;
}
function getSegments(id) {
  const inputContainer = document.getElementById(id);
  if (!isHTMLElement(inputContainer))
    return [];
  const segments = Array.from(inputContainer.querySelectorAll("[data-segment]")).filter((el) => {
    if (!isHTMLElement(el))
      return false;
    const segment = el.dataset.segment;
    if (segment === "trigger")
      return true;
    if (!isAnySegmentPart(segment) || segment === "literal")
      return false;
    return true;
  });
  return segments;
}
function getFirstSegment(id) {
  const segments = getSegments(id);
  return segments[0];
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/date/calendar.js
function isCalendarCell(node) {
  if (!isHTMLElement(node))
    return false;
  if (!node.hasAttribute("data-melt-calendar-cell"))
    return false;
  return true;
}
function getDaysBetween(start, end) {
  const days = [];
  let dCurrent = start.add({ days: 1 });
  const dEnd = end;
  while (dCurrent.compare(dEnd) < 0) {
    days.push(dCurrent);
    dCurrent = dCurrent.add({ days: 1 });
  }
  return days;
}
function createMonth(props) {
  const { dateObj, weekStartsOn, fixedWeeks, locale } = props;
  const daysInMonth = getDaysInMonth(dateObj);
  const datesArray = Array.from({ length: daysInMonth }, (_, i) => dateObj.set({ day: i + 1 }));
  const firstDayOfMonth = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(dateObj);
  const lastDayOfMonth = $14e0f24ef4ac5c92$export$a2258d9c4118825c(dateObj);
  const lastSunday = getLastFirstDayOfWeek(firstDayOfMonth, weekStartsOn, locale);
  const nextSaturday = getNextLastDayOfWeek(lastDayOfMonth, weekStartsOn, locale);
  const lastMonthDays = getDaysBetween(lastSunday.subtract({ days: 1 }), firstDayOfMonth);
  const nextMonthDays = getDaysBetween(lastDayOfMonth, nextSaturday.add({ days: 1 }));
  const totalDays = lastMonthDays.length + datesArray.length + nextMonthDays.length;
  if (fixedWeeks && totalDays < 42) {
    const extraDays = 42 - totalDays;
    let startFrom = nextMonthDays[nextMonthDays.length - 1];
    if (!startFrom) {
      startFrom = dateObj.add({ months: 1 }).set({ day: 1 });
    }
    const extraDaysArray = Array.from({ length: extraDays }, (_, i) => {
      const incr = i + 1;
      return startFrom.add({ days: incr });
    });
    nextMonthDays.push(...extraDaysArray);
  }
  const allDays = lastMonthDays.concat(datesArray, nextMonthDays);
  const weeks = chunk(allDays, 7);
  return {
    value: dateObj,
    dates: allDays,
    weeks
  };
}
function createMonths(props) {
  const { numberOfMonths, dateObj, ...monthProps } = props;
  const months = [];
  if (!numberOfMonths || numberOfMonths === 1) {
    months.push(createMonth({
      ...monthProps,
      dateObj
    }));
    return months;
  }
  months.push(createMonth({
    ...monthProps,
    dateObj
  }));
  for (let i = 1; i < numberOfMonths; i++) {
    const nextMonth = dateObj.add({ months: i });
    months.push(createMonth({
      ...monthProps,
      dateObj: nextMonth
    }));
  }
  return months;
}
function getSelectableCells(calendarId) {
  const node = document.getElementById(calendarId);
  if (!node)
    return [];
  const selectableSelector = `[data-melt-calendar-cell]:not([data-disabled]):not([data-outside-visible-months])`;
  return Array.from(node.querySelectorAll(selectableSelector)).filter((el) => isHTMLElement(el));
}
function setPlaceholderToNodeValue(node, placeholder) {
  const cellValue = node.getAttribute("data-value");
  if (!cellValue)
    return;
  placeholder.set(parseStringToDateValue(cellValue, get(placeholder)));
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/calendar/create.js
var defaults10 = {
  isDateDisabled: void 0,
  isDateUnavailable: void 0,
  value: void 0,
  preventDeselect: false,
  numberOfMonths: 1,
  pagedNavigation: false,
  weekStartsOn: 0,
  fixedWeeks: false,
  calendarLabel: "Event Date",
  locale: "en",
  minValue: void 0,
  maxValue: void 0,
  disabled: false,
  readonly: false,
  weekdayFormat: "narrow"
};
var { name: name5 } = createElHelpers("calendar");
var calendarIdParts = ["calendar", "accessibleHeading"];
function createCalendar(props) {
  const withDefaults = { ...defaults10, ...props };
  const options = toWritableStores({
    ...omit(withDefaults, "value", "placeholder", "multiple", "ids"),
    multiple: withDefaults.multiple ?? false
  });
  const { preventDeselect, numberOfMonths, pagedNavigation, weekStartsOn, fixedWeeks, calendarLabel, locale, minValue, maxValue, multiple, isDateUnavailable, disabled, readonly: readonly2, weekdayFormat } = options;
  const ids = toWritableStores({ ...generateIds(calendarIdParts), ...withDefaults.ids });
  const defaultDate = getDefaultDate({
    defaultPlaceholder: withDefaults.defaultPlaceholder,
    defaultValue: withDefaults.defaultValue
  });
  const formatter = createFormatter(withDefaults.locale);
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults.onValueChange);
  const placeholderWritable = withDefaults.placeholder ?? writable(withDefaults.defaultPlaceholder ?? defaultDate);
  const placeholder = dateStore(overridable(placeholderWritable, withDefaults.onPlaceholderChange), withDefaults.defaultPlaceholder ?? defaultDate);
  const months = withGet(writable(createMonths({
    dateObj: placeholder.get(),
    weekStartsOn: withDefaults.weekStartsOn,
    locale: withDefaults.locale,
    fixedWeeks: withDefaults.fixedWeeks,
    numberOfMonths: withDefaults.numberOfMonths
  })));
  const visibleMonths = withGet.derived([months], ([$months]) => {
    return $months.map((month) => {
      return month.value;
    });
  });
  const isOutsideVisibleMonths = derived([visibleMonths], ([$visibleMonths]) => {
    return (date) => {
      return !$visibleMonths.some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(date, month));
    };
  });
  const isNextButtonDisabled = withGet.derived([months, maxValue, disabled], ([$months, $maxValue, $disabled]) => {
    if (!$maxValue || !$months.length)
      return false;
    if ($disabled)
      return true;
    const lastMonthInView = $months[$months.length - 1].value;
    const firstMonthOfNextPage = lastMonthInView.add({ months: 1 }).set({ day: 1 });
    return isAfter(firstMonthOfNextPage, $maxValue);
  });
  const isPrevButtonDisabled = withGet.derived([months, minValue, disabled], ([$months, $minValue, $disabled]) => {
    if (!$minValue || !$months.length)
      return false;
    if ($disabled)
      return true;
    const firstMonthInView = $months[0].value;
    const lastMonthOfPrevPage = firstMonthInView.subtract({ months: 1 }).set({ day: 35 });
    return isBefore(lastMonthOfPrevPage, $minValue);
  });
  const isDateDisabled = withGet.derived([options.isDateDisabled, minValue, maxValue, disabled], ([$isDateDisabled, $minValue, $maxValue, $disabled]) => {
    return (date) => {
      if (($isDateDisabled == null ? void 0 : $isDateDisabled(date)) || $disabled)
        return true;
      if ($minValue && isBefore(date, $minValue))
        return true;
      if ($maxValue && isBefore($maxValue, date))
        return true;
      return false;
    };
  });
  const isDateSelected = derived([value], ([$value]) => {
    return (date) => {
      if (Array.isArray($value)) {
        return $value.some((d) => $14e0f24ef4ac5c92$export$ea39ec197993aef0(d, date));
      } else if (!$value) {
        return false;
      } else {
        return $14e0f24ef4ac5c92$export$ea39ec197993aef0($value, date);
      }
    };
  });
  const isInvalid = derived([value, isDateDisabled, options.isDateUnavailable], ([$value, $isDateDisabled, $isDateUnavailable]) => {
    if (Array.isArray($value)) {
      if (!$value.length)
        return false;
      for (const date of $value) {
        if ($isDateDisabled == null ? void 0 : $isDateDisabled(date))
          return true;
        if ($isDateUnavailable == null ? void 0 : $isDateUnavailable(date))
          return true;
      }
    } else {
      if (!$value)
        return false;
      if ($isDateDisabled == null ? void 0 : $isDateDisabled($value))
        return true;
      if ($isDateUnavailable == null ? void 0 : $isDateUnavailable($value))
        return true;
    }
    return false;
  });
  let announcer = getAnnouncer();
  const headingValue = withGet.derived([months, locale], ([$months, $locale]) => {
    if (!$months.length)
      return "";
    if ($locale !== formatter.getLocale()) {
      formatter.setLocale($locale);
    }
    if ($months.length === 1) {
      const month = $months[0].value;
      return `${formatter.fullMonthAndYear(toDate(month))}`;
    }
    const startMonth = toDate($months[0].value);
    const endMonth = toDate($months[$months.length - 1].value);
    const startMonthName = formatter.fullMonth(startMonth);
    const endMonthName = formatter.fullMonth(endMonth);
    const startMonthYear = formatter.fullYear(startMonth);
    const endMonthYear = formatter.fullYear(endMonth);
    const content = startMonthYear === endMonthYear ? `${startMonthName} - ${endMonthName} ${endMonthYear}` : `${startMonthName} ${startMonthYear} - ${endMonthName} ${endMonthYear}`;
    return content;
  });
  const fullCalendarLabel = withGet.derived([headingValue, calendarLabel], ([$headingValue, $calendarLabel]) => {
    return `${$calendarLabel}, ${$headingValue}`;
  });
  const calendar = makeElement(name5(), {
    stores: [fullCalendarLabel, isInvalid, disabled, readonly2, ids.calendar],
    returned: ([$fullCalendarLabel, $isInvalid, $disabled, $readonly, $calendarId]) => {
      return {
        id: $calendarId,
        role: "application",
        "aria-label": $fullCalendarLabel,
        "data-invalid": $isInvalid ? "" : void 0,
        "data-disabled": $disabled ? "" : void 0,
        "data-readonly": $readonly ? "" : void 0
      };
    },
    action: (node) => {
      createAccessibleHeading(node, fullCalendarLabel.get());
      announcer = getAnnouncer();
      const unsubKb = addMeltEventListener(node, "keydown", handleCalendarKeydown);
      return {
        destroy() {
          unsubKb();
        }
      };
    }
  });
  const heading = makeElement(name5("heading"), {
    stores: [disabled],
    returned: ([$disabled]) => {
      return {
        "aria-hidden": true,
        "data-disabled": $disabled ? "" : void 0
      };
    }
  });
  const grid = makeElement(name5("grid"), {
    stores: [readonly2, disabled],
    returned: ([$readonly, $disabled]) => {
      return {
        tabindex: -1,
        role: "grid",
        "aria-readonly": $readonly ? "true" : void 0,
        "aria-disabled": $disabled ? "true" : void 0,
        "data-readonly": $readonly ? "" : void 0,
        "data-disabled": $disabled ? "" : void 0
      };
    }
  });
  const prevButton = makeElement(name5("prevButton"), {
    stores: [isPrevButtonDisabled],
    returned: ([$isPrevButtonDisabled]) => {
      const disabled2 = $isPrevButtonDisabled;
      return {
        role: "button",
        type: "button",
        "aria-label": "Previous",
        "aria-disabled": disabled2 ? "true" : void 0,
        "data-disabled": disabled2 ? "" : void 0,
        disabled: disabled2 ? true : void 0
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        if (isPrevButtonDisabled.get())
          return;
        prevPage();
      }));
      return {
        destroy: unsub
      };
    }
  });
  const nextButton = makeElement(name5("nextButton"), {
    stores: [isNextButtonDisabled],
    returned: ([$isNextButtonDisabled]) => {
      const disabled2 = $isNextButtonDisabled;
      return {
        role: "button",
        type: "button",
        "aria-label": "Next",
        "aria-disabled": disabled2 ? "true" : void 0,
        "data-disabled": disabled2 ? "" : void 0,
        disabled: disabled2 ? true : void 0
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        if (isNextButtonDisabled.get())
          return;
        nextPage();
      }));
      return {
        destroy: unsub
      };
    }
  });
  const cell = makeElement(name5("cell"), {
    stores: [
      isDateSelected,
      isDateDisabled,
      isDateUnavailable,
      isOutsideVisibleMonths,
      placeholder
    ],
    returned: ([$isDateSelected, $isDateDisabled, $isDateUnavailable, $isOutsideVisibleMonths, $placeholder]) => {
      return (cellValue, monthValue) => {
        const cellDate = toDate(cellValue);
        const isDisabled = $isDateDisabled == null ? void 0 : $isDateDisabled(cellValue);
        const isUnavailable = $isDateUnavailable == null ? void 0 : $isDateUnavailable(cellValue);
        const isDateToday = $14e0f24ef4ac5c92$export$629b0a497aa65267(cellValue, $14e0f24ef4ac5c92$export$aa8b41735afcabd2());
        const isOutsideMonth = !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(cellValue, monthValue);
        const isOutsideVisibleMonths2 = $isOutsideVisibleMonths(cellValue);
        const isFocusedDate = $14e0f24ef4ac5c92$export$ea39ec197993aef0(cellValue, $placeholder);
        const isSelectedDate = $isDateSelected(cellValue);
        const labelText = formatter.custom(cellDate, {
          weekday: "long",
          month: "long",
          day: "numeric",
          year: "numeric"
        });
        return {
          role: "button",
          "aria-label": labelText,
          "aria-selected": isSelectedDate ? true : void 0,
          "aria-disabled": isOutsideMonth || isDisabled || isUnavailable ? true : void 0,
          "data-selected": isSelectedDate ? true : void 0,
          "data-value": cellValue.toString(),
          "data-disabled": isDisabled || isOutsideMonth ? "" : void 0,
          "data-unavailable": isUnavailable ? "" : void 0,
          "data-today": isDateToday ? "" : void 0,
          "data-outside-month": isOutsideMonth ? "" : void 0,
          "data-outside-visible-months": isOutsideVisibleMonths2 ? "" : void 0,
          "data-focused": isFocusedDate ? "" : void 0,
          tabindex: isFocusedDate ? 0 : isOutsideMonth || isDisabled ? void 0 : -1
        };
      };
    },
    action: (node) => {
      const getElArgs = () => {
        const value2 = node.getAttribute("data-value");
        const label = node.getAttribute("data-label");
        const disabled2 = node.hasAttribute("data-disabled");
        return {
          value: value2,
          label: label ?? node.textContent ?? null,
          disabled: disabled2 ? true : false
        };
      };
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        const args = getElArgs();
        if (args.disabled)
          return;
        if (!args.value)
          return;
        handleCellClick(parseStringToDateValue(args.value, placeholder.get()));
      }));
      return {
        destroy: unsub
      };
    }
  });
  effect([locale], ([$locale]) => {
    if (formatter.getLocale() === $locale)
      return;
    formatter.setLocale($locale);
  });
  effect([placeholder], ([$placeholder]) => {
    if (!isBrowser || !$placeholder)
      return;
    const $visibleMonths = visibleMonths.get();
    if ($visibleMonths.some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(month, $placeholder))) {
      return;
    }
    const $weekStartsOn = weekStartsOn.get();
    const $locale = locale.get();
    const $fixedWeeks = fixedWeeks.get();
    const $numberOfMonths = numberOfMonths.get();
    const defaultMonthProps = {
      weekStartsOn: $weekStartsOn,
      locale: $locale,
      fixedWeeks: $fixedWeeks,
      numberOfMonths: $numberOfMonths
    };
    months.set(createMonths({
      ...defaultMonthProps,
      dateObj: $placeholder
    }));
  });
  effect([weekStartsOn, locale, fixedWeeks, numberOfMonths], ([$weekStartsOn, $locale, $fixedWeeks, $numberOfMonths]) => {
    const $placeholder = placeholder.get();
    if (!isBrowser || !$placeholder)
      return;
    const defaultMonthProps = {
      weekStartsOn: $weekStartsOn,
      locale: $locale,
      fixedWeeks: $fixedWeeks,
      numberOfMonths: $numberOfMonths
    };
    months.set(createMonths({
      ...defaultMonthProps,
      dateObj: $placeholder
    }));
  });
  effect([fullCalendarLabel], ([$fullCalendarLabel]) => {
    if (!isBrowser)
      return;
    const node = document.getElementById(ids.accessibleHeading.get());
    if (!isHTMLElement(node))
      return;
    node.textContent = $fullCalendarLabel;
  });
  effect([value], ([$value]) => {
    if (Array.isArray($value) && $value.length) {
      const lastValue = $value[$value.length - 1];
      if (lastValue && placeholder.get() !== lastValue) {
        placeholder.set(lastValue);
      }
    } else if (!Array.isArray($value) && $value && placeholder.get() !== $value) {
      placeholder.set($value);
    }
  });
  const weekdays = derived([months, weekdayFormat, locale], ([$months, $weekdayFormat, _]) => {
    if (!$months.length)
      return [];
    return $months[0].weeks[0].map((date) => {
      return formatter.dayOfWeek(toDate(date), $weekdayFormat);
    });
  });
  function createAccessibleHeading(node, label) {
    if (!isBrowser)
      return;
    const div = document.createElement("div");
    div.style.cssText = styleToString({
      border: "0px",
      clip: "rect(0px, 0px, 0px, 0px)",
      "clip-path": "inset(50%)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: "0px",
      position: "absolute",
      "white-space": "nowrap",
      width: "1px"
    });
    const h2 = document.createElement("div");
    h2.textContent = label;
    h2.id = ids.accessibleHeading.get();
    h2.role = "heading";
    h2.ariaLevel = "2";
    node.insertBefore(div, node.firstChild);
    div.appendChild(h2);
  }
  function nextPage() {
    const $months = months.get();
    const $numberOfMonths = numberOfMonths.get();
    if (pagedNavigation.get()) {
      const firstMonth = $months[0].value;
      placeholder.set(firstMonth.add({ months: $numberOfMonths }));
    } else {
      const firstMonth = $months[0].value;
      const newMonths = createMonths({
        dateObj: firstMonth.add({ months: 1 }),
        weekStartsOn: weekStartsOn.get(),
        locale: locale.get(),
        fixedWeeks: fixedWeeks.get(),
        numberOfMonths: $numberOfMonths
      });
      months.set(newMonths);
      placeholder.set(newMonths[0].value.set({ day: 1 }));
    }
  }
  function prevPage() {
    const $months = months.get();
    const $numberOfMonths = numberOfMonths.get();
    if (pagedNavigation.get()) {
      const firstMonth = $months[0].value;
      placeholder.set(firstMonth.subtract({ months: $numberOfMonths }));
    } else {
      const firstMonth = $months[0].value;
      const newMonths = createMonths({
        dateObj: firstMonth.subtract({ months: 1 }),
        weekStartsOn: weekStartsOn.get(),
        locale: locale.get(),
        fixedWeeks: fixedWeeks.get(),
        numberOfMonths: $numberOfMonths
      });
      months.set(newMonths);
      placeholder.set(newMonths[0].value.set({ day: 1 }));
    }
  }
  function nextYear() {
    placeholder.add({ years: 1 });
  }
  function prevYear() {
    placeholder.subtract({ years: 1 });
  }
  const ARROW_KEYS = [kbd.ARROW_DOWN, kbd.ARROW_UP, kbd.ARROW_LEFT, kbd.ARROW_RIGHT];
  function setYear(year) {
    placeholder.setDate({ year });
  }
  function setMonth(month) {
    placeholder.setDate({ month });
  }
  function handleCellClick(date) {
    const $readonly = readonly2.get();
    if ($readonly)
      return;
    const $isDateDisabled = isDateDisabled.get();
    const $isUnavailable = options.isDateUnavailable.get();
    if (($isDateDisabled == null ? void 0 : $isDateDisabled(date)) || ($isUnavailable == null ? void 0 : $isUnavailable(date)))
      return;
    value.update((prev2) => {
      const $multiple = multiple.get();
      if ($multiple) {
        return handleMultipleUpdate(prev2, date);
      } else {
        const next2 = handleSingleUpdate(prev2, date);
        if (!next2) {
          announcer.announce("Selected date is now empty.", "polite", 5e3);
        } else {
          announcer.announce(`Selected Date: ${formatter.selectedDate(next2, false)}`, "polite");
        }
        return next2;
      }
    });
  }
  function handleSingleUpdate(prev2, date) {
    if (Array.isArray(prev2))
      throw new Error("Invalid value for multiple prop.");
    if (!prev2)
      return date;
    const $preventDeselect = preventDeselect.get();
    if (!$preventDeselect && $14e0f24ef4ac5c92$export$ea39ec197993aef0(prev2, date)) {
      placeholder.set(date);
      return void 0;
    }
    return date;
  }
  function handleMultipleUpdate(prev2, date) {
    if (!prev2)
      return [date];
    if (!Array.isArray(prev2))
      throw new Error("Invalid value for multiple prop.");
    const index = prev2.findIndex((d) => $14e0f24ef4ac5c92$export$ea39ec197993aef0(d, date));
    const $preventDeselect = preventDeselect.get();
    if (index === -1) {
      return [...prev2, date];
    } else if ($preventDeselect) {
      return prev2;
    } else {
      const next2 = prev2.filter((d) => !$14e0f24ef4ac5c92$export$ea39ec197993aef0(d, date));
      if (!next2.length) {
        placeholder.set(date);
        return void 0;
      }
      return next2;
    }
  }
  const SELECT_KEYS = [kbd.ENTER, kbd.SPACE];
  function handleCalendarKeydown(e) {
    const currentCell = e.target;
    if (!isCalendarCell(currentCell))
      return;
    if (!ARROW_KEYS.includes(e.key) && !SELECT_KEYS.includes(e.key))
      return;
    e.preventDefault();
    if (e.key === kbd.ARROW_DOWN) {
      shiftFocus(currentCell, 7);
    }
    if (e.key === kbd.ARROW_UP) {
      shiftFocus(currentCell, -7);
    }
    if (e.key === kbd.ARROW_LEFT) {
      shiftFocus(currentCell, -1);
    }
    if (e.key === kbd.ARROW_RIGHT) {
      shiftFocus(currentCell, 1);
    }
    if (e.key === kbd.SPACE || e.key === kbd.ENTER) {
      const cellValue = currentCell.getAttribute("data-value");
      if (!cellValue)
        return;
      handleCellClick(parseStringToDateValue(cellValue, placeholder.get()));
    }
  }
  function shiftFocus(node, add) {
    const candidateCells = getSelectableCells(ids.calendar.get());
    if (!candidateCells.length)
      return;
    const index = candidateCells.indexOf(node);
    const nextIndex = index + add;
    if (isValidIndex(nextIndex, candidateCells)) {
      const nextCell = candidateCells[nextIndex];
      setPlaceholderToNodeValue(nextCell, placeholder);
      return nextCell.focus();
    }
    if (nextIndex < 0) {
      if (isPrevButtonDisabled.get())
        return;
      const $months = months.get();
      const firstMonth = $months[0].value;
      const $numberOfMonths = numberOfMonths.get();
      placeholder.set(firstMonth.subtract({ months: $numberOfMonths }));
      tick().then(() => {
        const newCandidateCells = getSelectableCells(ids.calendar.get());
        if (!newCandidateCells.length) {
          return;
        }
        const newIndex = newCandidateCells.length - Math.abs(nextIndex);
        if (isValidIndex(newIndex, newCandidateCells)) {
          const newCell = newCandidateCells[newIndex];
          setPlaceholderToNodeValue(newCell, placeholder);
          return newCell.focus();
        }
      });
    }
    if (nextIndex >= candidateCells.length) {
      if (isNextButtonDisabled.get())
        return;
      const $months = months.get();
      const firstMonth = $months[0].value;
      const $numberOfMonths = numberOfMonths.get();
      placeholder.set(firstMonth.add({ months: $numberOfMonths }));
      tick().then(() => {
        const newCandidateCells = getSelectableCells(ids.calendar.get());
        if (!newCandidateCells.length) {
          return;
        }
        const newIndex = nextIndex - candidateCells.length;
        if (isValidIndex(newIndex, newCandidateCells)) {
          const nextCell = newCandidateCells[newIndex];
          return nextCell.focus();
        }
      });
    }
  }
  const _isDateDisabled = derived([isDateDisabled, placeholder, minValue, maxValue, disabled], ([$isDateDisabled, $placeholder, $minValue, $maxValue, $disabled]) => {
    return (date) => {
      if (($isDateDisabled == null ? void 0 : $isDateDisabled(date)) || $disabled)
        return true;
      if ($minValue && isBefore(date, $minValue))
        return true;
      if ($maxValue && isAfter(date, $maxValue))
        return true;
      if (!$14e0f24ef4ac5c92$export$a18c89cbd24170ff(date, $placeholder))
        return true;
      return false;
    };
  });
  const _isDateUnavailable = derived(isDateUnavailable, ($isDateUnavailable) => {
    return (date) => $isDateUnavailable == null ? void 0 : $isDateUnavailable(date);
  });
  return {
    elements: {
      calendar,
      heading,
      grid,
      cell,
      nextButton,
      prevButton
    },
    states: {
      placeholder: placeholder.toWritable(),
      months,
      value,
      weekdays,
      headingValue
    },
    helpers: {
      nextPage,
      prevPage,
      nextYear,
      prevYear,
      setYear,
      setMonth,
      isDateDisabled: _isDateDisabled,
      isDateSelected,
      isDateUnavailable: _isDateUnavailable
    },
    options,
    ids
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/date-field/create.js
var defaults11 = {
  isDateUnavailable: void 0,
  value: void 0,
  hourCycle: void 0,
  locale: "en",
  granularity: void 0,
  hideTimeZone: false,
  disabled: false,
  readonly: false,
  readonlySegments: void 0,
  name: void 0,
  required: false,
  minValue: void 0,
  maxValue: void 0
};
var prefix = "dateField";
var { name: name6 } = createElHelpers(prefix);
var dateFieldIdParts = [
  "field",
  "label",
  "description",
  "validation",
  "day",
  "month",
  "year",
  "hour",
  "minute",
  "second",
  "dayPeriod",
  "timeZoneName"
];
function createDateField(props) {
  const withDefaults = { ...defaults11, ...props };
  const options = toWritableStores(omit(withDefaults, "value", "placeholder", "ids"));
  const { locale, granularity, hourCycle, hideTimeZone, isDateUnavailable, disabled, readonly: readonly2, readonlySegments, name: nameStore, required, minValue, maxValue } = options;
  const defaultDate = getDefaultDate({
    defaultPlaceholder: withDefaults.defaultPlaceholder,
    granularity: withDefaults.granularity,
    defaultValue: withDefaults.defaultValue
  });
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults.onValueChange);
  const isInvalid = derived([value, isDateUnavailable, minValue, maxValue], ([$value, $isDateUnavailable, $minValue, $maxValue]) => {
    if (!$value)
      return false;
    if ($isDateUnavailable == null ? void 0 : $isDateUnavailable($value))
      return true;
    if ($minValue && isBefore($value, $minValue))
      return true;
    if ($maxValue && isBefore($maxValue, $value))
      return true;
    return false;
  });
  const placeholderWritable = withDefaults.placeholder ?? writable(withDefaults.defaultPlaceholder ?? defaultDate);
  const placeholder = dateStore(overridable(placeholderWritable, withDefaults.onPlaceholderChange), withDefaults.defaultPlaceholder ?? defaultDate);
  const inferredGranularity = withGet.derived([placeholder, granularity], ([$placeholder, $granularity]) => {
    if ($granularity) {
      return $granularity;
    } else {
      return inferGranularity($placeholder, $granularity);
    }
  });
  const formatter = createFormatter(locale.get());
  const initialSegments = initializeSegmentValues(inferredGranularity.get());
  const segmentValues = withGet.writable(structuredClone(initialSegments));
  let announcer = getAnnouncer();
  const updatingDayPeriod = writable(null);
  const readonlySegmentsSet = withGet(derived(readonlySegments, ($readonlySegments) => new Set($readonlySegments)));
  const ids = toWritableStores({ ...generateIds(dateFieldIdParts), ...withDefaults.ids });
  const idValues = derived([
    ids.field,
    ids.label,
    ids.description,
    ids.validation,
    ids.day,
    ids.month,
    ids.year,
    ids.hour,
    ids.minute,
    ids.second,
    ids.dayPeriod,
    ids.timeZoneName
  ], ([$fieldId, $labelId, $descriptionId, $validationId, $dayId, $monthId, $yearId, $hourId, $minuteId, $secondId, $dayPeriodId, $timeZoneNameId]) => {
    return {
      field: $fieldId,
      label: $labelId,
      description: $descriptionId,
      validation: $validationId,
      day: $dayId,
      month: $monthId,
      year: $yearId,
      hour: $hourId,
      minute: $minuteId,
      second: $secondId,
      dayPeriod: $dayPeriodId,
      timeZoneName: $timeZoneNameId
    };
  });
  const defaultSegmentAttrs = {
    role: "spinbutton",
    contenteditable: true,
    tabindex: 0,
    spellcheck: false,
    inputmode: "numeric",
    autocorrect: "off",
    enterkeyhint: "next",
    style: styleToString({
      "caret-color": "transparent"
    })
  };
  const states = initSegmentStates();
  const allSegmentContent = derived([segmentValues, locale, inferredGranularity, hideTimeZone, hourCycle], ([$segmentValues, $locale, $inferredGranularity, $hideTimeZone, $hourCycle]) => {
    return createContent({
      segmentValues: $segmentValues,
      formatter,
      locale: $locale,
      granularity: $inferredGranularity,
      dateRef: placeholder.get(),
      hideTimeZone: $hideTimeZone,
      hourCycle: $hourCycle
    });
  });
  const segmentContents = derived(allSegmentContent, ($allSegmentContent) => $allSegmentContent.arr);
  const segmentContentsObj = derived(allSegmentContent, ($allSegmentContent) => $allSegmentContent.obj);
  const label = makeElement(name6("label"), {
    stores: [isInvalid, disabled, ids.label],
    returned: ([$isInvalid, $disabled, $labelId]) => {
      return {
        id: $labelId,
        "data-invalid": $isInvalid ? "" : void 0,
        "data-disabled": $disabled ? "" : void 0
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        const firstSegment = getFirstSegment(ids.field.get());
        if (!firstSegment)
          return;
        sleep(1).then(() => firstSegment.focus());
      }), addMeltEventListener(node, "mousedown", (e) => {
        if (!e.defaultPrevented && e.detail > 1) {
          e.preventDefault();
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const validation = makeElement(name6("validation"), {
    stores: [isInvalid, ids.validation],
    returned: ([$isInvalid, $validationId]) => {
      const validStyle = styleToString({
        display: "none"
      });
      return {
        id: $validationId,
        "data-invalid": $isInvalid ? "" : void 0,
        style: $isInvalid ? void 0 : validStyle
      };
    }
  });
  const hiddenInput = createHiddenInput({
    prefix,
    value: derived(value, ($value) => ($value == null ? void 0 : $value.toString()) ?? ""),
    name: nameStore,
    disabled,
    required
  });
  const fieldIdDeps = derived([ids.field, ids.label, ids.description, ids.label], ([$fieldId, $labelId, $descriptionId, $validationId]) => {
    return {
      field: $fieldId,
      label: $labelId,
      description: $descriptionId,
      validation: $validationId
    };
  });
  const field = makeElement(name6("field"), {
    stores: [value, isInvalid, disabled, readonly2, fieldIdDeps],
    returned: ([$value, $isInvalid, $disabled, $readonly, $ids]) => {
      const describedBy = $value ? `${$ids.description}${$isInvalid ? ` ${$ids.validation}` : ""}` : `${$ids.description}`;
      return {
        role: "group",
        id: $ids.field,
        "aria-labelledby": $ids.label,
        "aria-describedby": describedBy,
        "aria-disabled": $disabled ? "true" : void 0,
        "aria-readonly": $readonly ? "true" : void 0,
        "data-invalid": $isInvalid ? "" : void 0,
        "data-disabled": $disabled ? "" : void 0
      };
    },
    // even if we don't need the element we need to specify it
    // or TS will complain when svelte tries to pass it
    action: (_node) => {
      announcer = getAnnouncer();
      return {
        destroy() {
          removeDescriptionElement(ids.description.get());
        }
      };
    }
  });
  const segmentBuilders = {
    day: {
      attrs: daySegmentAttrs,
      action: daySegmentAction
    },
    month: {
      attrs: monthSegmentAttrs,
      action: monthSegmentAction
    },
    year: {
      attrs: yearSegmentAttrs,
      action: yearSegmentAction
    },
    hour: {
      attrs: hourSegmentAttrs,
      action: hourSegmentAction
    },
    minute: {
      attrs: minuteSegmentAttrs,
      action: minuteSegmentAction
    },
    second: {
      attrs: secondSegmentAttrs,
      action: secondSegmentAction
    },
    dayPeriod: {
      attrs: dayPeriodSegmentAttrs,
      action: dayPeriodSegmentAction
    },
    literal: {
      attrs: literalSegmentAttrs,
      action: literalSegmentAction
    },
    timeZoneName: {
      attrs: timeZoneSegmentAttrs,
      action: timeZoneSegmentAction
    }
  };
  const segment = makeElement(name6("segment"), {
    stores: [
      segmentValues,
      hourCycle,
      placeholder,
      value,
      isInvalid,
      disabled,
      readonly2,
      readonlySegmentsSet,
      idValues,
      locale
    ],
    returned: ([$segmentValues, $hourCycle, $placeholder, $value, $isInvalid, $disabled, $readonly, $readonlySegmentsSet, $idValues, _]) => {
      const props2 = {
        segmentValues: $segmentValues,
        hourCycle: $hourCycle,
        placeholder: $placeholder,
        ids: $idValues
      };
      return (part) => {
        const inReadonlySegments = $readonlySegmentsSet.has(part);
        const defaultAttrs = {
          ...getSegmentAttrs(part, props2),
          "aria-invalid": $isInvalid ? "true" : void 0,
          "aria-disabled": $disabled ? "true" : void 0,
          "aria-readonly": $readonly || inReadonlySegments ? "true" : void 0,
          "data-invalid": $isInvalid ? "" : void 0,
          "data-disabled": $disabled ? "" : void 0,
          "data-segment": `${part}`
        };
        if (part === "literal") {
          return defaultAttrs;
        }
        const id = $idValues[part];
        const hasDescription = isFirstSegment(id, $idValues.field) || $value;
        const describedBy = hasDescription ? `${hasDescription} ${$isInvalid ? $idValues.validation : ""}` : void 0;
        return {
          ...defaultAttrs,
          id: $idValues[part],
          "aria-labelledby": getLabelledBy(part),
          contenteditable: $readonly || inReadonlySegments || $disabled ? false : true,
          "aria-describedby": describedBy,
          tabindex: $disabled ? void 0 : 0
        };
      };
    },
    action: (node) => getSegmentAction(node)
  });
  function updateSegment(part, cb) {
    if (disabled.get() || readonly2.get() || readonlySegmentsSet.get().has(part))
      return;
    segmentValues.update((prev2) => {
      const dateRef = placeholder.get();
      if (isDateAndTimeSegmentObj(prev2)) {
        const pVal = prev2[part];
        const castCb = cb;
        if (part === "month") {
          const next3 = castCb(pVal);
          if (part === "month" && next3 !== null && prev2.day !== null) {
            const date = dateRef.set({ month: next3 });
            const daysInMonth = getDaysInMonth(toDate(date));
            if (prev2.day > daysInMonth) {
              prev2.day = daysInMonth;
            }
          }
          return {
            ...prev2,
            [part]: next3
          };
        } else if (part === "dayPeriod") {
          const next3 = castCb(pVal);
          updatingDayPeriod.set(next3);
          const date = placeholder.get();
          if ("hour" in date) {
            const trueHour = date.hour;
            if (next3 === "AM") {
              if (trueHour >= 12) {
                prev2.hour = trueHour - 12;
              }
            } else if (next3 === "PM") {
              if (trueHour < 12) {
                prev2.hour = trueHour + 12;
              }
            }
          }
          return {
            ...prev2,
            [part]: next3
          };
        } else if (part === "hour") {
          const next3 = castCb(pVal);
          if (next3 !== null && prev2.dayPeriod !== null) {
            const dayPeriod = formatter.dayPeriod(toDate(dateRef.set({ hour: next3 })));
            if (dayPeriod === "AM" || dayPeriod === "PM") {
              prev2.dayPeriod = dayPeriod;
            }
          }
          return {
            ...prev2,
            [part]: next3
          };
        }
        const next2 = castCb(pVal);
        return {
          ...prev2,
          [part]: next2
        };
      } else if (isDateSegmentPart(part)) {
        const pVal = prev2[part];
        const castCb = cb;
        const next2 = castCb(pVal);
        if (part === "month" && next2 !== null && prev2.day !== null) {
          const date = dateRef.set({ month: next2 });
          const daysInMonth = getDaysInMonth(toDate(date));
          if (prev2.day > daysInMonth) {
            prev2.day = daysInMonth;
          }
        }
        return {
          ...prev2,
          [part]: next2
        };
      }
      return prev2;
    });
    const $segmentValues = segmentValues.get();
    const $fieldId = ids.field.get();
    if (areAllSegmentsFilled($segmentValues, $fieldId)) {
      value.set(getValueFromSegments({
        segmentObj: $segmentValues,
        id: $fieldId,
        dateRef: placeholder.get()
      }));
      updatingDayPeriod.set(null);
    } else {
      value.set(void 0);
      segmentValues.set($segmentValues);
    }
  }
  function handleSegmentKeydown(e, part) {
    const $disabled = disabled.get();
    if (e.key !== kbd.TAB) {
      e.preventDefault();
    }
    if ($disabled)
      return;
    const segmentKeydownHandlers = {
      day: handleDaySegmentKeydown,
      month: handleMonthSegmentKeydown,
      year: handleYearSegmentKeydown,
      hour: handleHourSegmentKeydown,
      minute: handleMinuteSegmentKeydown,
      second: handleSecondSegmentKeydown,
      dayPeriod: handleDayPeriodSegmentKeydown,
      timeZoneName: handleTimeZoneSegmentKeydown
    };
    segmentKeydownHandlers[part](e);
  }
  function handleSegmentClick(e) {
    const $disabled = disabled.get();
    if ($disabled) {
      e.preventDefault();
      return;
    }
  }
  function daySegmentAttrs(props2) {
    const { segmentValues: segmentValues2, placeholder: placeholder2, ids: ids2 } = props2;
    const isEmpty = segmentValues2.day === null;
    const date = segmentValues2.day ? placeholder2.set({ day: segmentValues2.day }) : placeholder2;
    const valueNow = date.day;
    const valueMin = 1;
    const valueMax = getDaysInMonth(toDate(date));
    const valueText = isEmpty ? "Empty" : `${valueNow}`;
    return {
      ...defaultSegmentAttrs,
      id: ids2.day,
      "aria-label": `day,`,
      "aria-valuemin": valueMin,
      "aria-valuemax": valueMax,
      "aria-valuenow": valueNow,
      "aria-valuetext": valueText
    };
  }
  function daySegmentAction(node) {
    const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => handleSegmentKeydown(e, "day")), addMeltEventListener(node, "focusout", () => states.day.hasLeftFocus = true), addMeltEventListener(node, "click", handleSegmentClick));
    return {
      destroy() {
        unsubEvents();
      }
    };
  }
  function handleDaySegmentKeydown(e) {
    if (!isAcceptableSegmentKey(e.key)) {
      return;
    }
    const $segmentMonthValue = segmentValues.get().month;
    const $placeholder = placeholder.get();
    const daysInMonth = $segmentMonthValue ? getDaysInMonth($placeholder.set({ month: $segmentMonthValue })) : getDaysInMonth($placeholder);
    if (e.key === kbd.ARROW_UP) {
      updateSegment("day", (prev2) => {
        if (prev2 === null) {
          const next3 = $placeholder.day;
          announcer.announce(next3);
          return next3;
        }
        const next2 = $placeholder.set({ day: prev2 }).cycle("day", 1).day;
        announcer.announce(next2);
        return next2;
      });
      return;
    }
    if (e.key === kbd.ARROW_DOWN) {
      updateSegment("day", (prev2) => {
        if (prev2 === null) {
          const next3 = $placeholder.day;
          announcer.announce(next3);
          return next3;
        }
        const next2 = $placeholder.set({ day: prev2 }).cycle("day", -1).day;
        announcer.announce(next2);
        return next2;
      });
      return;
    }
    const $fieldId = ids.field.get();
    if (isNumberString(e.key)) {
      const num = parseInt(e.key);
      let moveToNext = false;
      updateSegment("day", (prev2) => {
        const max = daysInMonth;
        const maxStart = Math.floor(max / 10);
        if (states.day.hasLeftFocus) {
          prev2 = null;
          states.day.hasLeftFocus = false;
        }
        if (prev2 === null) {
          if (num === 0) {
            states.day.lastKeyZero = true;
            return null;
          }
          if (states.day.lastKeyZero || num > maxStart) {
            moveToNext = true;
          }
          states.day.lastKeyZero = false;
          return num;
        }
        const digits = prev2.toString().length;
        const total = parseInt(prev2.toString() + num.toString());
        if (digits === 2 || total > max) {
          if (num > maxStart || total > max) {
            moveToNext = true;
          }
          announcer.announce(num);
          return num;
        }
        moveToNext = true;
        announcer.announce(total);
        return total;
      });
      if (moveToNext) {
        moveToNextSegment(e, $fieldId);
      }
    }
    if (e.key === kbd.BACKSPACE) {
      const currentTarget = e.currentTarget;
      if (!isHTMLElement(currentTarget))
        return;
      updateSegment("day", (prev2) => {
        if (prev2 === null)
          return null;
        const str = prev2.toString();
        if (str.length === 1)
          return null;
        return parseInt(str.slice(0, -1));
      });
    }
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, $fieldId);
    }
  }
  function monthSegmentAttrs(props2) {
    const { segmentValues: segmentValues2, placeholder: placeholder2, ids: ids2 } = props2;
    const isEmpty = segmentValues2.month === null;
    const date = segmentValues2.month ? placeholder2.set({ month: segmentValues2.month }) : placeholder2;
    const valueNow = date.month;
    const valueMin = 1;
    const valueMax = 12;
    const valueText = isEmpty ? "Empty" : `${valueNow} - ${formatter.fullMonth(toDate(date))}`;
    return {
      ...defaultSegmentAttrs,
      id: ids2.month,
      "aria-label": "month, ",
      contenteditable: true,
      "aria-valuemin": valueMin,
      "aria-valuemax": valueMax,
      "aria-valuenow": valueNow,
      "aria-valuetext": valueText
    };
  }
  function monthSegmentAction(node) {
    const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => handleSegmentKeydown(e, "month")), addMeltEventListener(node, "focusout", () => states.month.hasLeftFocus = true), addMeltEventListener(node, "click", handleSegmentClick));
    return {
      destroy() {
        unsubEvents();
      }
    };
  }
  function handleMonthSegmentKeydown(e) {
    if (!isAcceptableSegmentKey(e.key)) {
      return;
    }
    const $placeholder = placeholder.get();
    function getMonthAnnouncement(month) {
      return `${month} - ${formatter.fullMonth(toDate($placeholder.set({ month })))}`;
    }
    const max = 12;
    states.month.hasTouched = true;
    if (e.key === kbd.ARROW_UP) {
      updateSegment("month", (prev2) => {
        if (prev2 === null) {
          const next3 = $placeholder.month;
          announcer.announce(getMonthAnnouncement(next3));
          return next3;
        }
        const next2 = $placeholder.set({ month: prev2 }).cycle("month", 1);
        announcer.announce(getMonthAnnouncement(next2.month));
        return next2.month;
      });
      return;
    }
    if (e.key === kbd.ARROW_DOWN) {
      updateSegment("month", (prev2) => {
        if (prev2 === null) {
          const next3 = $placeholder.month;
          announcer.announce(getMonthAnnouncement(next3));
          return next3;
        }
        const next2 = $placeholder.set({ month: prev2 }).cycle("month", -1).month;
        announcer.announce(getMonthAnnouncement(next2));
        return next2;
      });
      return;
    }
    const $fieldId = ids.field.get();
    if (isNumberString(e.key)) {
      const num = parseInt(e.key);
      let moveToNext = false;
      updateSegment("month", (prev2) => {
        const maxStart = Math.floor(max / 10);
        if (states.month.hasLeftFocus) {
          prev2 = null;
          states.month.hasLeftFocus = false;
        }
        if (prev2 === null) {
          if (num === 0) {
            states.month.lastKeyZero = true;
            announcer.announce(null);
            return null;
          }
          if (states.month.lastKeyZero || num > maxStart) {
            moveToNext = true;
          }
          states.month.lastKeyZero = false;
          announcer.announce(num);
          return num;
        }
        const digits = prev2.toString().length;
        const total = parseInt(prev2.toString() + num.toString());
        if (digits === 2 || total > max) {
          if (num > maxStart) {
            moveToNext = true;
          }
          announcer.announce(num);
          return num;
        }
        moveToNext = true;
        announcer.announce(total);
        return total;
      });
      if (moveToNext) {
        moveToNextSegment(e, $fieldId);
      }
    }
    if (e.key === kbd.BACKSPACE) {
      states.month.hasLeftFocus = false;
      updateSegment("month", (prev2) => {
        if (prev2 === null) {
          announcer.announce(null);
          return null;
        }
        const str = prev2.toString();
        if (str.length === 1) {
          announcer.announce(null);
          return null;
        }
        const next2 = parseInt(str.slice(0, -1));
        announcer.announce(getMonthAnnouncement(next2));
        return next2;
      });
    }
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, $fieldId);
    }
  }
  function yearSegmentAttrs(props2) {
    const { segmentValues: segmentValues2, placeholder: placeholder2, ids: ids2 } = props2;
    const isEmpty = segmentValues2.year === null;
    const date = segmentValues2.year ? placeholder2.set({ year: segmentValues2.year }) : placeholder2;
    const valueMin = 1;
    const valueMax = 9999;
    const valueNow = date.year;
    const valueText = isEmpty ? "Empty" : `${valueNow}`;
    return {
      ...defaultSegmentAttrs,
      id: ids2.year,
      "aria-label": "year, ",
      "aria-valuemin": valueMin,
      "aria-valuemax": valueMax,
      "aria-valuenow": valueNow,
      "aria-valuetext": valueText
    };
  }
  function yearSegmentAction(node) {
    const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => handleSegmentKeydown(e, "year")), addMeltEventListener(node, "focusout", () => states.year.hasLeftFocus = true), addMeltEventListener(node, "click", handleSegmentClick));
    return {
      destroy() {
        unsubEvents();
      }
    };
  }
  function handleYearSegmentKeydown(e) {
    if (!isAcceptableSegmentKey(e.key)) {
      return;
    }
    states.year.hasTouched = true;
    const $placeholder = placeholder.get();
    if (e.key === kbd.ARROW_UP) {
      updateSegment("year", (prev2) => {
        if (prev2 === null) {
          const next3 = $placeholder.year;
          announcer.announce(next3);
          return next3;
        }
        const next2 = $placeholder.set({ year: prev2 }).cycle("year", 1).year;
        announcer.announce(next2);
        return next2;
      });
      return;
    }
    if (e.key === kbd.ARROW_DOWN) {
      updateSegment("year", (prev2) => {
        if (prev2 === null) {
          const next3 = $placeholder.year;
          announcer.announce(next3);
          return next3;
        }
        const next2 = $placeholder.set({ year: prev2 }).cycle("year", -1).year;
        announcer.announce(next2);
        return next2;
      });
      return;
    }
    const $fieldId = ids.field.get();
    if (isNumberString(e.key)) {
      let moveToNext = false;
      const num = parseInt(e.key);
      updateSegment("year", (prev2) => {
        if (states.year.hasLeftFocus) {
          prev2 = null;
          states.year.hasLeftFocus = false;
        }
        if (prev2 === null) {
          announcer.announce(num);
          return num;
        }
        const str = prev2.toString() + num.toString();
        if (str.length > 4) {
          announcer.announce(num);
          return num;
        }
        if (str.length === 4) {
          moveToNext = true;
        }
        const int = parseInt(str);
        announcer.announce(int);
        return int;
      });
      if (moveToNext) {
        moveToNextSegment(e, $fieldId);
      }
    }
    if (e.key === kbd.BACKSPACE) {
      updateSegment("year", (prev2) => {
        if (prev2 === null) {
          announcer.announce(null);
          return null;
        }
        const str = prev2.toString();
        if (str.length === 1) {
          announcer.announce(null);
          return null;
        }
        const next2 = parseInt(str.slice(0, -1));
        announcer.announce(next2);
        return next2;
      });
    }
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, $fieldId);
    }
  }
  function hourSegmentAttrs(props2) {
    const { segmentValues: segmentValues2, hourCycle: hourCycle2, placeholder: placeholder2, ids: ids2 } = props2;
    if (!("hour" in segmentValues2) || !("hour" in placeholder2))
      return {};
    const isEmpty = segmentValues2.hour === null;
    const date = segmentValues2.hour ? placeholder2.set({ hour: segmentValues2.hour }) : placeholder2;
    const valueMin = hourCycle2 === 12 ? 1 : 0;
    const valueMax = hourCycle2 === 12 ? 12 : 23;
    const valueNow = date.hour;
    const valueText = isEmpty ? "Empty" : `${valueNow} ${segmentValues2.dayPeriod ?? ""}`;
    return {
      ...defaultSegmentAttrs,
      id: ids2.hour,
      "aria-label": "hour, ",
      "aria-valuemin": valueMin,
      "aria-valuemax": valueMax,
      "aria-valuenow": valueNow,
      "aria-valuetext": valueText
    };
  }
  function hourSegmentAction(node) {
    const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => handleSegmentKeydown(e, "hour")), addMeltEventListener(node, "focusout", () => states.hour.hasLeftFocus = true), addMeltEventListener(node, "click", handleSegmentClick));
    return {
      destroy() {
        unsubEvents();
      }
    };
  }
  function handleHourSegmentKeydown(e) {
    const dateRef = placeholder.get();
    if (!isAcceptableSegmentKey(e.key) || !("hour" in dateRef)) {
      return;
    }
    states.hour.hasTouched = true;
    const $hourCycle = hourCycle.get();
    if (e.key === kbd.ARROW_UP) {
      updateSegment("hour", (prev2) => {
        if (prev2 === null) {
          const next3 = dateRef.cycle("hour", 1, { hourCycle: $hourCycle }).hour;
          announcer.announce(next3);
          return next3;
        }
        const next2 = dateRef.set({ hour: prev2 }).cycle("hour", 1, { hourCycle: $hourCycle }).hour;
        announcer.announce(next2);
        return next2;
      });
      return;
    }
    if (e.key === kbd.ARROW_DOWN) {
      updateSegment("hour", (prev2) => {
        if (prev2 === null) {
          const next3 = dateRef.cycle("hour", -1, { hourCycle: $hourCycle }).hour;
          announcer.announce(next3);
          return next3;
        }
        const next2 = dateRef.set({ hour: prev2 }).cycle("hour", -1, { hourCycle: $hourCycle }).hour;
        announcer.announce(next2);
        return next2;
      });
      return;
    }
    const $fieldId = ids.field.get();
    if (isNumberString(e.key)) {
      const num = parseInt(e.key);
      let moveToNext = false;
      updateSegment("hour", (prev2) => {
        const maxStart = Math.floor(24 / 10);
        if (states.hour.hasLeftFocus) {
          prev2 = null;
          states.hour.hasLeftFocus = false;
        }
        if (prev2 === null) {
          if (num === 0) {
            states.hour.lastKeyZero = true;
            announcer.announce(null);
            return null;
          }
          if (states.hour.lastKeyZero || num > maxStart) {
            moveToNext = true;
          }
          states.hour.lastKeyZero = false;
          announcer.announce(num);
          return num;
        }
        const digits = prev2.toString().length;
        const total = parseInt(prev2.toString() + num.toString());
        if (digits === 2 || total > 24) {
          if (num > maxStart) {
            moveToNext = true;
          }
          announcer.announce(num);
          return num;
        }
        moveToNext = true;
        announcer.announce(total);
        return total;
      });
      if (moveToNext) {
        moveToNextSegment(e, $fieldId);
      }
    }
    if (e.key === kbd.BACKSPACE) {
      states.hour.hasLeftFocus = false;
      updateSegment("hour", (prev2) => {
        if (prev2 === null) {
          announcer.announce(null);
          return null;
        }
        const str = prev2.toString();
        if (str.length === 1) {
          announcer.announce(null);
          return null;
        }
        const next2 = parseInt(str.slice(0, -1));
        announcer.announce(next2);
        return next2;
      });
    }
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, $fieldId);
    }
  }
  function minuteSegmentAttrs(props2) {
    const { segmentValues: segmentValues2, placeholder: placeholder2, ids: ids2 } = props2;
    if (!("minute" in segmentValues2) || !("minute" in placeholder2))
      return {};
    const isEmpty = segmentValues2.minute === null;
    const date = segmentValues2.minute ? placeholder2.set({ minute: segmentValues2.minute }) : placeholder2;
    const valueNow = date.minute;
    const valueMin = 0;
    const valueMax = 59;
    const valueText = isEmpty ? "Empty" : `${valueNow}`;
    return {
      ...defaultSegmentAttrs,
      id: ids2.minute,
      "aria-label": "minute, ",
      "aria-valuemin": valueMin,
      "aria-valuemax": valueMax,
      "aria-valuenow": valueNow,
      "aria-valuetext": valueText
    };
  }
  function minuteSegmentAction(node) {
    const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => handleSegmentKeydown(e, "minute")), addMeltEventListener(node, "focusout", () => states.minute.hasLeftFocus = true), addMeltEventListener(node, "click", handleSegmentClick));
    return {
      destroy() {
        unsubEvents();
      }
    };
  }
  function handleMinuteSegmentKeydown(e) {
    const dateRef = placeholder.get();
    if (!isAcceptableSegmentKey(e.key) || !("minute" in dateRef)) {
      return;
    }
    states.minute.hasTouched = true;
    const min = 0;
    const max = 59;
    if (e.key === kbd.ARROW_UP) {
      updateSegment("minute", (prev2) => {
        if (prev2 === null) {
          announcer.announce(min);
          return min;
        }
        const next2 = dateRef.set({ minute: prev2 }).cycle("minute", 1).minute;
        announcer.announce(next2);
        return next2;
      });
      return;
    }
    if (e.key === kbd.ARROW_DOWN) {
      updateSegment("minute", (prev2) => {
        if (prev2 === null) {
          announcer.announce(max);
          return max;
        }
        const next2 = dateRef.set({ minute: prev2 }).cycle("minute", -1).minute;
        announcer.announce(next2);
        return next2;
      });
      return;
    }
    const $fieldId = ids.field.get();
    if (isNumberString(e.key)) {
      const num = parseInt(e.key);
      let moveToNext = false;
      updateSegment("minute", (prev2) => {
        const maxStart = Math.floor(max / 10);
        if (states.minute.hasLeftFocus) {
          prev2 = null;
          states.minute.hasLeftFocus = false;
        }
        if (prev2 === null) {
          if (num === 0) {
            states.minute.lastKeyZero = true;
            announcer.announce(null);
            return 0;
          }
          if (states.minute.lastKeyZero || num > maxStart) {
            moveToNext = true;
          }
          states.minute.lastKeyZero = false;
          announcer.announce(num);
          return num;
        }
        const digits = prev2.toString().length;
        const total = parseInt(prev2.toString() + num.toString());
        if (digits === 2 || total > max) {
          if (num > maxStart) {
            moveToNext = true;
          }
          announcer.announce(num);
          return num;
        }
        moveToNext = true;
        announcer.announce(total);
        return total;
      });
      if (moveToNext) {
        moveToNextSegment(e, $fieldId);
      }
    }
    if (e.key === kbd.BACKSPACE) {
      states.minute.hasLeftFocus = false;
      updateSegment("minute", (prev2) => {
        if (prev2 === null) {
          announcer.announce("Empty");
          return null;
        }
        const str = prev2.toString();
        if (str.length === 1) {
          announcer.announce("Empty");
          return null;
        }
        const next2 = parseInt(str.slice(0, -1));
        announcer.announce(next2);
        return next2;
      });
    }
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, $fieldId);
    }
  }
  function secondSegmentAttrs(props2) {
    const { segmentValues: segmentValues2, placeholder: placeholder2, ids: ids2 } = props2;
    if (!("second" in segmentValues2) || !("second" in placeholder2))
      return {};
    const isEmpty = segmentValues2.second === null;
    const date = segmentValues2.second ? placeholder2.set({ second: segmentValues2.second }) : placeholder2;
    const valueNow = date.second;
    const valueMin = 0;
    const valueMax = 59;
    const valueText = isEmpty ? "Empty" : `${valueNow}`;
    return {
      ...defaultSegmentAttrs,
      id: ids2.second,
      "aria-label": "second, ",
      "aria-valuemin": valueMin,
      "aria-valuemax": valueMax,
      "aria-valuenow": valueNow,
      "aria-valuetext": valueText
    };
  }
  function secondSegmentAction(node) {
    const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => handleSegmentKeydown(e, "second")), addMeltEventListener(node, "focusout", () => states.second.hasLeftFocus = true), addMeltEventListener(node, "click", handleSegmentClick));
    return {
      destroy() {
        unsubEvents();
      }
    };
  }
  function handleSecondSegmentKeydown(e) {
    const dateRef = placeholder.get();
    if (!isAcceptableSegmentKey(e.key)) {
      return;
    }
    states.second.hasTouched = true;
    const min = 0;
    const max = 59;
    if (!("second" in dateRef))
      return;
    if (e.key === kbd.ARROW_UP) {
      updateSegment("second", (prev2) => {
        if (prev2 === null) {
          announcer.announce(min);
          return min;
        }
        const next2 = dateRef.set({ second: prev2 }).cycle("second", 1).second;
        announcer.announce(next2);
        return next2;
      });
      return;
    }
    if (e.key === kbd.ARROW_DOWN) {
      updateSegment("second", (prev2) => {
        if (prev2 === null) {
          announcer.announce(max);
          return max;
        }
        const next2 = dateRef.set({ second: prev2 }).cycle("second", -1).second;
        announcer.announce(next2);
        return next2;
      });
      return;
    }
    const $fieldId = ids.field.get();
    if (isNumberString(e.key)) {
      const num = parseInt(e.key);
      let moveToNext = false;
      updateSegment("second", (prev2) => {
        const maxStart = Math.floor(max / 10);
        if (states.second.hasLeftFocus) {
          prev2 = null;
          states.second.hasLeftFocus = false;
        }
        if (prev2 === null) {
          if (num === 0) {
            states.second.lastKeyZero = true;
            announcer.announce(null);
            return 0;
          }
          if (states.second.lastKeyZero || num > maxStart) {
            moveToNext = true;
          }
          states.second.lastKeyZero = false;
          announcer.announce(num);
          return num;
        }
        const digits = prev2.toString().length;
        const total = parseInt(prev2.toString() + num.toString());
        if (digits === 2 || total > max) {
          if (num > maxStart) {
            moveToNext = true;
          }
          announcer.announce(num);
          return num;
        }
        moveToNext = true;
        announcer.announce(total);
        return total;
      });
      if (moveToNext) {
        moveToNextSegment(e, $fieldId);
      }
    }
    if (e.key === kbd.BACKSPACE) {
      states.second.hasLeftFocus = false;
      updateSegment("second", (prev2) => {
        if (prev2 === null) {
          announcer.announce(null);
          return null;
        }
        const str = prev2.toString();
        if (str.length === 1) {
          announcer.announce(null);
          return null;
        }
        const next2 = parseInt(str.slice(0, -1));
        announcer.announce(next2);
        return next2;
      });
    }
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, $fieldId);
    }
  }
  function dayPeriodSegmentAttrs(props2) {
    const { segmentValues: segmentValues2, ids: ids2 } = props2;
    if (!("dayPeriod" in segmentValues2))
      return {};
    const valueMin = 0;
    const valueMax = 12;
    const valueNow = segmentValues2.dayPeriod ?? 0;
    const valueText = segmentValues2.dayPeriod ?? "AM";
    return {
      ...defaultSegmentAttrs,
      inputmode: "text",
      id: ids2.dayPeriod,
      "aria-label": "AM/PM",
      "aria-valuemin": valueMin,
      "aria-valuemax": valueMax,
      "aria-valuenow": valueNow,
      "aria-valuetext": valueText
    };
  }
  function dayPeriodSegmentAction(node) {
    const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => handleSegmentKeydown(e, "dayPeriod")), addMeltEventListener(node, "click", handleSegmentClick));
    return {
      destroy() {
        unsubEvents();
      }
    };
  }
  function handleDayPeriodSegmentKeydown(e) {
    if (!isAcceptableSegmentKey(e.key) && e.key !== kbd.A && e.key !== kbd.P) {
      return;
    }
    if (e.key === kbd.ARROW_UP || e.key === kbd.ARROW_DOWN) {
      updateSegment("dayPeriod", (prev2) => {
        if (prev2 === "AM") {
          const next3 = "PM";
          announcer.announce(next3);
          return next3;
        }
        const next2 = "AM";
        announcer.announce(next2);
        return next2;
      });
      return;
    }
    if (e.key === kbd.BACKSPACE) {
      states.second.hasLeftFocus = false;
      updateSegment("dayPeriod", () => {
        const next2 = "AM";
        announcer.announce(next2);
        return "AM";
      });
    }
    if (e.key === "a") {
      updateSegment("dayPeriod", () => {
        const next2 = "AM";
        announcer.announce(next2);
        return "AM";
      });
    }
    if (e.key === "p") {
      updateSegment("dayPeriod", () => {
        const next2 = "PM";
        announcer.announce(next2);
        return "PM";
      });
    }
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, ids.field.get());
    }
  }
  function literalSegmentAttrs(_) {
    return {
      "aria-hidden": true,
      "data-segment": "literal"
    };
  }
  function literalSegmentAction(_) {
    return {
      destroy: noop
    };
  }
  function timeZoneSegmentAttrs(_) {
    return {
      role: "textbox",
      "aria-label": "timezone, ",
      "data-readonly": true,
      "data-segment": "timeZoneName",
      tabindex: 0,
      style: styleToString({
        "caret-color": "transparent"
      })
    };
  }
  function timeZoneSegmentAction(node) {
    const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => handleSegmentKeydown(e, "timeZoneName")), addMeltEventListener(node, "click", handleSegmentClick));
    return {
      destroy() {
        unsubEvents();
      }
    };
  }
  function handleTimeZoneSegmentKeydown(e) {
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, ids.field.get());
    }
  }
  function getSegmentAttrs(part, props2) {
    var _a;
    return (_a = segmentBuilders[part]) == null ? void 0 : _a.attrs(props2);
  }
  function getSegmentAction(node) {
    const part = getPartFromNode(node);
    if (!part) {
      throw new Error("No segment part found");
    }
    return segmentBuilders[part].action(node);
  }
  function getLabelledBy(part) {
    return `${ids[part].get()} ${ids.label.get()}`;
  }
  effect(locale, ($locale) => {
    if (formatter.getLocale() === $locale)
      return;
    formatter.setLocale($locale);
  });
  effect(value, ($value) => {
    if ($value) {
      setDescription(ids.description.get(), formatter, $value);
    }
    if ($value && placeholder.get() !== $value) {
      placeholder.set($value);
    }
  });
  effect([value, locale], ([$value, _]) => {
    if ($value) {
      syncSegmentValues({
        value: $value,
        segmentValues,
        formatter,
        updatingDayPeriod
      });
    } else {
      segmentValues.set(structuredClone(initialSegments));
    }
  });
  const _isDateUnavailable = derived(isDateUnavailable, ($isDateUnavailable) => {
    return (date) => $isDateUnavailable == null ? void 0 : $isDateUnavailable(date);
  });
  return {
    elements: {
      field,
      segment,
      label,
      hiddenInput,
      validation
    },
    states: {
      value,
      segmentValues,
      segmentContents,
      segmentContentsObj,
      placeholder: placeholder.toWritable(),
      isInvalid
    },
    helpers: {
      isDateUnavailable: _isDateUnavailable
    },
    options,
    ids
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/date/focus.js
function pickerOpenFocus(defaultEl) {
  const el = document.querySelector("[data-melt-calendar-cell][data-focused]");
  if (isHTMLElement(el)) {
    return el;
  }
  if (isHTMLElement(defaultEl)) {
    return defaultEl;
  }
  return null;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/date-picker/create.js
var defaults12 = {
  isDateDisabled: void 0,
  isDateUnavailable: void 0,
  value: void 0,
  positioning: {
    placement: "bottom"
  },
  closeOnEscape: true,
  closeOnOutsideClick: true,
  onOutsideClick: void 0,
  preventScroll: false,
  forceVisible: false,
  locale: "en",
  granularity: void 0,
  disabled: false,
  readonly: false,
  minValue: void 0,
  maxValue: void 0,
  weekdayFormat: "narrow",
  ...omit(defaults10, "isDateDisabled", "isDateUnavailable", "value", "locale", "disabled", "readonly", "minValue", "maxValue", "weekdayFormat")
};
function createDatePicker(props) {
  const withDefaults = { ...defaults12, ...props };
  const options = toWritableStores(omit(withDefaults, "value", "placeholder"));
  const dateField = createDateField({
    ...withDefaults,
    ids: withDefaults.dateFieldIds
  });
  const { states: { value, placeholder: dfPlaceholder } } = dateField;
  const calendar = createCalendar({
    ...omit(withDefaults, "onValueChange"),
    placeholder: dfPlaceholder,
    value,
    ids: withDefaults.calendarIds
  });
  const popover = createPopover({
    positioning: withDefaults.positioning,
    arrowSize: withDefaults.arrowSize,
    defaultOpen: withDefaults.defaultOpen,
    open: withDefaults.open,
    disableFocusTrap: withDefaults.disableFocusTrap,
    closeOnEscape: withDefaults.closeOnEscape,
    preventScroll: withDefaults.preventScroll,
    onOpenChange: withDefaults.onOpenChange,
    closeOnOutsideClick: withDefaults.closeOnOutsideClick,
    portal: withDefaults.portal,
    forceVisible: withDefaults.forceVisible,
    openFocus: pickerOpenFocus,
    ids: withDefaults.popoverIds,
    onOutsideClick: withDefaults.onOutsideClick
  });
  const trigger = makeElement("popover-trigger", {
    stores: [popover.elements.trigger, options.disabled],
    returned: ([$trigger, $disabled]) => {
      return {
        ...omit($trigger, "action"),
        "aria-label": "Open date picker",
        "data-segment": "trigger",
        disabled: $disabled ? true : void 0
      };
    },
    action: (node) => {
      const unsubKeydown = addMeltEventListener(node, "keydown", handleTriggerKeydown);
      const { destroy } = popover.elements.trigger(node);
      return {
        destroy() {
          destroy == null ? void 0 : destroy();
          unsubKeydown();
        }
      };
    }
  });
  const formatter = createFormatter(options.locale.get());
  effect([options.locale], ([$locale]) => {
    dateField.options.locale.set($locale);
    calendar.options.locale.set($locale);
    if (formatter.getLocale() === $locale)
      return;
    formatter.setLocale($locale);
  });
  effect([options.weekdayFormat], ([$weekdayFormat]) => {
    calendar.options.weekdayFormat.set($weekdayFormat);
  });
  effect([options.disabled], ([$disabled]) => {
    dateField.options.disabled.set($disabled);
    calendar.options.disabled.set($disabled);
  });
  effect([options.readonly], ([$readonly]) => {
    dateField.options.readonly.set($readonly);
    calendar.options.readonly.set($readonly);
  });
  effect([options.minValue], ([$minValue]) => {
    dateField.options.minValue.set($minValue);
    calendar.options.minValue.set($minValue);
  });
  effect([options.maxValue], ([$maxValue]) => {
    dateField.options.maxValue.set($maxValue);
    calendar.options.maxValue.set($maxValue);
  });
  effect([options.numberOfMonths], ([$numberOfMonths]) => {
    calendar.options.numberOfMonths.set($numberOfMonths);
  });
  effect([options.fixedWeeks], ([$fixedWeeks]) => {
    calendar.options.fixedWeeks.set($fixedWeeks);
  });
  effect([options.weekStartsOn], ([$weekStartsOn]) => {
    calendar.options.weekStartsOn.set($weekStartsOn);
  });
  const dateFieldOptions = omit(dateField.options, "locale", "disabled", "readonly", "minValue", "maxValue");
  const calendarOptions = omit(calendar.options, "locale", "disabled", "readonly", "minValue", "maxValue");
  const { states: { open } } = popover;
  const defaultDate = getDefaultDate({
    defaultPlaceholder: withDefaults.defaultPlaceholder,
    defaultValue: withDefaults.defaultValue,
    granularity: withDefaults.granularity
  });
  const placeholder = dateStore(dfPlaceholder, withDefaults.defaultPlaceholder ?? defaultDate);
  effect([open], ([$open]) => {
    if (!$open) {
      const $value = value.get();
      if ($value) {
        placeholder.set($value);
      } else {
        placeholder.reset();
      }
    }
  });
  function handleTriggerKeydown(e) {
    if (isSegmentNavigationKey(e.key)) {
      e.preventDefault();
      handleSegmentNavigation(e, dateField.ids.field.get());
    }
  }
  return {
    elements: {
      ...calendar.elements,
      ...dateField.elements,
      ...popover.elements,
      trigger
    },
    states: {
      ...dateField.states,
      ...calendar.states,
      placeholder: placeholder.toWritable(),
      value,
      ...popover.states
    },
    helpers: {
      ...calendar.helpers
    },
    options: {
      ...dateFieldOptions,
      ...calendarOptions,
      ...options,
      ...popover.options
    },
    ids: {
      dateField: dateField.ids,
      calendar: calendar.ids,
      popover: popover.ids
    }
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/date-range-field/_internal/helpers.js
function removeDescriptionElement2(id) {
  if (!isBrowser)
    return;
  const el = document.getElementById(id);
  if (!el)
    return;
  document.body.removeChild(el);
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/date-range-field/create.js
var defaults13 = {
  isDateUnavailable: void 0,
  value: void 0,
  hourCycle: void 0,
  locale: "en",
  granularity: void 0,
  hideTimeZone: false,
  defaultValue: {
    start: void 0,
    end: void 0
  },
  startName: void 0,
  endName: void 0,
  disabled: false,
  readonly: false,
  readonlySegments: void 0,
  minValue: void 0,
  maxValue: void 0
};
var { name: name7 } = createElHelpers("dateField");
var rangeFieldIdParts = ["field", "label", "description", "validation"];
function createDateRangeField(props) {
  var _a, _b, _c, _d, _e, _f, _g;
  const withDefaults = { ...defaults13, ...props };
  const options = toWritableStores(omit(withDefaults, "value", "placeholder"));
  const generatedIds = generateIds(rangeFieldIdParts);
  const ids = toWritableStores({ ...generatedIds, ...withDefaults.ids });
  const defaultDate = getDefaultDate({
    defaultValue: (_a = withDefaults.defaultValue) == null ? void 0 : _a.start,
    defaultPlaceholder: withDefaults.defaultPlaceholder,
    granularity: withDefaults.granularity
  });
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults.onValueChange);
  const startValue = withGet.writable(((_b = value.get()) == null ? void 0 : _b.start) ?? ((_c = withDefaults.defaultValue) == null ? void 0 : _c.start));
  const endValue = withGet.writable(((_d = value.get()) == null ? void 0 : _d.end) ?? ((_e = withDefaults.defaultValue) == null ? void 0 : _e.end));
  const isCompleted = derived(value, ($value) => {
    return ($value == null ? void 0 : $value.start) && ($value == null ? void 0 : $value.end);
  });
  const placeholderWritable = withDefaults.placeholder ?? writable(withDefaults.defaultPlaceholder ?? defaultDate);
  const placeholder = dateStore(overridable(placeholderWritable, withDefaults.onPlaceholderChange), withDefaults.defaultPlaceholder ?? defaultDate);
  const startField = createDateField({
    ...omit(withDefaults, "defaultValue", "onValueChange", "startName", "endName", "readonlySegments"),
    value: startValue,
    name: withDefaults.startName,
    readonlySegments: (_f = withDefaults.readonlySegments) == null ? void 0 : _f.start,
    ids: {
      ...generatedIds,
      ...withDefaults.ids,
      ...withDefaults.startIds
    }
  });
  const endField = createDateField({
    ...omit(withDefaults, "defaultValue", "onValueChange", "endName", "startName", "readonlySegments"),
    value: endValue,
    name: withDefaults.endName,
    readonlySegments: (_g = withDefaults.readonlySegments) == null ? void 0 : _g.end,
    ids: {
      ...generatedIds,
      ...withDefaults.ids,
      ...withDefaults.endIds
    }
  });
  const { elements: { segment: startSegment, hiddenInput: startHiddenInput }, states: { isInvalid: isStartInvalid, segmentContents: startSegmentContents, segmentValues: startSegmentValues }, options: { name: startName } } = startField;
  const { elements: { segment: endSegment, hiddenInput: endHiddenInput }, states: { isInvalid: isEndInvalid, segmentContents: endSegmentContents, segmentValues: endSegmentValues }, options: { name: endName } } = endField;
  const isInvalid = derived([value, isStartInvalid, isEndInvalid, options.isDateUnavailable], ([$value, $isStartInvalid, $isEndInvalid, $isDateUnavailable]) => {
    if ($isStartInvalid || $isEndInvalid) {
      return true;
    }
    if (!($value == null ? void 0 : $value.start) || !($value == null ? void 0 : $value.end)) {
      return false;
    }
    if (!isBeforeOrSame($value == null ? void 0 : $value.start, $value == null ? void 0 : $value.end)) {
      return true;
    }
    if ($isDateUnavailable !== void 0) {
      const allValid = areAllDaysBetweenValid($value == null ? void 0 : $value.start, $value == null ? void 0 : $value.end, $isDateUnavailable, void 0);
      if (!allValid) {
        return true;
      }
    }
    return false;
  });
  const label = makeElement(name7("label"), {
    stores: [isInvalid, options.disabled, ids.label],
    returned: ([$isInvalid, $disabled, $labelId]) => {
      return {
        id: $labelId,
        "data-invalid": $isInvalid ? "" : void 0,
        "data-disabled": $disabled ? "" : void 0
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        const firstSegment = getFirstSegment(ids.field.get());
        if (!firstSegment)
          return;
        sleep(1).then(() => firstSegment.focus());
      }), addMeltEventListener(node, "mousedown", (e) => {
        if (!e.defaultPrevented && e.detail > 1) {
          e.preventDefault();
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const fieldIdDeps = derived([ids.field, ids.label, ids.description, ids.validation], ([$fieldId, $labelId, $descriptionId, $validationId]) => {
    return {
      field: $fieldId,
      label: $labelId,
      description: $descriptionId,
      validation: $validationId
    };
  });
  const field = makeElement(name7("field"), {
    stores: [isCompleted, isInvalid, fieldIdDeps],
    returned: ([$isCompleted, $isInvalid, $ids]) => {
      const describedBy = $isCompleted ? `${$ids.description}${$isInvalid ? ` ${$ids.validation}` : ""}` : `${$ids.description}`;
      return {
        role: "group",
        id: $ids.field,
        "aria-labelledby": $ids.label,
        "aria-describedby": describedBy,
        "data-invalid": $isInvalid ? "" : void 0
      };
    },
    action: () => {
      getAnnouncer();
      return {
        destroy() {
          removeDescriptionElement2(ids.description.get());
        }
      };
    }
  });
  const validation = makeElement(name7("validation"), {
    stores: [isInvalid, ids.validation],
    returned: ([$isInvalid, $validationId]) => {
      const validStyle = styleToString({
        display: "none"
      });
      return {
        id: $validationId,
        "data-invalid": $isInvalid ? "" : void 0,
        style: $isInvalid ? void 0 : validStyle
      };
    }
  });
  const segmentContents = derived([startSegmentContents, endSegmentContents], ([$startSegmentContents, $endSegmentContents]) => {
    return {
      start: $startSegmentContents,
      end: $endSegmentContents
    };
  });
  effect([value], ([$value]) => {
    const $startValue = startValue.get();
    const $endValue = endValue.get();
    if (($value == null ? void 0 : $value.start) && ($value == null ? void 0 : $value.end)) {
      if ($value.start !== $startValue) {
        startValue.set($value.start);
      }
      if ($value.end !== $endValue) {
        endValue.set($value.end);
      }
      return;
    }
  });
  effect([startValue, endValue], ([$startValue, $endValue]) => {
    const $value = value.get();
    if ($value && ($value == null ? void 0 : $value.start) === $startValue && ($value == null ? void 0 : $value.end) === $endValue)
      return;
    if ($startValue && $endValue) {
      value.update((prev2) => {
        if ((prev2 == null ? void 0 : prev2.start) === $startValue && (prev2 == null ? void 0 : prev2.end) === $endValue) {
          return prev2;
        }
        return {
          start: $startValue,
          end: $endValue
        };
      });
    } else if ($value && ($value == null ? void 0 : $value.start) && ($value == null ? void 0 : $value.end)) {
      value.set({
        start: void 0,
        end: void 0
      });
    }
  });
  effect([options.disabled], ([$disabled]) => {
    startField.options.disabled.set($disabled);
    endField.options.disabled.set($disabled);
  });
  effect([options.readonly], ([$readonly]) => {
    startField.options.readonly.set($readonly);
    endField.options.readonly.set($readonly);
  });
  effect([options.readonlySegments], ([$readonlySegments]) => {
    startField.options.readonlySegments.set($readonlySegments == null ? void 0 : $readonlySegments.start);
    endField.options.readonlySegments.set($readonlySegments == null ? void 0 : $readonlySegments.end);
  });
  effect([options.minValue], ([$minValue]) => {
    startField.options.minValue.set($minValue);
    endField.options.minValue.set($minValue);
  });
  effect([options.maxValue], ([$maxValue]) => {
    startField.options.maxValue.set($maxValue);
    endField.options.maxValue.set($maxValue);
  });
  effect([options.granularity], ([$granularity]) => {
    startField.options.granularity.set($granularity);
    endField.options.granularity.set($granularity);
  });
  effect([options.hideTimeZone], ([$hideTimeZone]) => {
    startField.options.hideTimeZone.set($hideTimeZone);
    endField.options.hideTimeZone.set($hideTimeZone);
  });
  effect([options.hourCycle], ([$hourCycle]) => {
    startField.options.hourCycle.set($hourCycle);
    endField.options.hourCycle.set($hourCycle);
  });
  effect([options.locale], ([$locale]) => {
    startField.options.locale.set($locale);
    endField.options.locale.set($locale);
  });
  return {
    elements: {
      field,
      label,
      startSegment,
      endSegment,
      startHiddenInput,
      endHiddenInput,
      validation
    },
    states: {
      value,
      placeholder: placeholder.toWritable(),
      segmentContents,
      endSegmentValues,
      startSegmentValues,
      isInvalid
    },
    options: {
      ...options,
      endName,
      startName
    },
    ids: {
      field: ids,
      start: startField.ids,
      end: endField.ids
    }
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/date-range-picker/create.js
var defaults14 = {
  isDateDisabled: void 0,
  isDateUnavailable: void 0,
  value: void 0,
  positioning: {
    placement: "bottom"
  },
  closeOnEscape: true,
  closeOnOutsideClick: true,
  preventScroll: false,
  forceVisible: false,
  locale: "en",
  granularity: void 0,
  disabled: false,
  readonly: false,
  minValue: void 0,
  maxValue: void 0,
  weekdayFormat: "narrow",
  onOutsideClick: void 0
};
function createDateRangePicker(props) {
  var _a;
  const withDefaults = { ...defaults14, ...props };
  const rangeField = createDateRangeField(withDefaults);
  const { states: { value, placeholder: rfPlaceholder } } = rangeField;
  const calendar = createRangeCalendar({
    ...omit(withDefaults, "onValueChange"),
    placeholder: rfPlaceholder,
    value,
    ids: withDefaults.calendarIds
  });
  const popover = createPopover({
    positioning: withDefaults.positioning,
    arrowSize: withDefaults.arrowSize,
    defaultOpen: withDefaults.defaultOpen,
    open: withDefaults.open,
    disableFocusTrap: withDefaults.disableFocusTrap,
    closeOnEscape: withDefaults.closeOnEscape,
    preventScroll: withDefaults.preventScroll,
    onOpenChange: withDefaults.onOpenChange,
    closeOnOutsideClick: withDefaults.closeOnOutsideClick,
    portal: withDefaults.portal,
    forceVisible: withDefaults.forceVisible,
    openFocus: pickerOpenFocus,
    onOutsideClick: withDefaults.onOutsideClick
  });
  const options = toWritableStores({
    ...omit(withDefaults, "value", "placeholder")
  });
  const { locale } = options;
  const defaultDate = getDefaultDate({
    defaultValue: (_a = withDefaults.defaultValue) == null ? void 0 : _a.start,
    defaultPlaceholder: withDefaults.defaultPlaceholder,
    granularity: withDefaults.granularity
  });
  const formatter = createFormatter(locale.get());
  const placeholder = dateStore(rfPlaceholder, withDefaults.defaultPlaceholder ?? defaultDate);
  const trigger = makeElement("popover-trigger", {
    stores: [popover.elements.trigger, options.disabled],
    returned: ([$trigger, $disabled]) => {
      return {
        ...omit($trigger, "action"),
        "aria-label": "Open date picker",
        "data-segment": "trigger",
        disabled: $disabled ? true : void 0
      };
    },
    action: (node) => {
      const unsubKeydown = addMeltEventListener(node, "keydown", handleTriggerKeydown);
      const { destroy } = popover.elements.trigger(node);
      return {
        destroy() {
          destroy == null ? void 0 : destroy();
          unsubKeydown();
        }
      };
    }
  });
  effect([options.locale], ([$locale]) => {
    rangeField.options.locale.set($locale);
    calendar.options.locale.set($locale);
    if (formatter.getLocale() === $locale)
      return;
    formatter.setLocale($locale);
  });
  effect([options.weekdayFormat], ([$weekdayFormat]) => {
    calendar.options.weekdayFormat.set($weekdayFormat);
  });
  effect([options.disabled], ([$disabled]) => {
    rangeField.options.disabled.set($disabled);
    calendar.options.disabled.set($disabled);
  });
  effect([options.readonly], ([$readonly]) => {
    rangeField.options.readonly.set($readonly);
    calendar.options.readonly.set($readonly);
  });
  effect([options.minValue], ([$minValue]) => {
    rangeField.options.minValue.set($minValue);
    calendar.options.minValue.set($minValue);
  });
  effect([options.maxValue], ([$maxValue]) => {
    rangeField.options.maxValue.set($maxValue);
    calendar.options.maxValue.set($maxValue);
  });
  effect([popover.states.open], ([$open]) => {
    if (!$open) {
      const $value = value.get();
      if ($value == null ? void 0 : $value.start) {
        placeholder.set($value.start);
      } else {
        placeholder.reset();
      }
    }
  });
  effect([options.onOutsideClick], ([$onOutsideClick]) => {
    popover.options.onOutsideClick.set($onOutsideClick);
  });
  const rangeFieldOptions = omit(rangeField.options, "locale", "disabled", "readonly", "minValue", "maxValue");
  const rangeCalendarOptions = omit(calendar.options, "locale", "disabled", "readonly", "minValue", "maxValue");
  function handleTriggerKeydown(e) {
    if (isSegmentNavigationKey(e.key)) {
      e.preventDefault();
      handleSegmentNavigation(e, rangeField.ids.field.field.get());
    }
  }
  return {
    elements: {
      ...calendar.elements,
      ...rangeField.elements,
      ...popover.elements,
      trigger
    },
    states: {
      ...rangeField.states,
      ...calendar.states,
      placeholder: placeholder.toWritable(),
      value,
      ...popover.states
    },
    helpers: {
      ...calendar.helpers
    },
    options: {
      ...rangeFieldOptions,
      ...rangeCalendarOptions,
      ...options,
      ...popover.options
    },
    ids: {
      rangeField: rangeField.ids,
      calendar: calendar.ids,
      popover: popover.ids
    }
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/dialog/create.js
var { name: name8 } = createElHelpers("dialog");
var defaults15 = {
  preventScroll: true,
  closeOnEscape: true,
  closeOnOutsideClick: true,
  role: "dialog",
  defaultOpen: false,
  portal: void 0,
  forceVisible: false,
  openFocus: void 0,
  closeFocus: void 0,
  onOutsideClick: void 0
};
var dialogIdParts = ["content", "title", "description"];
function createDialog(props) {
  const withDefaults = { ...defaults15, ...props };
  const options = toWritableStores(omit(withDefaults, "ids"));
  const { preventScroll, closeOnEscape, closeOnOutsideClick, role, portal, forceVisible, openFocus, closeFocus, onOutsideClick } = options;
  const activeTrigger = withGet.writable(null);
  const ids = toWritableStores({
    ...generateIds(dialogIdParts),
    ...withDefaults.ids
  });
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => {
    return $open || $forceVisible;
  });
  let unsubScroll = noop;
  function handleOpen(e) {
    const el = e.currentTarget;
    const triggerEl = e.currentTarget;
    if (!isHTMLElement(el) || !isHTMLElement(triggerEl))
      return;
    open.set(true);
    activeTrigger.set(triggerEl);
  }
  function handleClose() {
    open.set(false);
    handleFocus({
      prop: closeFocus.get(),
      defaultEl: activeTrigger.get()
    });
  }
  const trigger = makeElement(name8("trigger"), {
    stores: [open],
    returned: ([$open]) => {
      return {
        "aria-haspopup": "dialog",
        "aria-expanded": $open,
        type: "button"
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e) => {
        handleOpen(e);
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)
          return;
        e.preventDefault();
        handleOpen(e);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const overlay = makeElement(name8("overlay"), {
    stores: [isVisible, open],
    returned: ([$isVisible, $open]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        "aria-hidden": true,
        "data-state": $open ? "open" : "closed"
      };
    },
    action: (node) => {
      let unsubEscapeKeydown = noop;
      if (closeOnEscape.get()) {
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            handleClose();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          unsubEscapeKeydown = escapeKeydown.destroy;
        }
      }
      return {
        destroy() {
          unsubEscapeKeydown();
        }
      };
    }
  });
  const content = makeElement(name8("content"), {
    stores: [isVisible, ids.content, ids.description, ids.title, open],
    returned: ([$isVisible, $contentId, $descriptionId, $titleId, $open]) => {
      return {
        id: $contentId,
        role: role.get(),
        "aria-describedby": $descriptionId,
        "aria-labelledby": $titleId,
        "aria-modal": $isVisible ? "true" : void 0,
        "data-state": $open ? "open" : "closed",
        tabindex: -1,
        hidden: $isVisible ? void 0 : true,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        })
      };
    },
    action: (node) => {
      let activate = noop;
      let deactivate = noop;
      const destroy = executeCallbacks(effect([open, closeOnOutsideClick, closeOnEscape], ([$open, $closeOnOutsideClick, $closeOnEscape]) => {
        if (!$open)
          return;
        const focusTrap = createFocusTrap2({
          immediate: false,
          escapeDeactivates: $closeOnEscape,
          clickOutsideDeactivates: $closeOnOutsideClick,
          allowOutsideClick: true,
          returnFocusOnDeactivate: false,
          fallbackFocus: node
        });
        activate = focusTrap.activate;
        deactivate = focusTrap.deactivate;
        const ac = focusTrap.useFocusTrap(node);
        if (ac && ac.destroy) {
          return ac.destroy;
        } else {
          return focusTrap.deactivate;
        }
      }), effect([closeOnOutsideClick, open], ([$closeOnOutsideClick, $open]) => {
        return useModal(node, {
          open: $open,
          closeOnInteractOutside: $closeOnOutsideClick,
          onClose() {
            handleClose();
          },
          shouldCloseOnInteractOutside(e) {
            var _a;
            (_a = onOutsideClick.get()) == null ? void 0 : _a(e);
            if (e.defaultPrevented)
              return false;
            return true;
          }
        }).destroy;
      }), effect([closeOnEscape], ([$closeOnEscape]) => {
        if (!$closeOnEscape)
          return noop;
        return useEscapeKeydown(node, { handler: handleClose }).destroy;
      }), effect([isVisible], ([$isVisible]) => {
        tick().then(() => {
          if (!$isVisible) {
            deactivate();
          } else {
            activate();
          }
        });
      }));
      return {
        destroy: () => {
          unsubScroll();
          destroy();
        }
      };
    }
  });
  const portalled = makeElement(name8("portalled"), {
    stores: portal,
    returned: ($portal) => ({
      "data-portal": portalAttr($portal)
    }),
    action: (node) => {
      const unsubPortal = effect([portal], ([$portal]) => {
        if ($portal === null)
          return noop;
        const portalDestination = getPortalDestination(node, $portal);
        if (portalDestination === null)
          return noop;
        return usePortal(node, portalDestination).destroy;
      });
      return {
        destroy() {
          unsubPortal();
        }
      };
    }
  });
  const title = makeElement(name8("title"), {
    stores: [ids.title],
    returned: ([$titleId]) => ({
      id: $titleId
    })
  });
  const description = makeElement(name8("description"), {
    stores: [ids.description],
    returned: ([$descriptionId]) => ({
      id: $descriptionId
    })
  });
  const close = makeElement(name8("close"), {
    returned: () => ({
      type: "button"
    }),
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        handleClose();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd.SPACE && e.key !== kbd.ENTER)
          return;
        e.preventDefault();
        handleClose();
      }));
      return {
        destroy: unsub
      };
    }
  });
  effect([open, preventScroll], ([$open, $preventScroll]) => {
    if (!isBrowser)
      return;
    if ($preventScroll && $open)
      unsubScroll = removeScroll();
    if ($open) {
      const contentEl = document.getElementById(ids.content.get());
      handleFocus({ prop: openFocus.get(), defaultEl: contentEl });
    }
    return () => {
      if (!forceVisible.get()) {
        unsubScroll();
      }
    };
  });
  return {
    ids,
    elements: {
      content,
      trigger,
      title,
      description,
      overlay,
      close,
      portalled
    },
    states: {
      open
    },
    options
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/dropdown-menu/create.js
var defaults16 = {
  arrowSize: 8,
  positioning: {
    placement: "bottom"
  },
  preventScroll: true,
  closeOnEscape: true,
  closeOnOutsideClick: true,
  portal: void 0,
  loop: false,
  dir: "ltr",
  defaultOpen: false,
  forceVisible: false,
  typeahead: true,
  closeFocus: void 0,
  disableFocusFirstItem: false,
  closeOnItemClick: true,
  onOutsideClick: void 0
};
function createDropdownMenu(props) {
  const withDefaults = { ...defaults16, ...props };
  const rootOptions = toWritableStores(omit(withDefaults, "ids"));
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const rootOpen = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const rootActiveTrigger = withGet(writable(null));
  const nextFocusable = withGet(writable(null));
  const prevFocusable = withGet(writable(null));
  const { elements, builders, ids, states, options } = createMenuBuilder({
    rootOptions,
    rootOpen,
    rootActiveTrigger: withGet(rootActiveTrigger),
    nextFocusable: withGet(nextFocusable),
    prevFocusable: withGet(prevFocusable),
    selector: "dropdown-menu",
    removeScroll: true,
    ids: withDefaults.ids
  });
  return {
    ids,
    elements,
    states,
    builders,
    options
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/link-preview/create.js
var { name: name9 } = createElHelpers("hover-card");
var defaults17 = {
  defaultOpen: false,
  openDelay: 1e3,
  closeDelay: 100,
  positioning: {
    placement: "bottom"
  },
  arrowSize: 8,
  closeOnOutsideClick: true,
  forceVisible: false,
  portal: void 0,
  closeOnEscape: true,
  onOutsideClick: void 0
};
var linkPreviewIdParts = ["trigger", "content"];
function createLinkPreview(props = {}) {
  const withDefaults = { ...defaults17, ...props };
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const hasSelection = withGet.writable(false);
  const isPointerDownOnContent = withGet.writable(false);
  const containSelection = writable(false);
  const activeTrigger = writable(null);
  const options = toWritableStores(omit(withDefaults, "ids"));
  const { openDelay, closeDelay, positioning, arrowSize, closeOnOutsideClick, forceVisible, portal, closeOnEscape, onOutsideClick } = options;
  const ids = toWritableStores({ ...generateIds(linkPreviewIdParts), ...withDefaults.ids });
  let timeout = null;
  let originalBodyUserSelect;
  const handleOpen = withGet.derived(openDelay, ($openDelay) => {
    return () => {
      if (timeout) {
        window.clearTimeout(timeout);
        timeout = null;
      }
      timeout = window.setTimeout(() => {
        open.set(true);
      }, $openDelay);
    };
  });
  const handleClose = withGet.derived([closeDelay, isPointerDownOnContent, hasSelection], ([$closeDelay, $isPointerDownOnContent, $hasSelection]) => {
    return () => {
      if (timeout) {
        window.clearTimeout(timeout);
        timeout = null;
      }
      if (!$isPointerDownOnContent && !$hasSelection) {
        timeout = window.setTimeout(() => {
          open.set(false);
        }, $closeDelay);
      }
    };
  });
  const trigger = makeElement(name9("trigger"), {
    stores: [open, ids.trigger, ids.content],
    returned: ([$open, $triggerId, $contentId]) => {
      return {
        role: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": $open,
        "data-state": $open ? "open" : "closed",
        "aria-controls": $contentId,
        id: $triggerId
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "pointerenter", (e) => {
        if (isTouch(e))
          return;
        handleOpen.get()();
      }), addMeltEventListener(node, "pointerleave", (e) => {
        if (isTouch(e))
          return;
        handleClose.get()();
      }), addMeltEventListener(node, "focus", (e) => {
        if (!isElement(e.currentTarget) || !isFocusVisible(e.currentTarget))
          return;
        handleOpen.get()();
      }), addMeltEventListener(node, "blur", () => handleClose.get()()));
      return {
        destroy: unsub
      };
    }
  });
  const isVisible = derivedVisible({ open, forceVisible, activeTrigger });
  const content = makeElement(name9("content"), {
    stores: [isVisible, portal, ids.content],
    returned: ([$isVisible, $portal, $contentId]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          "pointer-events": $isVisible ? void 0 : "none",
          opacity: $isVisible ? 1 : 0,
          userSelect: "text",
          WebkitUserSelect: "text"
        }),
        id: $contentId,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": portalAttr($portal)
      };
    },
    action: (node) => {
      let unsub = noop;
      const unsubTimers = () => {
        if (timeout) {
          window.clearTimeout(timeout);
        }
      };
      let unsubPopper = noop;
      const unsubDerived = effect([isVisible, activeTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $activeTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape]) => {
        unsubPopper();
        if (!$isVisible || !$activeTrigger)
          return;
        tick().then(() => {
          unsubPopper();
          unsubPopper = usePopper(node, {
            anchorElement: $activeTrigger,
            open,
            options: {
              floating: $positioning,
              modal: {
                closeOnInteractOutside: $closeOnOutsideClick,
                onClose: () => {
                  open.set(false);
                  $activeTrigger.focus();
                },
                shouldCloseOnInteractOutside: (e) => {
                  var _a;
                  (_a = onOutsideClick.get()) == null ? void 0 : _a(e);
                  if (e.defaultPrevented)
                    return false;
                  if (isHTMLElement($activeTrigger) && $activeTrigger.contains(e.target))
                    return false;
                  return true;
                },
                open: $isVisible
              },
              portal: getPortalDestination(node, $portal),
              focusTrap: null,
              escapeKeydown: $closeOnEscape ? void 0 : null
            }
          }).destroy;
        });
      });
      unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e) => {
        const currentTarget = e.currentTarget;
        const target = e.target;
        if (!isHTMLElement(currentTarget) || !isHTMLElement(target))
          return;
        if (currentTarget.contains(target)) {
          containSelection.set(true);
        }
        hasSelection.set(false);
        isPointerDownOnContent.set(true);
      }), addMeltEventListener(node, "pointerenter", (e) => {
        if (isTouch(e))
          return;
        handleOpen.get()();
      }), addMeltEventListener(node, "pointerleave", (e) => {
        if (isTouch(e))
          return;
        handleClose.get()();
      }), addMeltEventListener(node, "focusout", (e) => {
        e.preventDefault();
      }));
      return {
        destroy() {
          unsub();
          unsubPopper();
          unsubTimers();
          unsubDerived();
        }
      };
    }
  });
  const arrow2 = makeElement(name9("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  effect([containSelection], ([$containSelection]) => {
    if (!isBrowser || !$containSelection)
      return;
    const body = document.body;
    const contentElement = document.getElementById(ids.content.get());
    if (!contentElement)
      return;
    originalBodyUserSelect = body.style.userSelect || body.style.webkitUserSelect;
    const originalContentUserSelect = contentElement.style.userSelect || contentElement.style.webkitUserSelect;
    body.style.userSelect = "none";
    body.style.webkitUserSelect = "none";
    contentElement.style.userSelect = "text";
    contentElement.style.webkitUserSelect = "text";
    return () => {
      body.style.userSelect = originalBodyUserSelect;
      body.style.webkitUserSelect = originalBodyUserSelect;
      contentElement.style.userSelect = originalContentUserSelect;
      contentElement.style.webkitUserSelect = originalContentUserSelect;
    };
  });
  safeOnMount(() => {
    const triggerEl = document.getElementById(ids.trigger.get());
    if (!triggerEl)
      return;
    activeTrigger.set(triggerEl);
  });
  effect([open], ([$open]) => {
    if (!isBrowser || !$open) {
      hasSelection.set(false);
      return;
    }
    const handlePointerUp = () => {
      containSelection.set(false);
      isPointerDownOnContent.set(false);
      sleep(1).then(() => {
        var _a;
        const isSelection = ((_a = document.getSelection()) == null ? void 0 : _a.toString()) !== "";
        if (isSelection) {
          hasSelection.set(true);
        }
      });
    };
    document.addEventListener("pointerup", handlePointerUp);
    const contentElement = document.getElementById(ids.content.get());
    if (!contentElement)
      return;
    const tabbables = getTabbableNodes(contentElement);
    tabbables.forEach((tabbable) => tabbable.setAttribute("tabindex", "-1"));
    return () => {
      document.removeEventListener("pointerup", handlePointerUp);
      hasSelection.set(false);
      isPointerDownOnContent.set(false);
    };
  });
  return {
    ids,
    elements: {
      trigger,
      content,
      arrow: arrow2
    },
    states: {
      open
    },
    options
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/menubar/create.js
var MENUBAR_NAV_KEYS = [kbd.ARROW_LEFT, kbd.ARROW_RIGHT, kbd.HOME, kbd.END];
var { name: name10 } = createElHelpers("menubar");
var defaults18 = {
  loop: true,
  closeOnEscape: true,
  preventScroll: false
};
var menubarIdParts = ["menubar"];
function createMenubar(props) {
  const withDefaults = { ...defaults18, ...props };
  const options = toWritableStores(omit(withDefaults, "ids"));
  const { loop, closeOnEscape, preventScroll } = options;
  const activeMenu = withGet(writable(""));
  const nextFocusable = withGet(writable(null));
  const prevFocusable = withGet(writable(null));
  const lastFocusedMenuTrigger = withGet(writable(null));
  const closeTimer = withGet(writable(0));
  let scrollRemoved = false;
  const ids = toWritableStores({ ...generateIds(menubarIdParts), ...withDefaults.ids });
  const menubar = makeElement(name10(), {
    stores: [ids.menubar],
    returned([$menubarId]) {
      return {
        role: "menubar",
        "data-melt-menubar": "",
        "data-orientation": "horizontal",
        id: $menubarId
      };
    },
    action: (node) => {
      const menuTriggers = Array.from(node.querySelectorAll("[data-melt-menubar-trigger]"));
      if (!isHTMLElement(menuTriggers[0]))
        return {};
      menuTriggers[0].tabIndex = 0;
      return {
        destroy: noop
      };
    }
  });
  const menuDefaults = {
    positioning: {
      placement: "bottom-start"
    },
    arrowSize: 8,
    dir: "ltr",
    loop: false,
    closeOnEscape: true,
    closeOnOutsideClick: true,
    portal: void 0,
    forceVisible: false,
    defaultOpen: false,
    typeahead: true,
    closeFocus: void 0,
    disableFocusFirstItem: false,
    closeOnItemClick: true,
    onOutsideClick: void 0
  };
  const createMenu = (props2) => {
    const withDefaults2 = { ...menuDefaults, ...props2 };
    const rootOpen = withGet(writable(false));
    const rootActiveTrigger = withGet(writable(null));
    const options2 = toWritableStores(withDefaults2);
    const { positioning, portal, forceVisible, closeOnOutsideClick, onOutsideClick } = options2;
    const m = createMenuBuilder({
      rootOptions: { ...options2, preventScroll },
      rootOpen: withGet(rootOpen),
      rootActiveTrigger: withGet(rootActiveTrigger),
      nextFocusable: withGet(nextFocusable),
      prevFocusable: withGet(prevFocusable),
      selector: "menubar-menu",
      removeScroll: false
    });
    const isVisible = derivedVisible({
      open: rootOpen,
      forceVisible,
      activeTrigger: rootActiveTrigger
    });
    const menu = makeElement(name10("menu"), {
      stores: [isVisible, portal, m.ids.menu, m.ids.trigger, ids.menubar],
      returned: ([$isVisible, $portal, $menuId, $triggerId, $menubarId]) => {
        return {
          role: "menu",
          hidden: $isVisible ? void 0 : true,
          style: styleToString({
            display: $isVisible ? void 0 : "none"
          }),
          id: $menuId,
          "aria-labelledby": $triggerId,
          "data-state": $isVisible ? "open" : "closed",
          "data-melt-scope": $menubarId,
          "data-portal": portalAttr($portal),
          tabindex: -1
        };
      },
      action: (node) => {
        let unsubPopper = noop;
        const unsubDerived = effect([rootOpen, rootActiveTrigger, positioning, portal, closeOnOutsideClick], ([$rootOpen, $rootActiveTrigger, $positioning, $portal, $closeOnOutsideClick]) => {
          unsubPopper();
          if (!($rootOpen && $rootActiveTrigger))
            return;
          tick().then(() => {
            unsubPopper();
            unsubPopper = usePopper(node, {
              anchorElement: $rootActiveTrigger,
              open: rootOpen,
              options: {
                floating: $positioning,
                portal: getPortalDestination(node, $portal),
                modal: {
                  closeOnInteractOutside: $closeOnOutsideClick,
                  shouldCloseOnInteractOutside: (e) => {
                    var _a;
                    (_a = onOutsideClick.get()) == null ? void 0 : _a(e);
                    if (e.defaultPrevented)
                      return false;
                    const target = e.target;
                    const menubarEl = document.getElementById(ids.menubar.get());
                    if (!menubarEl || !isElement(target))
                      return true;
                    if (menubarEl.contains(target))
                      return false;
                    return true;
                  },
                  onClose: () => {
                    activeMenu.set("");
                  },
                  open: $rootOpen
                }
              }
            }).destroy;
          });
        });
        const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => {
          const target = e.target;
          const menuEl = e.currentTarget;
          if (!isHTMLElement(menuEl) || !isHTMLElement(target))
            return;
          if (MENUBAR_NAV_KEYS.includes(e.key)) {
            handleCrossMenuNavigation(e);
          }
          const isKeyDownInside = target.closest('[role="menu"]') === menuEl;
          if (!isKeyDownInside)
            return;
          if (FIRST_LAST_KEYS.includes(e.key)) {
            handleMenuNavigation(e);
          }
          if (e.key === kbd.TAB) {
            e.preventDefault();
            rootActiveTrigger.set(null);
            rootOpen.set(false);
            handleTabNavigation(e, nextFocusable, prevFocusable);
          }
          const isCharacterKey = e.key.length === 1;
          const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
          if (!isModifierKey && isCharacterKey) {
            m.helpers.handleTypeaheadSearch(e.key, getMenuItems(menuEl));
          }
        }));
        return {
          destroy() {
            unsubDerived();
            unsubEvents();
            unsubPopper();
          }
        };
      }
    });
    const trigger = makeElement(name10("trigger"), {
      stores: [rootOpen, m.ids.menu, m.ids.trigger],
      returned: ([$rootOpen, $menuId, $triggerId]) => {
        return {
          "aria-controls": $menuId,
          "aria-expanded": $rootOpen,
          "data-state": $rootOpen ? "open" : "closed",
          id: $triggerId,
          "aria-haspopup": "menu",
          "data-orientation": "horizontal",
          role: "menuitem"
        };
      },
      action: (node) => {
        applyAttrsIfDisabled(node);
        const menubarEl = document.getElementById(ids.menubar.get());
        if (!menubarEl)
          return {};
        const menubarTriggers = Array.from(menubarEl.querySelectorAll("[data-melt-menubar-trigger]"));
        if (!menubarTriggers.length)
          return {};
        const unsubEffect = effect([lastFocusedMenuTrigger], ([$lastFocusedMenuTrigger]) => {
          if (!$lastFocusedMenuTrigger && menubarTriggers[0] === node) {
            node.tabIndex = 0;
          } else if ($lastFocusedMenuTrigger === node) {
            node.tabIndex = 0;
          } else {
            node.tabIndex = -1;
          }
        });
        if (menubarTriggers[0] === node) {
          node.tabIndex = 0;
        } else {
          node.tabIndex = -1;
        }
        const unsub = executeCallbacks(addMeltEventListener(node, "click", (e) => {
          const $rootOpen = rootOpen.get();
          const triggerEl = e.currentTarget;
          if (!isHTMLElement(triggerEl))
            return;
          handleOpen(triggerEl);
          if (!$rootOpen)
            e.preventDefault();
        }), addMeltEventListener(node, "keydown", (e) => {
          const triggerEl = e.currentTarget;
          if (!isHTMLElement(triggerEl))
            return;
          if (SELECTION_KEYS.includes(e.key) || e.key === kbd.ARROW_DOWN) {
            e.preventDefault();
            handleOpen(triggerEl);
            const menuId = triggerEl.getAttribute("aria-controls");
            if (!menuId)
              return;
            const menu2 = document.getElementById(menuId);
            if (!menu2)
              return;
            const menuItems = getMenuItems(menu2);
            if (!menuItems.length)
              return;
            handleRovingFocus(menuItems[0]);
          }
        }), addMeltEventListener(node, "pointerenter", (e) => {
          const triggerEl = e.currentTarget;
          if (!isHTMLElement(triggerEl))
            return;
          const $activeMenu = activeMenu.get();
          const $rootOpen = rootOpen.get();
          if ($activeMenu && !$rootOpen) {
            rootOpen.set(true);
            activeMenu.set(m.ids.menu.get());
            rootActiveTrigger.set(triggerEl);
          }
        }));
        return {
          destroy() {
            unsub();
            unsubEffect();
          }
        };
      }
    });
    function handleOpen(triggerEl) {
      rootOpen.update((prev2) => {
        const isOpen = !prev2;
        if (isOpen) {
          nextFocusable.set(getNextFocusable(triggerEl));
          prevFocusable.set(getPreviousFocusable(triggerEl));
          rootActiveTrigger.set(triggerEl);
          activeMenu.set(m.ids.menu.get());
        } else {
          rootActiveTrigger.set(null);
        }
        return isOpen;
      });
    }
    effect([activeMenu], ([$activeMenu]) => {
      if (!isBrowser)
        return;
      if ($activeMenu === m.ids.menu.get()) {
        if (rootOpen.get())
          return;
        const triggerEl = document.getElementById(m.ids.trigger.get());
        if (!triggerEl)
          return;
        rootActiveTrigger.set(triggerEl);
        addHighlight(triggerEl);
        rootOpen.set(true);
        return;
      }
      if ($activeMenu !== m.ids.menu.get()) {
        if (!isBrowser)
          return;
        if (rootOpen.get()) {
          const triggerEl = document.getElementById(m.ids.trigger.get());
          if (!triggerEl)
            return;
          rootActiveTrigger.set(null);
          rootOpen.set(false);
          removeHighlight(triggerEl);
        }
        return;
      }
    });
    effect([rootOpen], ([$rootOpen]) => {
      if (!isBrowser)
        return;
      const triggerEl = document.getElementById(m.ids.trigger.get());
      if (!triggerEl)
        return;
      if (!$rootOpen && activeMenu.get() === m.ids.menu.get()) {
        rootActiveTrigger.set(null);
        activeMenu.set("");
        removeHighlight(triggerEl);
        return;
      }
      if ($rootOpen) {
        lastFocusedMenuTrigger.set(triggerEl);
        addHighlight(triggerEl);
      }
    });
    safeOnMount(() => {
      if (!isBrowser)
        return;
      const triggerEl = document.getElementById(m.ids.trigger.get());
      if (isHTMLElement(triggerEl) && rootOpen.get()) {
        rootActiveTrigger.set(triggerEl);
      }
    });
    return {
      ids: m.ids,
      elements: {
        ...m.elements,
        menu,
        trigger
      },
      builders: m.builders,
      states: m.states,
      options: options2
    };
  };
  function handleCrossMenuNavigation(e) {
    if (!isBrowser)
      return;
    e.preventDefault();
    const currentTarget = e.currentTarget;
    const target = e.target;
    if (!isHTMLElement(target) || !isHTMLElement(currentTarget))
      return;
    const targetIsSubTrigger = target.hasAttribute("data-melt-menubar-menu-subtrigger");
    const isKeyDownInsideSubMenu = target.closest('[role="menu"]') !== currentTarget;
    const prevMenuKey = kbd.ARROW_LEFT;
    const isPrevKey = e.key === prevMenuKey;
    const isNextKey = !isPrevKey;
    if (isNextKey && targetIsSubTrigger)
      return;
    if (isPrevKey && isKeyDownInsideSubMenu)
      return;
    const menubarEl = document.getElementById(ids.menubar.get());
    if (!isHTMLElement(menubarEl))
      return;
    const triggers = getMenuTriggers(menubarEl);
    const currTriggerId = currentTarget.getAttribute("aria-labelledby");
    const currIndex = triggers.findIndex((trigger) => trigger.id === currTriggerId);
    let nextIndex;
    switch (e.key) {
      case kbd.ARROW_RIGHT:
        nextIndex = currIndex < triggers.length - 1 ? currIndex + 1 : 0;
        break;
      case kbd.ARROW_LEFT:
        nextIndex = currIndex > 0 ? currIndex - 1 : triggers.length - 1;
        break;
      case kbd.HOME:
        nextIndex = 0;
        break;
      case kbd.END:
        nextIndex = triggers.length - 1;
        break;
      default:
        return;
    }
    const nextFocusedTrigger = triggers[nextIndex];
    const menuId = nextFocusedTrigger.getAttribute("aria-controls");
    menuId && activeMenu.set(menuId);
  }
  function getMenuTriggers(el) {
    const menuEl = el.closest('[role="menubar"]');
    if (!isHTMLElement(menuEl))
      return [];
    return Array.from(menuEl.querySelectorAll("[data-melt-menubar-trigger]")).filter((el2) => isHTMLElement(el2));
  }
  function handleMenubarNavigation(e) {
    e.preventDefault();
    const currentFocusedItem = document.activeElement;
    const currentTarget = e.currentTarget;
    if (!isHTMLElement(currentTarget) || !isHTMLElement(currentFocusedItem))
      return;
    const menuTriggers = getMenuTriggers(currentTarget);
    if (!menuTriggers.length)
      return;
    const candidateNodes = menuTriggers.filter((item) => {
      if (item.hasAttribute("data-disabled")) {
        return false;
      }
      if (item.getAttribute("disabled") === "true") {
        return false;
      }
      return true;
    });
    const currentIndex = candidateNodes.indexOf(currentFocusedItem);
    let nextIndex;
    const $loop = loop.get();
    switch (e.key) {
      case kbd.ARROW_RIGHT:
        nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : $loop ? 0 : currentIndex;
        break;
      case kbd.ARROW_LEFT:
        nextIndex = currentIndex > 0 ? currentIndex - 1 : $loop ? candidateNodes.length - 1 : 0;
        break;
      case kbd.HOME:
        nextIndex = 0;
        break;
      case kbd.END:
        nextIndex = candidateNodes.length - 1;
        break;
      default:
        return;
    }
    handleRovingFocus(candidateNodes[nextIndex]);
  }
  safeOnMount(() => {
    if (!isBrowser)
      return;
    const menubarEl = document.getElementById(ids.menubar.get());
    if (!menubarEl)
      return;
    const unsubEvents = executeCallbacks(addMeltEventListener(menubarEl, "keydown", (e) => {
      const target = e.target;
      const menuEl = e.currentTarget;
      if (!isHTMLElement(menuEl) || !isHTMLElement(target))
        return;
      const isTargetTrigger = target.hasAttribute("data-melt-menubar-trigger");
      if (!isTargetTrigger)
        return;
      if (MENUBAR_NAV_KEYS.includes(e.key)) {
        handleMenubarNavigation(e);
      }
    }), addEventListener(document, "keydown", (e) => {
      if (closeOnEscape.get() && e.key === kbd.ESCAPE) {
        window.clearTimeout(closeTimer.get());
        activeMenu.set("");
      }
    }));
    return () => {
      unsubEvents();
    };
  });
  const unsubs = [];
  effect([activeMenu, preventScroll], ([$activeMenu, $preventScroll]) => {
    if (!isBrowser || !$preventScroll)
      return;
    if (!$activeMenu) {
      unsubs.forEach((unsub) => unsub());
      scrollRemoved = false;
    } else if (!scrollRemoved) {
      unsubs.push(removeScroll());
      scrollRemoved = true;
    }
  });
  safeOnDestroy(() => {
    unsubs.forEach((unsub) => unsub());
  });
  return {
    ids,
    elements: {
      menubar
    },
    builders: {
      createMenu
    },
    options
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/pagination/helpers.js
function getPageItems({ page = 1, totalPages, siblingCount = 1 }) {
  const pageItems = [];
  const pagesToShow = /* @__PURE__ */ new Set([1, totalPages]);
  const firstItemWithSiblings = 3 + siblingCount;
  const lastItemWithSiblings = totalPages - 2 - siblingCount;
  if (firstItemWithSiblings > lastItemWithSiblings) {
    for (let p = 2; p <= totalPages - 1; p++) {
      pagesToShow.add(p);
    }
  } else if (page < firstItemWithSiblings) {
    for (let p = 2; p <= Math.min(firstItemWithSiblings, totalPages); p++) {
      pagesToShow.add(p);
    }
  } else if (page > lastItemWithSiblings) {
    for (let p = totalPages - 1; p >= Math.max(lastItemWithSiblings, 2); p--) {
      pagesToShow.add(p);
    }
  } else {
    for (let p = Math.max(page - siblingCount, 2); p <= Math.min(page + siblingCount, totalPages); p++) {
      pagesToShow.add(p);
    }
  }
  const addPage = (value) => {
    pageItems.push({ type: "page", value, key: `page-${value}` });
  };
  const addEllipsis = () => {
    pageItems.push({ type: "ellipsis", key: `ellipsis-${pageItems.length}` });
  };
  let lastNumber = 0;
  for (const page2 of Array.from(pagesToShow).sort((a, b) => a - b)) {
    if (page2 - lastNumber > 1) {
      addEllipsis();
    }
    addPage(page2);
    lastNumber = page2;
  }
  return pageItems;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/pagination/create.js
var defaults19 = {
  perPage: 1,
  siblingCount: 1,
  defaultPage: 1
};
var { name: name11, selector: selector3 } = createElHelpers("pagination");
function createPagination(props) {
  const withDefaults = { ...defaults19, ...props };
  const pageWritable = withDefaults.page ?? writable(withDefaults.defaultPage);
  const page = overridable(pageWritable, withDefaults == null ? void 0 : withDefaults.onPageChange);
  const options = toWritableStores(omit(withDefaults, "page", "onPageChange", "defaultPage"));
  const { perPage, siblingCount, count } = options;
  const totalPages = withGet.derived([count, perPage], ([$count, $perPage]) => {
    return Math.ceil($count / $perPage);
  });
  const range = derived([page, perPage, count], ([$page, $perPage, $count]) => {
    const start = ($page - 1) * $perPage;
    const end = Math.min(start + $perPage, $count);
    return { start, end };
  });
  const root5 = makeElement(name11(), {
    returned: () => ({
      "data-scope": "pagination"
    })
  });
  const pages = derived([page, totalPages, siblingCount], ([$page, $totalPages, $siblingCount]) => {
    return getPageItems({ page: $page, totalPages: $totalPages, siblingCount: $siblingCount });
  });
  const keydown = (e) => {
    const thisEl = e.target;
    if (!isHTMLElement(thisEl))
      return;
    const rootEl = thisEl.closest('[data-scope="pagination"]');
    if (!isHTMLElement(rootEl))
      return;
    const triggers = Array.from(rootEl.querySelectorAll(selector3("page"))).filter((el) => isHTMLElement(el));
    const prevButton2 = rootEl.querySelector(selector3("prev"));
    const nextButton2 = rootEl.querySelector(selector3("next"));
    if (isHTMLElement(prevButton2)) {
      triggers.unshift(prevButton2);
    }
    if (isHTMLElement(nextButton2)) {
      triggers.push(nextButton2);
    }
    const index = triggers.indexOf(thisEl);
    if (e.key === kbd.ARROW_LEFT && index !== 0) {
      e.preventDefault();
      triggers[index - 1].focus();
    } else if (e.key === kbd.ARROW_RIGHT && index !== triggers.length - 1) {
      e.preventDefault();
      triggers[index + 1].focus();
    } else if (e.key === kbd.HOME) {
      e.preventDefault();
      triggers[0].focus();
    } else if (e.key === kbd.END) {
      e.preventDefault();
      triggers[triggers.length - 1].focus();
    }
  };
  const pageTrigger = makeElement(name11("page"), {
    stores: page,
    returned: ($page) => {
      return (pageItem) => {
        return {
          "aria-label": `Page ${pageItem.value}`,
          "data-value": pageItem.value,
          "data-selected": pageItem.value === $page ? "" : void 0
        };
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        const value = node.dataset.value;
        if (!value || Number.isNaN(+value))
          return;
        page.set(Number(value));
      }), addMeltEventListener(node, "keydown", keydown));
      return {
        destroy: unsub
      };
    }
  });
  const prevButton = makeElement(name11("prev"), {
    stores: page,
    returned: ($page) => {
      return {
        "aria-label": "Previous",
        disabled: $page <= 1
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        page.update((p) => Math.max(p - 1, 1));
      }), addMeltEventListener(node, "keydown", keydown));
      return {
        destroy: unsub
      };
    }
  });
  const nextButton = makeElement(name11("next"), {
    stores: [page, totalPages],
    returned: ([$page, $totalPages]) => {
      return {
        "aria-label": "Next",
        disabled: $page >= $totalPages
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        const $totalPages = totalPages.get();
        page.update((p) => Math.min(p + 1, $totalPages));
      }), addMeltEventListener(node, "keydown", keydown));
      return {
        destroy: unsub
      };
    }
  });
  return {
    elements: {
      root: root5,
      pageTrigger,
      prevButton,
      nextButton
    },
    states: {
      range: readonly(range),
      page,
      pages: readonly(pages),
      totalPages: readonly(totalPages)
    },
    options
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/pin-input/create.js
var prefix2 = "pin-input";
var { name: name12, selector: selector4 } = createElHelpers(prefix2);
var getInputs = (node) => {
  const rootEl = node.closest(selector4());
  if (!isHTMLElement(rootEl)) {
    return { inputs: null, el: node, elIndex: -1 };
  }
  const inputs = Array.from(rootEl.querySelectorAll(selector4("input"))).filter((input) => isHTMLInputElement(input));
  return {
    elIndex: inputs.indexOf(node),
    inputs
  };
};
var defaults20 = {
  placeholder: "",
  disabled: false,
  type: "text",
  name: void 0,
  defaultValue: []
};
var pinInputIdParts = ["root"];
function createPinInput(props) {
  const withDefaults = { ...defaults20, ...props };
  const options = toWritableStores(omit(withDefaults, "value", "ids"));
  const { placeholder, disabled, type, name: nameStore } = options;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  const valueStr = derived(value, (v) => v.join(""));
  const ids = toWritableStores({ ...generateIds(pinInputIdParts), ...withDefaults.ids });
  const root5 = makeElement(name12(), {
    stores: [value, ids.root],
    returned: ([$value, $rootId]) => {
      return {
        id: $rootId,
        "data-complete": $value.length && $value.every((v) => v.length > 0) ? "" : void 0
      };
    }
  });
  let index = 0;
  const getTotalItems = () => {
    if (!isBrowser)
      return Infinity;
    const rootEl = document.getElementById(ids.root.get());
    if (!rootEl)
      return Infinity;
    const inputs = Array.from(rootEl.querySelectorAll(selector4("input")));
    return inputs.length;
  };
  const input = makeElement(name12("input"), {
    stores: [value, placeholder, disabled, type],
    returned: ([$value, $placeholder, $disabled, $type]) => {
      return () => {
        const totalItems = getTotalItems();
        const currIndex = index % totalItems;
        index = (index + 1) % totalItems;
        const currValue = $value[currIndex] ?? "";
        return {
          "data-complete": $value.length && $value.every((v) => v.length > 0) ? "" : void 0,
          placeholder: $placeholder,
          disabled: disabledAttr($disabled),
          type: $type,
          value: currValue
        };
      };
    },
    action: (node) => {
      const { elIndex } = getInputs(node);
      value.update((v) => {
        v[elIndex] = node.value;
        return v;
      });
      const unsub = executeCallbacks(addMeltEventListener(node, "keydown", (e) => {
        const { inputs, elIndex: elIndex2 } = getInputs(node);
        if (!inputs)
          return;
        if (e.key === "Backspace") {
          e.preventDefault();
          if (node.value) {
            node.value = "";
            tick().then(() => node.placeholder = "");
            value.set(inputs.map((input2) => input2.value.slice(-1) ?? void 0));
          } else {
            const prevEl = prev(inputs, elIndex2, false);
            prevEl.focus();
            prevEl.value = "";
            tick().then(() => prevEl.placeholder = "");
            value.set(inputs.map((input2) => input2.value.slice(-1) ?? void 0));
          }
        }
        if (e.key === "Delete") {
          e.preventDefault();
          node.value = "";
          tick().then(() => node.placeholder = "");
          value.set(inputs.map((input2) => input2.value.slice(-1) ?? void 0));
        }
        if (e.key === "ArrowLeft") {
          e.preventDefault();
          const prevEl = prev(inputs, elIndex2, false);
          prevEl.focus();
        }
        if (e.key === "ArrowRight") {
          e.preventDefault();
          const nextEl = next(inputs, elIndex2, false);
          nextEl.focus();
        }
        if (e.key === "Home") {
          e.preventDefault();
          inputs[0].focus();
        }
        if (e.key === "End") {
          e.preventDefault();
          last(inputs).focus();
        }
      }), addMeltEventListener(node, "input", (e) => {
        const { inputs, elIndex: elIndex2 } = getInputs(node);
        if (!inputs)
          return;
        const getInputted = (el) => {
          const $value = value.get();
          const prevElValue = $value[elIndex2];
          const selectionStart = el.selectionStart ?? 1;
          if (!prevElValue)
            return el.value;
          return selectionStart > 1 ? el.value.slice(1) : el.value.slice(0, Math.max(el.value.length - 2, 1));
        };
        const inputted = getInputted(node);
        const inputEvent = e;
        if (inputEvent.inputType === "insertFromPaste") {
          return;
        }
        node.value = inputted.slice(-1);
        if (node.value.length !== 0) {
          const nextEl = next(inputs, elIndex2, false);
          nextEl.focus();
        }
        value.set(inputs.map((input2) => input2.value.slice(-1) ?? void 0));
      }), addMeltEventListener(node, "paste", (e) => {
        var _a;
        e.preventDefault();
        const { inputs, elIndex: elIndex2 } = getInputs(node);
        if (!inputs)
          return;
        const inputEvent = e;
        const clipboardData = inputEvent.clipboardData;
        if (!clipboardData)
          return;
        const pasted = clipboardData.getData("text");
        const initialIndex = pasted.length >= inputs.length ? 0 : elIndex2;
        const lastIndex = Math.min(initialIndex + pasted.length, inputs.length);
        for (let i = initialIndex; i < lastIndex; i++) {
          const input2 = inputs[i];
          input2.value = pasted[i - initialIndex];
          input2.focus();
        }
        (_a = inputs[lastIndex]) == null ? void 0 : _a.focus();
        value.set(inputs.map((input2) => input2.value.slice(-1) ?? void 0));
      }), addMeltEventListener(node, "change", () => {
        const { inputs } = getInputs(node);
        if (!inputs)
          return;
        value.set(inputs.map((input2) => input2.value.slice(-1) ?? void 0));
      }), addMeltEventListener(node, "focus", () => {
        node.setSelectionRange(1, 1);
        node.placeholder = "";
        tick().then(() => {
          node.placeholder = "";
        });
      }), addMeltEventListener(node, "blur", () => {
        node.placeholder = placeholder.get();
      }));
      return {
        destroy() {
          unsub();
        }
      };
    }
  });
  const hiddenInput = createHiddenInput({
    value: valueStr,
    disabled,
    name: nameStore,
    prefix: prefix2
  });
  const clear = () => {
    value.update((v) => {
      v.forEach((_, i) => v[i] = "");
      return v;
    });
  };
  return {
    ids,
    elements: {
      root: root5,
      input,
      hiddenInput
    },
    states: {
      value,
      valueStr: readonly(valueStr)
    },
    helpers: {
      clear
    },
    options
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/popover/create.js
var defaults21 = {
  positioning: {
    placement: "bottom"
  },
  arrowSize: 8,
  defaultOpen: false,
  disableFocusTrap: false,
  closeOnEscape: true,
  preventScroll: false,
  onOpenChange: void 0,
  closeOnOutsideClick: true,
  portal: void 0,
  forceVisible: false,
  openFocus: void 0,
  closeFocus: void 0,
  onOutsideClick: void 0
};
var { name: name13 } = createElHelpers("popover");
var popoverIdParts = ["trigger", "content"];
function createPopover(args) {
  const withDefaults = { ...defaults21, ...args };
  const options = toWritableStores(omit(withDefaults, "open", "ids"));
  const { positioning, arrowSize, disableFocusTrap, preventScroll, closeOnEscape, closeOnOutsideClick, portal, forceVisible, openFocus, closeFocus, onOutsideClick } = options;
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const activeTrigger = withGet.writable(null);
  const ids = toWritableStores({ ...generateIds(popoverIdParts), ...withDefaults.ids });
  safeOnMount(() => {
    activeTrigger.set(document.getElementById(ids.trigger.get()));
  });
  function handleClose() {
    open.set(false);
    const triggerEl = document.getElementById(ids.trigger.get());
    handleFocus({ prop: closeFocus.get(), defaultEl: triggerEl });
  }
  const isVisible = derivedVisible({ open, activeTrigger, forceVisible });
  const content = makeElement(name13("content"), {
    stores: [isVisible, portal, ids.content],
    returned: ([$isVisible, $portal, $contentId]) => {
      return {
        hidden: $isVisible && isBrowser ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        id: $contentId,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": portalAttr($portal)
      };
    },
    action: (node) => {
      let unsubPopper = noop;
      const unsubDerived = effect([
        isVisible,
        activeTrigger,
        positioning,
        disableFocusTrap,
        closeOnEscape,
        closeOnOutsideClick,
        portal
      ], ([$isVisible, $activeTrigger, $positioning, $disableFocusTrap, $closeOnEscape, $closeOnOutsideClick, $portal]) => {
        unsubPopper();
        if (!$isVisible || !$activeTrigger)
          return;
        tick().then(() => {
          unsubPopper();
          unsubPopper = usePopper(node, {
            anchorElement: $activeTrigger,
            open,
            options: {
              floating: $positioning,
              focusTrap: $disableFocusTrap ? null : {
                returnFocusOnDeactivate: false,
                clickOutsideDeactivates: $closeOnOutsideClick,
                allowOutsideClick: true,
                escapeDeactivates: $closeOnEscape
              },
              modal: {
                shouldCloseOnInteractOutside,
                onClose: handleClose,
                open: $isVisible,
                closeOnInteractOutside: $closeOnOutsideClick
              },
              escapeKeydown: $closeOnEscape ? {
                handler: () => {
                  handleClose();
                }
              } : null,
              portal: getPortalDestination(node, $portal)
            }
          }).destroy;
        });
      });
      return {
        destroy() {
          unsubDerived();
          unsubPopper();
        }
      };
    }
  });
  function toggleOpen(triggerEl) {
    open.update((prev2) => {
      return !prev2;
    });
    if (triggerEl && triggerEl !== activeTrigger.get()) {
      activeTrigger.set(triggerEl);
    }
  }
  function shouldCloseOnInteractOutside(e) {
    var _a;
    (_a = onOutsideClick.get()) == null ? void 0 : _a(e);
    if (e.defaultPrevented)
      return false;
    const target = e.target;
    const triggerEl = document.getElementById(ids.trigger.get());
    if (triggerEl && isElement(target)) {
      if (target === triggerEl || triggerEl.contains(target))
        return false;
    }
    return true;
  }
  const trigger = makeElement(name13("trigger"), {
    stores: [isVisible, ids.content, ids.trigger],
    returned: ([$isVisible, $contentId, $triggerId]) => {
      return {
        role: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": $isVisible ? "true" : "false",
        "data-state": stateAttr2($isVisible),
        "aria-controls": $contentId,
        id: $triggerId
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        toggleOpen(node);
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)
          return;
        e.preventDefault();
        toggleOpen(node);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const overlay = makeElement(name13("overlay"), {
    stores: [isVisible],
    returned: ([$isVisible]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        "aria-hidden": "true",
        "data-state": stateAttr2($isVisible)
      };
    },
    action: (node) => {
      let unsubEscapeKeydown = noop;
      let unsubDerived = noop;
      let unsubPortal = noop;
      if (closeOnEscape.get()) {
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            handleClose();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          unsubEscapeKeydown = escapeKeydown.destroy;
        }
      }
      unsubDerived = effect([portal], ([$portal]) => {
        unsubPortal();
        if ($portal === null)
          return;
        const portalDestination = getPortalDestination(node, $portal);
        if (portalDestination === null)
          return;
        unsubPortal = usePortal(node, portalDestination).destroy;
      });
      return {
        destroy() {
          unsubEscapeKeydown();
          unsubDerived();
          unsubPortal();
        }
      };
    }
  });
  const arrow2 = makeElement(name13("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  const close = makeElement(name13("close"), {
    returned: () => ({
      type: "button"
    }),
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e) => {
        if (e.defaultPrevented)
          return;
        handleClose();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.defaultPrevented)
          return;
        if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)
          return;
        e.preventDefault();
        toggleOpen();
      }));
      return {
        destroy: unsub
      };
    }
  });
  effect([open, activeTrigger, preventScroll], ([$open, $activeTrigger, $preventScroll]) => {
    if (!isBrowser)
      return;
    const unsubs = [];
    if ($open) {
      if (!$activeTrigger) {
        tick().then(() => {
          const triggerEl2 = document.getElementById(ids.trigger.get());
          if (!isHTMLElement(triggerEl2))
            return;
          activeTrigger.set(triggerEl2);
        });
      }
      if ($preventScroll) {
        unsubs.push(removeScroll());
      }
      const triggerEl = $activeTrigger ?? document.getElementById(ids.trigger.get());
      handleFocus({ prop: openFocus.get(), defaultEl: triggerEl });
    }
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  return {
    ids,
    elements: {
      trigger,
      content,
      arrow: arrow2,
      close,
      overlay
    },
    states: {
      open
    },
    options
  };
}
function stateAttr2(open) {
  return open ? "open" : "closed";
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/progress/create.js
var defaults22 = {
  defaultValue: 0,
  max: 100
};
var { name: name14 } = createElHelpers("progress");
var createProgress = (props) => {
  const withDefaults = { ...defaults22, ...props };
  const options = toWritableStores(omit(withDefaults, "value"));
  const { max } = options;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  const root5 = makeElement(name14(), {
    stores: [value, max],
    returned: ([$value, $max]) => {
      return {
        value: $value,
        max: $max,
        role: "meter",
        "aria-valuemin": 0,
        "aria-valuemax": $max,
        "aria-valuenow": $value,
        "data-value": $value,
        "data-state": $value === null ? "indeterminate" : $value === $max ? "complete" : "loading",
        "data-max": $max
      };
    }
  });
  return {
    elements: {
      root: root5
    },
    states: {
      value
    },
    options
  };
};

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/radio-group/create.js
var defaults23 = {
  orientation: "vertical",
  loop: true,
  disabled: false,
  required: false,
  defaultValue: void 0
};
var prefix3 = "radio-group";
var { name: name15, selector: selector5 } = createElHelpers(prefix3);
function createRadioGroup(props) {
  const withDefaults = { ...defaults23, ...props };
  const options = toWritableStores(omit(withDefaults, "value"));
  const { disabled, required, loop, orientation } = options;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  const focusedHistory = {
    prev: null,
    curr: null
  };
  safeOnMount(() => {
    return addEventListener(document, "focus", (e) => {
      const focusedItem = e.target;
      if (!isHTMLElement(focusedItem))
        return;
      focusedHistory.prev = focusedHistory.curr;
      focusedHistory.curr = focusedItem;
    });
  });
  let hasActiveTabIndex = false;
  effect(value, ($value) => {
    if ($value === void 0) {
      hasActiveTabIndex = false;
    } else {
      hasActiveTabIndex = true;
    }
  });
  const selectItem = (item2) => {
    const disabled2 = item2.dataset.disabled === "true";
    const itemValue = item2.dataset.value;
    if (disabled2 || itemValue === void 0)
      return;
    value.set(itemValue);
  };
  const root5 = makeElement(name15(), {
    stores: [required, orientation],
    returned: ([$required, $orientation]) => {
      return {
        role: "radiogroup",
        "aria-required": $required,
        "data-orientation": $orientation
      };
    }
  });
  const item = makeElement(name15("item"), {
    stores: [value, orientation, disabled],
    returned: ([$value, $orientation, $disabled]) => {
      return (props2) => {
        const itemValue = typeof props2 === "string" ? props2 : props2.value;
        const argDisabled = typeof props2 === "string" ? false : !!props2.disabled;
        const disabled2 = $disabled || argDisabled;
        const checked = $value === itemValue;
        const tabindex = !hasActiveTabIndex ? 0 : checked ? 0 : -1;
        hasActiveTabIndex = true;
        return {
          disabled: disabled2,
          "data-value": itemValue,
          "data-orientation": $orientation,
          "data-disabled": disabledAttr(disabled2),
          "data-state": checked ? "checked" : "unchecked",
          "aria-checked": checked,
          type: "button",
          role: "radio",
          tabindex
        };
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        selectItem(node);
      }), addMeltEventListener(node, "keydown", (e) => {
        const el = e.currentTarget;
        if (!isHTMLElement(el))
          return;
        const root6 = el.closest(selector5());
        if (!isHTMLElement(root6))
          return;
        const items = Array.from(root6.querySelectorAll(selector5("item"))).filter((el2) => isHTMLElement(el2) && !el2.hasAttribute("data-disabled"));
        const currentIndex = items.indexOf(el);
        const dir = getElemDirection(root6);
        const { nextKey, prevKey } = getDirectionalKeys(dir, orientation.get());
        const $loop = loop.get();
        let itemToFocus = null;
        if (e.key === nextKey) {
          e.preventDefault();
          const nextIndex = currentIndex + 1;
          if (nextIndex >= items.length && $loop) {
            itemToFocus = items[0];
          } else {
            itemToFocus = items[nextIndex];
          }
        } else if (e.key === prevKey) {
          e.preventDefault();
          const prevIndex = currentIndex - 1;
          if (prevIndex < 0 && $loop) {
            itemToFocus = items[items.length - 1];
          } else {
            itemToFocus = items[prevIndex];
          }
        } else if (e.key === kbd.HOME) {
          e.preventDefault();
          itemToFocus = items[0];
        } else if (e.key === kbd.END) {
          e.preventDefault();
          itemToFocus = items[items.length - 1];
        }
        if (itemToFocus) {
          itemToFocus.focus();
          selectItem(itemToFocus);
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const hiddenInput = createHiddenInput({
    value,
    disabled,
    required
  });
  const isChecked = derived(value, ($value) => {
    return (itemValue) => {
      return $value === itemValue;
    };
  });
  return {
    elements: {
      root: root5,
      item,
      hiddenInput
    },
    states: {
      value
    },
    helpers: {
      isChecked
    },
    options
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/range-calendar/create.js
var defaults24 = {
  isDateDisabled: void 0,
  isDateUnavailable: void 0,
  value: void 0,
  defaultValue: {
    start: void 0,
    end: void 0
  },
  preventDeselect: false,
  numberOfMonths: 1,
  pagedNavigation: false,
  weekStartsOn: 0,
  fixedWeeks: false,
  calendarLabel: "Event Date",
  locale: "en",
  minValue: void 0,
  maxValue: void 0,
  disabled: false,
  readonly: false,
  weekdayFormat: "narrow"
};
var { name: name16 } = createElHelpers("calendar");
var rangeCalendarIdParts = ["calendar", "accessibleHeading"];
function createRangeCalendar(props) {
  var _a, _b, _c;
  const withDefaults = { ...defaults24, ...props };
  const options = toWritableStores({
    ...omit(withDefaults, "value", "placeholder")
  });
  const { preventDeselect, numberOfMonths, pagedNavigation, weekStartsOn, fixedWeeks, calendarLabel, locale, minValue, maxValue, disabled, readonly: readonly2, weekdayFormat } = options;
  const ids = toWritableStores({ ...generateIds(rangeCalendarIdParts), ...withDefaults.ids });
  const defaultDate = getDefaultDate({
    defaultValue: (_a = withDefaults.defaultValue) == null ? void 0 : _a.start,
    defaultPlaceholder: withDefaults.defaultPlaceholder
  });
  const formatter = createFormatter(locale.get());
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults.onValueChange);
  if (!value.get()) {
    value.set(withDefaults.defaultValue);
  }
  const startValue = withGet(writable(value.get().start ?? ((_b = withDefaults.defaultValue) == null ? void 0 : _b.start)));
  const endValue = withGet(writable(value.get().end ?? ((_c = withDefaults.defaultValue) == null ? void 0 : _c.end)));
  const placeholderWritable = withDefaults.placeholder ?? writable(withDefaults.defaultPlaceholder ?? defaultDate);
  const placeholder = dateStore(overridable(placeholderWritable, withDefaults.onPlaceholderChange), withDefaults.defaultPlaceholder ?? defaultDate);
  const focusedValue = withGet(writable(null));
  const lastPressedDateValue = withGet(writable(null));
  const months = withGet(writable(createMonths({
    dateObj: placeholder.get(),
    weekStartsOn: withDefaults.weekStartsOn,
    locale: withDefaults.locale,
    fixedWeeks: withDefaults.fixedWeeks,
    numberOfMonths: withDefaults.numberOfMonths
  })));
  const visibleMonths = withGet(derived([months], ([$months]) => {
    return $months.map((month) => {
      return month.value;
    });
  }));
  const isOutsideVisibleMonths = withGet(derived([visibleMonths], ([$visibleMonths]) => {
    return (date) => {
      return !$visibleMonths.some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(date, month));
    };
  }));
  const isDateDisabled = withGet(derived([options.isDateDisabled, minValue, maxValue], ([$isDateDisabled, $minValue, $maxValue]) => {
    return (date) => {
      if ($isDateDisabled == null ? void 0 : $isDateDisabled(date))
        return true;
      if ($minValue && isBefore(date, $minValue))
        return true;
      if ($maxValue && isAfter(date, $maxValue))
        return true;
      return false;
    };
  }));
  const isDateUnavailable = withGet(derived([options.isDateUnavailable], ([$isDateUnavailable]) => {
    return (date) => {
      if ($isDateUnavailable == null ? void 0 : $isDateUnavailable(date))
        return true;
      return false;
    };
  }));
  const isStartInvalid = derived([startValue, isDateUnavailable, isDateDisabled], ([$startValue, $isDateUnavailable, $isDateDisabled]) => {
    if (!$startValue)
      return false;
    return $isDateUnavailable($startValue) || $isDateDisabled($startValue);
  });
  const isEndInvalid = derived([endValue, isDateUnavailable, isDateDisabled], ([$endValue, $isDateUnavailable, $isDateDisabled]) => {
    if (!$endValue)
      return false;
    return $isDateUnavailable($endValue) || $isDateDisabled($endValue);
  });
  const isInvalid = derived([startValue, endValue, isEndInvalid, isStartInvalid], ([$startValue, $endValue, $isEndInvalid, $isStartInvalid]) => {
    if ($isStartInvalid || $isEndInvalid) {
      return true;
    }
    if ($endValue && $startValue && isBefore($endValue, $startValue)) {
      return true;
    }
    return false;
  });
  const isNextButtonDisabled = withGet.derived([months, maxValue, disabled], ([$months, $maxValue, $disabled]) => {
    if (!$maxValue || !$months.length)
      return false;
    if ($disabled)
      return true;
    const lastMonthInView = $months[$months.length - 1].value;
    const firstMonthOfNextPage = lastMonthInView.add({ months: 1 }).set({ day: 1 });
    return isAfter(firstMonthOfNextPage, $maxValue);
  });
  const isPrevButtonDisabled = withGet.derived([months, minValue, disabled], ([$months, $minValue, $disabled]) => {
    if (!$minValue || !$months.length)
      return false;
    if ($disabled)
      return true;
    const firstMonthInView = $months[0].value;
    const lastMonthOfPrevPage = firstMonthInView.subtract({ months: 1 }).set({ day: 35 });
    return isBefore(lastMonthOfPrevPage, $minValue);
  });
  let announcer = getAnnouncer();
  const headingValue = withGet.derived([months, locale], ([$months, $locale]) => {
    if (!$months.length)
      return "";
    if ($locale !== formatter.getLocale()) {
      formatter.setLocale($locale);
    }
    if ($months.length === 1) {
      const month = toDate($months[0].value);
      return `${formatter.fullMonthAndYear(month)}`;
    }
    const startMonth = toDate($months[0].value);
    const endMonth = toDate($months[$months.length - 1].value);
    const startMonthName = formatter.fullMonth(startMonth);
    const endMonthName = formatter.fullMonth(endMonth);
    const startMonthYear = formatter.fullYear(startMonth);
    const endMonthYear = formatter.fullYear(endMonth);
    const content = startMonthYear === endMonthYear ? `${startMonthName} - ${endMonthName} ${endMonthYear}` : `${startMonthName} ${startMonthYear} - ${endMonthName} ${endMonthYear}`;
    return content;
  });
  const fullCalendarLabel = withGet.derived([headingValue, calendarLabel], ([$headingValue, $calendarLabel]) => {
    return `${$calendarLabel}, ${$headingValue}`;
  });
  const calendar = makeElement(name16(), {
    stores: [fullCalendarLabel, isInvalid, ids.calendar, disabled, readonly2],
    returned: ([$fullCalendarLabel, $isInvalid, $calendarId, $disabled, $readonly]) => {
      return {
        id: $calendarId,
        role: "application",
        "aria-label": $fullCalendarLabel,
        "data-invalid": $isInvalid ? "" : void 0,
        "data-disabled": $disabled ? "" : void 0,
        "data-readonly": $readonly ? "" : void 0
      };
    },
    action: (node) => {
      createAccessibleHeading(node, fullCalendarLabel.get());
      announcer = getAnnouncer();
      const unsubKb = addMeltEventListener(node, "keydown", handleCalendarKeydown);
      return {
        destroy() {
          unsubKb();
        }
      };
    }
  });
  const heading = makeElement(name16("heading"), {
    stores: [disabled],
    returned: ([$disabled]) => {
      return {
        "aria-hidden": true,
        "data-disabled": $disabled ? "" : void 0
      };
    }
  });
  const grid = makeElement(name16("grid"), {
    stores: [readonly2, disabled],
    returned: ([$readonly, $disabled]) => ({
      tabindex: -1,
      role: "grid",
      "aria-readonly": $readonly ? "true" : void 0,
      "aria-disabled": $disabled ? "true" : void 0,
      "data-readonly": $readonly ? "" : void 0,
      "data-disabled": $disabled ? "" : void 0
    })
  });
  const prevButton = makeElement(name16("prevButton"), {
    stores: [isPrevButtonDisabled],
    returned: ([$isPrevButtonDisabled]) => {
      const disabled2 = $isPrevButtonDisabled;
      return {
        role: "button",
        type: "button",
        "aria-label": "Previous",
        "aria-disabled": disabled2 ? "true" : void 0,
        disabled: disabled2 ? true : void 0,
        "data-disabled": disabled2 ? "" : void 0
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        prevPage();
      }));
      return {
        destroy: unsub
      };
    }
  });
  const nextButton = makeElement(name16("nextButton"), {
    stores: [isNextButtonDisabled],
    returned: ([$isNextButtonDisabled]) => {
      const disabled2 = $isNextButtonDisabled;
      return {
        role: "button",
        type: "button",
        "aria-label": "Next",
        "aria-disabled": disabled2 ? "true" : void 0,
        disabled: disabled2 ? true : void 0,
        "data-disabled": disabled2 ? "" : void 0
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        nextPage();
      }));
      return {
        destroy: unsub
      };
    }
  });
  const isSelectionStart = derived([startValue], ([$startValue]) => {
    return (date) => {
      if (!$startValue)
        return false;
      return $14e0f24ef4ac5c92$export$ea39ec197993aef0($startValue, date);
    };
  });
  const isSelectionEnd = derived([endValue], ([$endValue]) => {
    return (date) => {
      if (!$endValue)
        return false;
      return $14e0f24ef4ac5c92$export$ea39ec197993aef0($endValue, date);
    };
  });
  const isSelected = derived([startValue, endValue], ([$startValue, $endValue]) => {
    return (date) => {
      if ($startValue && $14e0f24ef4ac5c92$export$ea39ec197993aef0($startValue, date))
        return true;
      if ($endValue && $14e0f24ef4ac5c92$export$ea39ec197993aef0($endValue, date))
        return true;
      if ($endValue && $startValue) {
        return isBetweenInclusive(date, $startValue, $endValue);
      }
      return false;
    };
  });
  const highlightedRange = withGet.derived([startValue, endValue, focusedValue, isDateDisabled, isDateUnavailable], ([$startValue, $endValue, $focusedValue, $isDateDisabled, $isDateUnavailable]) => {
    if ($startValue && $endValue)
      return null;
    if (!$startValue || !$focusedValue)
      return null;
    const isStartBeforeFocused = isBefore($startValue, $focusedValue);
    const start = isStartBeforeFocused ? $startValue : $focusedValue;
    const end = isStartBeforeFocused ? $focusedValue : $startValue;
    if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(start.add({ days: 1 }), end)) {
      return {
        start,
        end
      };
    }
    const isValid = areAllDaysBetweenValid(start, end, $isDateUnavailable, $isDateDisabled);
    if (isValid) {
      return {
        start,
        end
      };
    }
    return null;
  });
  const cell = makeElement(name16("cell"), {
    stores: [
      isSelected,
      isSelectionEnd,
      isSelectionStart,
      highlightedRange,
      isDateDisabled,
      isDateUnavailable,
      placeholder,
      isOutsideVisibleMonths
    ],
    returned: ([$isSelected, $isSelectionEnd, $isSelectionStart, $highlightedRange, $isDateDisabled, $isDateUnavailable, $placeholder, $isOutsideVisibleMonths]) => {
      return (cellValue, monthValue) => {
        const cellDate = toDate(cellValue);
        const isDisabled = $isDateDisabled(cellValue);
        const isUnavailable = $isDateUnavailable(cellValue);
        const isDateToday = $14e0f24ef4ac5c92$export$629b0a497aa65267(cellValue, $14e0f24ef4ac5c92$export$aa8b41735afcabd2());
        const isOutsideMonth = !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(cellValue, monthValue);
        const isFocusedDate = $14e0f24ef4ac5c92$export$ea39ec197993aef0(cellValue, $placeholder);
        const isOutsideVisibleMonths2 = $isOutsideVisibleMonths(cellValue);
        const isSelectedDate = $isSelected(cellValue);
        const isSelectionStart2 = $isSelectionStart(cellValue);
        const isSelectionEnd2 = $isSelectionEnd(cellValue);
        const isHighlighted = $highlightedRange ? isBetweenInclusive(cellValue, $highlightedRange.start, $highlightedRange.end) : false;
        const labelText = formatter.custom(cellDate, {
          weekday: "long",
          month: "long",
          day: "numeric",
          year: "numeric"
        });
        return {
          role: "button",
          "aria-label": labelText,
          "aria-selected": isSelectedDate ? true : void 0,
          "aria-disabled": isOutsideMonth || isDisabled || isUnavailable ? true : void 0,
          "data-selected": isSelectedDate ? true : void 0,
          "data-selection-start": isSelectionStart2 ? true : void 0,
          "data-selection-end": isSelectionEnd2 ? true : void 0,
          "data-value": cellValue.toString(),
          "data-disabled": isDisabled || isOutsideMonth ? "" : void 0,
          "data-unavailable": isUnavailable ? "" : void 0,
          "data-today": isDateToday ? "" : void 0,
          "data-outside-month": isOutsideMonth ? "" : void 0,
          "data-outside-visible-months": isOutsideVisibleMonths2 ? "" : void 0,
          "data-focused": isFocusedDate ? "" : void 0,
          "data-highlighted": isHighlighted ? "" : void 0,
          tabindex: isFocusedDate ? 0 : isOutsideMonth || isDisabled ? void 0 : -1
        };
      };
    },
    action: (node) => {
      const getElArgs = () => {
        const value2 = node.getAttribute("data-value");
        const label = node.getAttribute("data-label");
        const disabled2 = node.hasAttribute("data-disabled");
        return {
          value: value2,
          label: label ?? node.textContent ?? null,
          disabled: disabled2 ? true : false
        };
      };
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e) => {
        const args = getElArgs();
        if (args.disabled)
          return;
        if (!args.value)
          return;
        handleCellClick(e, parseStringToDateValue(args.value, placeholder.get()));
      }), addMeltEventListener(node, "mouseenter", () => {
        const args = getElArgs();
        if (args.disabled)
          return;
        if (!args.value)
          return;
        focusedValue.set(parseStringToDateValue(args.value, placeholder.get()));
      }), addMeltEventListener(node, "focusin", () => {
        const args = getElArgs();
        if (args.disabled)
          return;
        if (!args.value)
          return;
        focusedValue.set(parseStringToDateValue(args.value, placeholder.get()));
      }));
      return {
        destroy: unsub
      };
    }
  });
  effect([locale], ([$locale]) => {
    if (formatter.getLocale() === $locale)
      return;
    formatter.setLocale($locale);
  });
  effect([placeholder], ([$placeholder]) => {
    if (!isBrowser || !$placeholder)
      return;
    const $visibleMonths = visibleMonths.get();
    if ($visibleMonths.some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(month, $placeholder))) {
      return;
    }
    const $weekStartsOn = weekStartsOn.get();
    const $locale = locale.get();
    const $fixedWeeks = fixedWeeks.get();
    const $numberOfMonths = numberOfMonths.get();
    const defaultMonthProps = {
      weekStartsOn: $weekStartsOn,
      locale: $locale,
      fixedWeeks: $fixedWeeks,
      numberOfMonths: $numberOfMonths
    };
    months.set(createMonths({
      ...defaultMonthProps,
      dateObj: $placeholder
    }));
  });
  effect([weekStartsOn, locale, fixedWeeks, numberOfMonths], ([$weekStartsOn, $locale, $fixedWeeks, $numberOfMonths]) => {
    const $placeholder = placeholder.get();
    if (!isBrowser || !$placeholder)
      return;
    const defaultMonthProps = {
      weekStartsOn: $weekStartsOn,
      locale: $locale,
      fixedWeeks: $fixedWeeks,
      numberOfMonths: $numberOfMonths
    };
    months.set(createMonths({
      ...defaultMonthProps,
      dateObj: $placeholder
    }));
  });
  effect([fullCalendarLabel], ([$fullCalendarLabel]) => {
    if (!isBrowser)
      return;
    const node = document.getElementById(ids.accessibleHeading.get());
    if (!isHTMLElement(node))
      return;
    node.textContent = $fullCalendarLabel;
  });
  effect([startValue], ([$startValue]) => {
    if ($startValue && placeholder.get() !== $startValue) {
      placeholder.set($startValue);
    }
  });
  const weekdays = derived([months, weekdayFormat, locale], ([$months, $weekdayFormat, _]) => {
    if (!$months.length)
      return [];
    return $months[0].weeks[0].map((date) => {
      return formatter.dayOfWeek(toDate(date), $weekdayFormat);
    });
  });
  function createAccessibleHeading(node, label) {
    if (!isBrowser)
      return;
    const div = document.createElement("div");
    div.style.cssText = styleToString({
      border: "0px",
      clip: "rect(0px, 0px, 0px, 0px)",
      "clip-path": "inset(50%)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: "0px",
      position: "absolute",
      "white-space": "nowrap",
      width: "1px"
    });
    const h2 = document.createElement("div");
    h2.textContent = label;
    h2.id = ids.accessibleHeading.get();
    h2.role = "heading";
    h2.ariaLevel = "2";
    node.insertBefore(div, node.firstChild);
    div.appendChild(h2);
  }
  function nextPage() {
    const $months = months.get();
    const $numberOfMonths = numberOfMonths.get();
    if (pagedNavigation.get()) {
      const firstMonth = $months[0].value;
      placeholder.set(firstMonth.add({ months: $numberOfMonths }));
    } else {
      const firstMonth = $months[0].value;
      const newMonths = createMonths({
        dateObj: firstMonth.add({ months: 1 }),
        weekStartsOn: weekStartsOn.get(),
        locale: locale.get(),
        fixedWeeks: fixedWeeks.get(),
        numberOfMonths: $numberOfMonths
      });
      months.set(newMonths);
      placeholder.set(newMonths[0].value.set({ day: 1 }));
    }
  }
  function prevPage() {
    const $months = months.get();
    const $numberOfMonths = numberOfMonths.get();
    if (pagedNavigation.get()) {
      const firstMonth = $months[0].value;
      placeholder.set(firstMonth.subtract({ months: $numberOfMonths }));
    } else {
      const firstMonth = $months[0].value;
      const newMonths = createMonths({
        dateObj: firstMonth.subtract({ months: 1 }),
        weekStartsOn: weekStartsOn.get(),
        locale: locale.get(),
        fixedWeeks: fixedWeeks.get(),
        numberOfMonths: $numberOfMonths
      });
      months.set(newMonths);
      placeholder.set(newMonths[0].value.set({ day: 1 }));
    }
  }
  function nextYear() {
    placeholder.add({ years: 1 });
  }
  function prevYear() {
    placeholder.subtract({ years: 1 });
  }
  const ARROW_KEYS = [kbd.ARROW_DOWN, kbd.ARROW_UP, kbd.ARROW_LEFT, kbd.ARROW_RIGHT];
  function setYear(year) {
    placeholder.setDate({ year });
  }
  function setMonth(month) {
    if (month < 0 || month > 11)
      throw new Error("Month must be between 0 and 11");
    placeholder.setDate({ month });
  }
  function handleCellClick(e, date) {
    const $isDateDisabled = isDateDisabled.get();
    const $isDateUnavailable = isDateUnavailable.get();
    if ($isDateDisabled(date) || $isDateUnavailable(date))
      return;
    const $lastPressedDate = lastPressedDateValue.get();
    lastPressedDateValue.set(date);
    const $startValue = startValue.get();
    const $endValue = endValue.get();
    const $highlightedRange = highlightedRange.get();
    if ($startValue && $highlightedRange === null) {
      if ($14e0f24ef4ac5c92$export$ea39ec197993aef0($startValue, date) && !preventDeselect.get() && !$endValue) {
        startValue.set(void 0);
        placeholder.set(date);
        announcer.announce("Selected date is now empty.", "polite");
        return;
      } else if (!$endValue) {
        e.preventDefault();
        if ($lastPressedDate && $14e0f24ef4ac5c92$export$ea39ec197993aef0($lastPressedDate, date)) {
          startValue.set(date);
          announcer.announce(`Selected Date: ${formatter.selectedDate(date, false)}`, "polite");
        }
        return;
      }
    }
    if ($startValue && $endValue && $14e0f24ef4ac5c92$export$ea39ec197993aef0($endValue, date) && !preventDeselect.get()) {
      startValue.set(void 0);
      endValue.set(void 0);
      placeholder.set(date);
      announcer.announce("Selected date is now empty.", "polite");
      return;
    }
    if (!$startValue) {
      startValue.update(() => {
        announcer.announce(`Selected Date: ${formatter.selectedDate(date, false)}`, "polite");
        return date;
      });
    } else if (!$endValue) {
      endValue.update(() => {
        announcer.announce(`Selected Dates: ${formatter.selectedDate($startValue, false)} to ${formatter.selectedDate(date, false)}`, "polite");
        return date;
      });
    } else if ($endValue && $startValue) {
      endValue.set(void 0);
      startValue.update(() => {
        announcer.announce(`Selected Date: ${formatter.selectedDate(date, false)}`, "polite");
        return date;
      });
    }
  }
  const SELECT_KEYS = [kbd.ENTER, kbd.SPACE];
  function handleCalendarKeydown(e) {
    const currentCell = e.target;
    if (!isCalendarCell(currentCell))
      return;
    if (!ARROW_KEYS.includes(e.key) && !SELECT_KEYS.includes(e.key))
      return;
    e.preventDefault();
    if (e.key === kbd.ARROW_DOWN) {
      shiftFocus(currentCell, 7);
    }
    if (e.key === kbd.ARROW_UP) {
      shiftFocus(currentCell, -7);
    }
    if (e.key === kbd.ARROW_LEFT) {
      shiftFocus(currentCell, -1);
    }
    if (e.key === kbd.ARROW_RIGHT) {
      shiftFocus(currentCell, 1);
    }
    if (e.key === kbd.SPACE || e.key === kbd.ENTER) {
      const cellValue = currentCell.getAttribute("data-value");
      if (!cellValue)
        return;
      handleCellClick(e, parseStringToDateValue(cellValue, placeholder.get()));
    }
  }
  function shiftFocus(node, add) {
    const $calendarId = ids.calendar.get();
    const candidateCells = getSelectableCells($calendarId);
    if (!candidateCells.length) {
      return;
    }
    const index = candidateCells.indexOf(node);
    const nextIndex = index + add;
    if (isValidIndex(nextIndex, candidateCells)) {
      const nextCell = candidateCells[nextIndex];
      setPlaceholderToNodeValue(nextCell, placeholder);
      return nextCell.focus();
    }
    if (nextIndex < 0) {
      if (isPrevButtonDisabled.get())
        return;
      const $months = months.get();
      const firstMonth = $months[0].value;
      const $numberOfMonths = numberOfMonths.get();
      placeholder.set(firstMonth.subtract({ months: $numberOfMonths }));
      tick().then(() => {
        const newCandidateCells = getSelectableCells($calendarId);
        if (!newCandidateCells.length) {
          return;
        }
        const newIndex = newCandidateCells.length - Math.abs(nextIndex);
        if (isValidIndex(newIndex, newCandidateCells)) {
          const newCell = newCandidateCells[newIndex];
          setPlaceholderToNodeValue(newCell, placeholder);
          return newCell.focus();
        }
      });
    }
    if (nextIndex >= candidateCells.length) {
      if (isNextButtonDisabled.get())
        return;
      const $months = months.get();
      const firstMonth = $months[0].value;
      const $numberOfMonths = numberOfMonths.get();
      placeholder.set(firstMonth.add({ months: $numberOfMonths }));
      tick().then(() => {
        const newCandidateCells = getSelectableCells($calendarId);
        if (!newCandidateCells.length) {
          return;
        }
        const newIndex = nextIndex - candidateCells.length;
        if (isValidIndex(newIndex, newCandidateCells)) {
          const nextCell = newCandidateCells[newIndex];
          return nextCell.focus();
        }
      });
    }
  }
  const _isDateDisabled = derived([isDateDisabled, placeholder, minValue, maxValue], ([$isDateDisabled, $placeholder, $minValue, $maxValue]) => {
    return (date) => {
      if ($isDateDisabled(date))
        return true;
      if ($minValue && isBefore(date, $minValue))
        return true;
      if ($maxValue && isAfter(date, $maxValue))
        return true;
      if (!$14e0f24ef4ac5c92$export$a18c89cbd24170ff(date, $placeholder))
        return true;
      return false;
    };
  });
  effect([value], ([$value]) => {
    const $startValue = startValue.get();
    const $endValue = endValue.get();
    if (($value == null ? void 0 : $value.start) && ($value == null ? void 0 : $value.end)) {
      if ($value.start !== $startValue) {
        startValue.set($value.start);
      }
      if ($value.end !== $endValue) {
        endValue.set($value.end);
      }
      return;
    }
  });
  effect([startValue, endValue], ([$startValue, $endValue]) => {
    const $value = value.get();
    if ($value && ($value == null ? void 0 : $value.start) === $startValue && ($value == null ? void 0 : $value.end) === $endValue)
      return;
    if ($startValue && $endValue) {
      value.update((prev2) => {
        if ((prev2 == null ? void 0 : prev2.start) === $startValue && (prev2 == null ? void 0 : prev2.end) === $endValue) {
          return prev2;
        }
        if (isBefore($endValue, $startValue)) {
          return {
            start: $endValue,
            end: $startValue
          };
        } else {
          return {
            start: $startValue,
            end: $endValue
          };
        }
      });
    } else if ($value && $value.start && $value.end) {
      value.set({
        start: void 0,
        end: void 0
      });
    }
  });
  return {
    elements: {
      calendar,
      heading,
      grid,
      cell,
      nextButton,
      prevButton
    },
    states: {
      placeholder: placeholder.toWritable(),
      months,
      weekdays,
      headingValue,
      value,
      startValue,
      endValue
    },
    helpers: {
      nextPage,
      prevPage,
      nextYear,
      prevYear,
      setYear,
      setMonth,
      isDateDisabled: _isDateDisabled,
      isDateUnavailable
    },
    options,
    ids
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/scroll-area/helpers.js
function debounceCallback(cb, delay) {
  let debounceTimer = 0;
  safeOnDestroy(() => {
    clearTimeout(debounceTimer);
  });
  return () => {
    window.clearTimeout(debounceTimer);
    debounceTimer = window.setTimeout(cb, delay);
  };
}
function resizeObserver(node, handleResize) {
  let animationFrame = 0;
  const observer = new ResizeObserver(() => {
    cancelAnimationFrame(animationFrame);
    animationFrame = requestAnimationFrame(handleResize);
  });
  observer.observe(node);
  return () => {
    window.cancelAnimationFrame(animationFrame);
    observer.unobserve(node);
  };
}
function addUnlinkedScrollListener(node, handler = noop) {
  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };
  let rAF = 0;
  (function loop() {
    const position = { left: node.scrollLeft, top: node.scrollTop };
    const isHorizontalScroll = prevPosition.left !== position.left;
    const isVerticalScroll = prevPosition.top !== position.top;
    if (isHorizontalScroll || isVerticalScroll)
      handler();
    prevPosition = position;
    rAF = window.requestAnimationFrame(loop);
  })();
  return () => window.cancelAnimationFrame(rAF);
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function toInt(value) {
  return value ? parseInt(value, 10) : 0;
}
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset2 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset2;
  const minPointerPos = sizes.scrollbar.paddingStart + offset2;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange);
  return interpolate(pointerPos);
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const [scrollClampMin, scrollClampMax] = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp(scrollClampMin, scrollPos, scrollClampMax);
  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate(scrollWithoutMomentum);
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/store/stateMachine.js
function createStateMachine(initialState, machine) {
  const state = withGet.writable(initialState);
  function reducer(event2) {
    const $state = state.get();
    const nextState = machine[$state][event2];
    return nextState ?? $state;
  }
  const dispatch = (event2) => {
    state.set(reducer(event2));
  };
  return {
    state,
    dispatch
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/scroll-area/scrollbars.js
function createBaseScrollbarAction(state) {
  const { rootState, scrollbarState } = state;
  scrollbarState.isVisible.set(true);
  function handleDragScroll(e) {
    const $domRect = scrollbarState.domRect.get();
    if (!$domRect)
      return;
    const x = e.clientX - $domRect.left;
    const y = e.clientY - $domRect.top;
    const $isHorizontal = scrollbarState.isHorizontal.get();
    if ($isHorizontal) {
      scrollbarState.onDragScroll(x);
    } else {
      scrollbarState.onDragScroll(y);
    }
  }
  function handlePointerDown(e) {
    if (e.button !== 0)
      return;
    const target = e.target;
    if (!isHTMLElement(target))
      return;
    target.setPointerCapture(e.pointerId);
    const currentTarget = e.currentTarget;
    if (!isHTMLElement(currentTarget))
      return;
    scrollbarState.domRect.set(currentTarget.getBoundingClientRect());
    scrollbarState.prevWebkitUserSelect.set(document.body.style.webkitUserSelect);
    document.body.style.webkitUserSelect = "none";
    const $viewportEl = rootState.viewportEl.get();
    if ($viewportEl) {
      $viewportEl.style.scrollBehavior = "auto";
    }
    handleDragScroll(e);
  }
  function handlePointerMove(e) {
    handleDragScroll(e);
  }
  function handlePointerUp(e) {
    const target = e.target;
    if (!isHTMLElement(target))
      return;
    if (target.hasPointerCapture(e.pointerId)) {
      target.releasePointerCapture(e.pointerId);
    }
    document.body.style.webkitUserSelect = scrollbarState.prevWebkitUserSelect.get();
    const $viewportEl = rootState.viewportEl.get();
    if ($viewportEl) {
      $viewportEl.style.scrollBehavior = "";
    }
    scrollbarState.domRect.set(null);
  }
  function handleWheel(e) {
    const target = e.target;
    const currentTarget = e.currentTarget;
    if (!isHTMLElement(target) || !isHTMLElement(currentTarget))
      return;
    const isScrollbarWheel = currentTarget.contains(target);
    if (!isScrollbarWheel)
      return;
    const $sizes = scrollbarState.sizes.get();
    if (!$sizes)
      return;
    const maxScrollPos = $sizes.content - $sizes.viewport;
    scrollbarState.handleWheelScroll(e, maxScrollPos);
  }
  function baseAction(node) {
    scrollbarState.scrollbarEl.set(node);
    const unsubEvents = executeCallbacks(addMeltEventListener(node, "pointerdown", handlePointerDown), addMeltEventListener(node, "pointermove", handlePointerMove), addMeltEventListener(node, "pointerup", handlePointerUp), addEventListener(document, "wheel", handleWheel, { passive: false }));
    const unsubResizeContent = effect([rootState.contentEl], ([$contentEl]) => {
      if (!$contentEl)
        return noop;
      return resizeObserver($contentEl, scrollbarState.handleSizeChange);
    });
    return {
      destroy() {
        unsubEvents();
        unsubResizeContent();
      }
    };
  }
  return baseAction;
}
function createAutoScrollbarAction(state) {
  const baseAction = createBaseScrollbarAction(state);
  const { rootState, scrollbarState } = state;
  const handleResize = debounceCallback(() => {
    const $viewportEl = rootState.viewportEl.get();
    if (!$viewportEl)
      return;
    const isOverflowX = $viewportEl.offsetWidth < $viewportEl.scrollWidth;
    const isOverflowY = $viewportEl.offsetHeight < $viewportEl.scrollHeight;
    scrollbarState.isVisible.set(scrollbarState.isHorizontal.get() ? isOverflowX : isOverflowY);
  }, 10);
  function scrollbarAutoAction(node) {
    var _a;
    const unsubBaseAction = (_a = baseAction(node)) == null ? void 0 : _a.destroy;
    handleResize();
    const unsubObservers = [];
    const $viewportEl = rootState.viewportEl.get();
    if ($viewportEl) {
      unsubObservers.push(resizeObserver($viewportEl, handleResize));
    }
    const $contentEl = rootState.contentEl.get();
    if ($contentEl) {
      unsubObservers.push(resizeObserver($contentEl, handleResize));
    }
    return {
      destroy() {
        unsubObservers.forEach((unsub) => unsub());
        unsubBaseAction();
      }
    };
  }
  return scrollbarAutoAction;
}
function createHoverScrollbarAction(state) {
  const baseAction = createBaseScrollbarAction(state);
  const { rootState, scrollbarState } = state;
  scrollbarState.isVisible.set(false);
  let timeout;
  function handlePointerEnter() {
    window.clearTimeout(timeout);
    if (scrollbarState.isVisible.get())
      return;
    const $viewportEl = rootState.viewportEl.get();
    if (!$viewportEl)
      return;
    const isOverflowX = $viewportEl.offsetWidth < $viewportEl.scrollWidth;
    const isOverflowY = $viewportEl.offsetHeight < $viewportEl.scrollHeight;
    scrollbarState.isVisible.set(scrollbarState.isHorizontal.get() ? isOverflowX : isOverflowY);
  }
  function handlePointerLeave() {
    timeout = window.setTimeout(() => {
      if (!scrollbarState.isVisible.get())
        return;
      scrollbarState.isVisible.set(false);
    }, rootState.options.hideDelay.get());
  }
  function scrollbarHoverAction(node) {
    var _a;
    const unsubBaseAction = (_a = baseAction(node)) == null ? void 0 : _a.destroy;
    const scrollAreaEl = node.closest("[data-melt-scroll-area]");
    let unsubScrollAreaListeners = noop;
    if (scrollAreaEl) {
      if (isTouchDevice()) {
        unsubScrollAreaListeners = executeCallbacks(addEventListener(scrollAreaEl, "touchstart", handlePointerEnter), addEventListener(scrollAreaEl, "touchend", handlePointerLeave));
      } else if (isFirefox()) {
        unsubScrollAreaListeners = executeCallbacks(addEventListener(scrollAreaEl, "pointerenter", handlePointerEnter), addEventListener(scrollAreaEl, "mouseenter", handlePointerEnter), addEventListener(scrollAreaEl, "mouseleave", handlePointerLeave));
      } else {
        unsubScrollAreaListeners = executeCallbacks(addEventListener(scrollAreaEl, "pointerenter", handlePointerEnter), addEventListener(scrollAreaEl, "pointerleave", handlePointerLeave));
      }
    }
    return {
      destroy() {
        unsubBaseAction == null ? void 0 : unsubBaseAction();
        unsubScrollAreaListeners();
      }
    };
  }
  return scrollbarHoverAction;
}
function createScrollScrollbarAction(state) {
  const baseAction = createBaseScrollbarAction(state);
  const { rootState, scrollbarState } = state;
  const machine = createStateMachine("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  effect([machine.state], ([$status]) => {
    if ($status === "idle") {
      window.setTimeout(() => {
        machine.dispatch("HIDE");
      }, rootState.options.hideDelay.get());
    }
    if ($status === "hidden") {
      scrollbarState.isVisible.set(false);
    } else {
      scrollbarState.isVisible.set(true);
    }
  });
  const debounceScrollEnd = debounceCallback(() => machine.dispatch("SCROLL_END"), 100);
  effect([rootState.viewportEl, scrollbarState.isHorizontal], ([$viewportEl, $isHorizontal]) => {
    const scrollDirection = $isHorizontal ? "scrollLeft" : "scrollTop";
    let unsub = noop;
    if ($viewportEl) {
      let prevScrollPos = $viewportEl[scrollDirection];
      const handleScroll = () => {
        const scrollPos = $viewportEl[scrollDirection];
        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
        if (hasScrollInDirectionChanged) {
          machine.dispatch("SCROLL");
          debounceScrollEnd();
        }
        prevScrollPos = scrollPos;
      };
      unsub = addEventListener($viewportEl, "scroll", handleScroll);
    }
    return () => {
      unsub();
    };
  });
  function scrollbarScrollAction(node) {
    var _a;
    const unsubBaseAction = (_a = baseAction(node)) == null ? void 0 : _a.destroy;
    const unsubListeners = executeCallbacks(addEventListener(node, "pointerenter", () => machine.dispatch("POINTER_ENTER")), addEventListener(node, "pointerleave", () => machine.dispatch("POINTER_LEAVE")));
    return {
      destroy() {
        unsubBaseAction == null ? void 0 : unsubBaseAction();
        unsubListeners();
      }
    };
  }
  return scrollbarScrollAction;
}
function createScrollbarX(state, createAction) {
  const action2 = createAction(state);
  const { rootState, scrollbarState } = state;
  return makeElement(name17("scrollbar"), {
    stores: [scrollbarState.sizes, rootState.options.dir, scrollbarState.isVisible],
    returned: ([$sizes, $dir, $isVisible]) => {
      return {
        style: styleToString({
          position: "absolute",
          bottom: 0,
          left: $dir === "rtl" ? "var(--melt-scroll-area-corner-width)" : 0,
          right: $dir === "ltr" ? "var(--melt-scroll-area-corner-width)" : 0,
          "--melt-scroll-area-thumb-width": `${getThumbSize($sizes)}px`,
          visibility: !$isVisible ? "hidden" : void 0
        }),
        "data-state": $isVisible ? "visible" : "hidden"
      };
    },
    action: (node) => {
      var _a;
      const unsubAction = (_a = action2(node)) == null ? void 0 : _a.destroy;
      rootState.scrollbarXEl.set(node);
      rootState.scrollbarXEnabled.set(true);
      return {
        destroy() {
          unsubAction == null ? void 0 : unsubAction();
          rootState.scrollbarXEl.set(null);
        }
      };
    }
  });
}
function createScrollbarY(state, createAction) {
  const action2 = createAction(state);
  const { rootState, scrollbarState } = state;
  return makeElement(name17("scrollbar"), {
    stores: [scrollbarState.sizes, rootState.options.dir, scrollbarState.isVisible],
    returned: ([$sizes, $dir, $isVisible]) => {
      return {
        style: styleToString({
          position: "absolute",
          top: 0,
          right: $dir === "ltr" ? 0 : void 0,
          left: $dir === "rtl" ? 0 : void 0,
          bottom: "var(--melt-scroll-area-corner-height)",
          "--melt-scroll-area-thumb-height": `${getThumbSize($sizes)}px`,
          visibility: !$isVisible ? "hidden" : void 0
        }),
        "data-state": $isVisible ? "visible" : "hidden"
      };
    },
    action: (node) => {
      var _a;
      const unsubAction = (_a = action2(node)) == null ? void 0 : _a.destroy;
      rootState.scrollbarYEl.set(node);
      rootState.scrollbarYEnabled.set(true);
      return {
        destroy() {
          unsubAction == null ? void 0 : unsubAction();
          rootState.scrollbarYEl.set(null);
        }
      };
    }
  });
}
function getScrollbarActionByType(type) {
  switch (type) {
    case "always":
      return createBaseScrollbarAction;
    case "auto":
      return createAutoScrollbarAction;
    case "hover":
      return createHoverScrollbarAction;
    case "scroll":
      return createScrollScrollbarAction;
    default:
      return createBaseScrollbarAction;
  }
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/scroll-area/create.js
var { name: name17 } = createElHelpers("scroll-area");
var scrollAreaIdParts = [
  "root",
  "viewport",
  "content",
  "scrollbarX",
  "scrollbarY",
  "thumbX",
  "thumbY"
];
var defaults25 = {
  type: "hover",
  hideDelay: 600,
  dir: "ltr"
};
function createScrollArea(props) {
  const withDefaults = { ...defaults25, ...props };
  const options = toWritableStores(omit(withDefaults, "ids"));
  const cornerWidth = withGet.writable(0);
  const cornerHeight = withGet.writable(0);
  const scrollbarXEnabled = withGet.writable(false);
  const scrollbarYEnabled = withGet.writable(false);
  const scrollAreaEl = withGet.writable(null);
  const viewportEl = withGet.writable(null);
  const contentEl = withGet.writable(null);
  const scrollbarXEl = withGet.writable(null);
  const scrollbarYEl = withGet.writable(null);
  const ids = toWritableStores({ ...generateIds(scrollAreaIdParts), ...withDefaults.ids });
  const rootState = {
    cornerWidth,
    cornerHeight,
    scrollbarXEnabled,
    scrollbarYEnabled,
    viewportEl,
    contentEl,
    options,
    scrollbarXEl,
    scrollbarYEl,
    scrollAreaEl,
    ids
  };
  const root5 = makeElement(name17(), {
    stores: [cornerWidth, cornerHeight, ids.root],
    returned: ([$cornerWidth, $cornderHeight, $rootId]) => {
      return {
        style: styleToString({
          position: "relative",
          "--melt-scroll-area-corner-width": `${$cornerWidth}px`,
          "--melt-scroll-area-corner-height": `${$cornderHeight}px`
        }),
        id: $rootId
      };
    },
    action: (node) => {
      scrollAreaEl.set(node);
      return {
        destroy() {
          scrollAreaEl.set(null);
        }
      };
    }
  });
  const viewport = makeElement(name17("viewport"), {
    stores: [scrollbarXEnabled, scrollbarYEnabled, ids.viewport],
    returned: ([$scrollbarXEnabled, $scrollbarYEnabled, $viewportId]) => {
      return {
        style: styleToString({
          "scrollbar-width": "none",
          "-ms-overflow-style": "none",
          "-webkit-overflow-scrolling": "touch",
          "-webkit-scrollbar": "none",
          "overflow-x": $scrollbarXEnabled ? "scroll" : "hidden",
          "overflow-y": $scrollbarYEnabled ? "scroll" : "hidden"
        }),
        id: $viewportId
      };
    },
    action: (node) => {
      var _a;
      const styleNode = document.createElement("style");
      styleNode.innerHTML = `
				/* Hide scrollbars cross-browser and enable momentum scroll for touch
					devices */
				[data-melt-scroll-area-viewport] {
					scrollbar-width: none;
					-ms-overflow-style: none;
					-webkit-overflow-scrolling: touch;
				}

				[data-melt-scroll-area-viewport]::-webkit-scrollbar {
					display: none;
				}
			`;
      (_a = node.parentElement) == null ? void 0 : _a.insertBefore(styleNode, node);
      viewportEl.set(node);
      return {
        destroy() {
          styleNode.remove();
          viewportEl.set(null);
        }
      };
    }
  });
  const content = makeElement(name17("content"), {
    stores: [ids.content],
    returned: ([$contentId]) => {
      return {
        style: styleToString({
          "min-width": "100%",
          display: "table"
        }),
        id: $contentId
      };
    },
    action: (node) => {
      contentEl.set(node);
      return {
        destroy() {
          contentEl.set(null);
        }
      };
    }
  });
  function createScrollbar(orientationProp = "vertical") {
    const orientation = withGet.writable(orientationProp);
    const isHorizontal = withGet.writable(orientationProp === "horizontal");
    const domRect = withGet.writable(null);
    const prevWebkitUserSelect = withGet.writable("");
    const pointerOffset = withGet.writable(0);
    const thumbEl = withGet.writable(null);
    const thumbOffset = withGet.writable(0);
    const scrollbarEl = withGet.writable(null);
    const sizes = withGet.writable({
      content: 0,
      viewport: 0,
      scrollbar: {
        size: 0,
        paddingStart: 0,
        paddingEnd: 0
      }
    });
    const isVisible = withGet.writable(false);
    const hasThumb = withGet.derived(sizes, ($sizes) => {
      const thumbRatio = getThumbRatio($sizes.viewport, $sizes.content);
      return Boolean(thumbRatio > 0 && thumbRatio < 1);
    });
    function getScrollPosition(pointerPos, dir) {
      return getScrollPositionFromPointer(pointerPos, pointerOffset.get(), sizes.get(), dir);
    }
    function handleWheelScroll(e, payload) {
      const $viewportEl = viewportEl.get();
      if (!$viewportEl)
        return;
      if (isHorizontal.get()) {
        const scrollPos = $viewportEl.scrollLeft + e.deltaY;
        $viewportEl.scrollLeft = scrollPos;
        if (isScrollingWithinScrollbarBounds(scrollPos, payload)) {
          e.preventDefault();
        }
      } else {
        const scrollPos = $viewportEl.scrollTop + e.deltaY;
        $viewportEl.scrollTop = scrollPos;
        if (isScrollingWithinScrollbarBounds(scrollPos, payload)) {
          e.preventDefault();
        }
      }
    }
    function handleThumbDown(payload) {
      if (isHorizontal.get()) {
        pointerOffset.set(payload.x);
      } else {
        pointerOffset.set(payload.y);
      }
    }
    function handleThumbUp() {
      pointerOffset.set(0);
    }
    function onThumbPositionChange() {
      const $viewportEl = viewportEl.get();
      const $thumbEl = thumbEl.get();
      if (!$viewportEl || !$thumbEl)
        return;
      const scrollPos = isHorizontal.get() ? $viewportEl.scrollLeft : $viewportEl.scrollTop;
      const offset2 = getThumbOffsetFromScroll(scrollPos, sizes.get(), rootState.options.dir.get());
      thumbOffset.set(offset2);
    }
    function onDragScroll(payload) {
      const $viewportEl = viewportEl.get();
      if (!$viewportEl)
        return;
      if (isHorizontal.get()) {
        $viewportEl.scrollLeft = getScrollPosition(payload, rootState.options.dir.get());
      } else {
        $viewportEl.scrollTop = getScrollPosition(payload);
      }
    }
    function handleSizeChange() {
      const $scrollbarEl = scrollbarState.scrollbarEl.get();
      if (!$scrollbarEl)
        return;
      const $isHorizontal = scrollbarState.isHorizontal.get();
      const $viewportEl = rootState.viewportEl.get();
      if ($isHorizontal) {
        scrollbarState.sizes.set({
          content: ($viewportEl == null ? void 0 : $viewportEl.scrollWidth) ?? 0,
          viewport: ($viewportEl == null ? void 0 : $viewportEl.offsetWidth) ?? 0,
          scrollbar: {
            size: $scrollbarEl.clientWidth ?? 0,
            paddingStart: toInt(getComputedStyle($scrollbarEl).paddingLeft),
            paddingEnd: toInt(getComputedStyle($scrollbarEl).paddingRight)
          }
        });
      } else {
        scrollbarState.sizes.set({
          content: ($viewportEl == null ? void 0 : $viewportEl.scrollHeight) ?? 0,
          viewport: ($viewportEl == null ? void 0 : $viewportEl.offsetHeight) ?? 0,
          scrollbar: {
            size: $scrollbarEl.clientHeight ?? 0,
            paddingStart: toInt(getComputedStyle($scrollbarEl).paddingLeft),
            paddingEnd: toInt(getComputedStyle($scrollbarEl).paddingRight)
          }
        });
      }
    }
    const scrollbarState = {
      isHorizontal,
      domRect,
      prevWebkitUserSelect,
      pointerOffset,
      thumbEl,
      thumbOffset,
      sizes,
      orientation,
      handleThumbDown,
      handleThumbUp,
      onThumbPositionChange,
      onDragScroll,
      handleWheelScroll,
      hasThumb,
      scrollbarEl,
      isVisible,
      handleSizeChange
    };
    const scrollbarActionByType = getScrollbarActionByType(options.type.get());
    const scrollAreaState = { rootState, scrollbarState };
    const scrollbar = orientationProp === "horizontal" ? createScrollbarX(scrollAreaState, scrollbarActionByType) : createScrollbarY(scrollAreaState, scrollbarActionByType);
    const thumb = createScrollbarThumb(scrollAreaState);
    return {
      scrollbar,
      thumb
    };
  }
  const { scrollbar: scrollbarX, thumb: thumbX } = createScrollbar("horizontal");
  const { scrollbar: scrollbarY, thumb: thumbY } = createScrollbar("vertical");
  const corner = createScrollAreaCorner(rootState);
  return {
    options,
    elements: {
      root: root5,
      viewport,
      content,
      corner,
      scrollbarX,
      scrollbarY,
      thumbX,
      thumbY
    }
  };
}
function createScrollbarThumb(state) {
  const { scrollbarState, rootState } = state;
  function handlePointerDown(e) {
    const thumb2 = e.target;
    if (!isHTMLElement(thumb2))
      return;
    const thumbRect = thumb2.getBoundingClientRect();
    const x = e.clientX - thumbRect.left;
    const y = e.clientY - thumbRect.top;
    scrollbarState.handleThumbDown({ x, y });
  }
  function handlePointerUp(e) {
    scrollbarState.handleThumbUp(e);
  }
  let unsubListener = void 0;
  function handleScroll() {
    if (unsubListener)
      return;
    const $viewportEl = rootState.viewportEl.get();
    if ($viewportEl) {
      unsubListener = addUnlinkedScrollListener($viewportEl, scrollbarState.onThumbPositionChange);
    }
    scrollbarState.onThumbPositionChange();
  }
  const thumb = makeElement(name17("thumb"), {
    stores: [scrollbarState.hasThumb, scrollbarState.isHorizontal, scrollbarState.thumbOffset],
    returned: ([$hasThumb, $isHorizontal, $offset]) => {
      return {
        style: styleToString({
          width: "var(--melt-scroll-area-thumb-width)",
          height: "var(--melt-scroll-area-thumb-height)",
          transform: $isHorizontal ? `translate3d(${Math.round($offset)}px, 0, 0)` : `translate3d(0, ${Math.round($offset)}px, 0)`
        }),
        "data-state": $hasThumb ? "visible" : "hidden"
      };
    },
    action: (node) => {
      scrollbarState.thumbEl.set(node);
      const unsubEffect = effect([scrollbarState.sizes], ([_]) => {
        const $viewportEl = rootState.viewportEl.get();
        if (!$viewportEl)
          return noop;
        scrollbarState.onThumbPositionChange();
        return addEventListener($viewportEl, "scroll", handleScroll);
      });
      const unsubEvents = executeCallbacks(addMeltEventListener(node, "pointerdown", handlePointerDown), addMeltEventListener(node, "pointerup", handlePointerUp));
      return {
        destroy() {
          unsubListener == null ? void 0 : unsubListener();
          unsubEvents();
          unsubEffect();
        }
      };
    }
  });
  return thumb;
}
function createScrollAreaCorner(rootState) {
  const width = writable(0);
  const height = writable(0);
  const hasSize = derived([width, height], ([$width, $height]) => !!$width && !!$height);
  function setCornerHeight() {
    var _a;
    const offsetHeight = ((_a = rootState.scrollbarXEl.get()) == null ? void 0 : _a.offsetHeight) || 0;
    rootState.cornerHeight.set(offsetHeight);
    height.set(offsetHeight);
  }
  function setCornerWidth() {
    var _a;
    const offsetWidth = ((_a = rootState.scrollbarYEl.get()) == null ? void 0 : _a.offsetWidth) || 0;
    rootState.cornerWidth.set(offsetWidth);
    width.set(offsetWidth);
  }
  effect([rootState.scrollbarXEl], ([$scrollbarXEl]) => {
    if ($scrollbarXEl) {
      setCornerHeight();
    }
  });
  effect([rootState.scrollbarYEl], ([$scrollbarYEl]) => {
    if ($scrollbarYEl) {
      setCornerWidth();
    }
  });
  const hasBothScrollbarsVisible = derived([rootState.scrollbarXEl, rootState.scrollbarYEl], ([$scrollbarXEl, $scrollbarYEl]) => {
    return !!$scrollbarXEl && !!$scrollbarYEl;
  });
  const hasCorner = derived([rootState.options.type, hasBothScrollbarsVisible], ([$type, $hasBoth]) => {
    return $type !== "scroll" && $hasBoth;
  });
  const shouldDisplay = derived([hasCorner, hasSize], ([$hasCorner, $hasSize]) => $hasCorner && $hasSize);
  const corner = makeElement(name17("corner"), {
    stores: [width, height, rootState.options.dir, shouldDisplay],
    returned: ([$width, $height, $dir, $shouldDisplay]) => {
      return {
        style: styleToString({
          display: $shouldDisplay ? "block" : "none",
          width: `${$width}px`,
          height: `${$height}px`,
          position: "absolute",
          right: $dir === "ltr" ? 0 : void 0,
          left: $dir === "rtl" ? 0 : void 0,
          bottom: 0
        })
      };
    }
  });
  return corner;
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/select/create.js
function createSelect(props) {
  const listbox = createListbox({ ...props, builder: "select" });
  const selectedLabel = derived(listbox.states.selected, ($selected) => {
    if (Array.isArray($selected)) {
      return $selected.map((o) => o.label).join(", ");
    }
    return ($selected == null ? void 0 : $selected.label) ?? "";
  });
  return {
    ...listbox,
    elements: {
      ...listbox.elements
    },
    states: {
      ...listbox.states,
      selectedLabel
    }
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/separator/create.js
var defaults26 = {
  orientation: "horizontal",
  decorative: false
};
var createSeparator = (props) => {
  const withDefaults = { ...defaults26, ...props };
  const options = toWritableStores(withDefaults);
  const { orientation, decorative } = options;
  const root5 = makeElement("separator", {
    stores: [orientation, decorative],
    returned: ([$orientation, $decorative]) => {
      const ariaOrientation = $orientation === "vertical" ? $orientation : void 0;
      return {
        role: $decorative ? "none" : "separator",
        "aria-orientation": ariaOrientation,
        "aria-hidden": $decorative,
        "data-orientation": $orientation
      };
    }
  });
  return {
    elements: {
      root: root5
    },
    options
  };
};

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/slider/create.js
var defaults27 = {
  defaultValue: [],
  min: 0,
  max: 100,
  step: 1,
  orientation: "horizontal",
  dir: "ltr",
  disabled: false
};
var { name: name18 } = createElHelpers("slider");
var createSlider = (props) => {
  const withDefaults = { ...defaults27, ...props };
  const options = toWritableStores(omit(withDefaults, "value", "onValueChange", "defaultValue"));
  const { min, max, step, orientation, dir, disabled } = options;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  const isActive = withGet(writable(false));
  const currentThumbIndex = withGet(writable(0));
  const activeThumb = withGet(writable(null));
  const meltIds = generateIds(["root"]);
  const updatePosition = (val, index) => {
    value.update((prev2) => {
      if (!prev2)
        return [val];
      if (prev2[index] === val)
        return prev2;
      const newValue = [...prev2];
      const direction2 = newValue[index] > val ? -1 : 1;
      function swap() {
        newValue[index] = newValue[index + direction2];
        newValue[index + direction2] = val;
        const thumbs2 = getAllThumbs();
        if (thumbs2) {
          thumbs2[index + direction2].focus();
          activeThumb.set({ thumb: thumbs2[index + direction2], index: index + direction2 });
        }
      }
      if (direction2 === -1 && val < newValue[index - 1]) {
        swap();
        return newValue;
      } else if (direction2 === 1 && val > newValue[index + 1]) {
        swap();
        return newValue;
      }
      const $min = min.get();
      const $max = max.get();
      const $step = step.get();
      newValue[index] = snapValueToStep(val, $min, $max, $step);
      return newValue;
    });
  };
  const getAllThumbs = () => {
    const root6 = getElementByMeltId(meltIds.root);
    if (!root6)
      return null;
    return Array.from(root6.querySelectorAll('[data-melt-part="thumb"]')).filter((thumb) => isHTMLElement(thumb));
  };
  const position = derived([min, max], ([$min, $max]) => {
    return (val) => {
      const pos = (val - $min) / ($max - $min) * 100;
      return pos;
    };
  });
  const direction = withGet.derived([orientation, dir], ([$orientation, $dir]) => {
    if ($orientation === "horizontal") {
      return $dir === "rtl" ? "rl" : "lr";
    } else {
      return $dir === "rtl" ? "tb" : "bt";
    }
  });
  const root5 = makeElement(name18(), {
    stores: [disabled, orientation, dir],
    returned: ([$disabled, $orientation, $dir]) => {
      return {
        dir: $dir,
        disabled: disabledAttr($disabled),
        "data-disabled": disabledAttr($disabled),
        "data-orientation": $orientation,
        style: $disabled ? void 0 : `touch-action: ${$orientation === "horizontal" ? "pan-y" : "pan-x"}`,
        "data-melt-id": meltIds.root
      };
    }
  });
  const range = makeElement(name18("range"), {
    stores: [value, direction, position],
    returned: ([$value, $direction, $position]) => {
      const minimum = $value.length > 1 ? $position(Math.min(...$value) ?? 0) : 0;
      const maximum = 100 - $position(Math.max(...$value) ?? 0);
      const style = {
        position: "absolute"
      };
      switch ($direction) {
        case "lr": {
          style.left = `${minimum}%`;
          style.right = `${maximum}%`;
          break;
        }
        case "rl": {
          style.right = `${minimum}%`;
          style.left = `${maximum}%`;
          break;
        }
        case "bt": {
          style.bottom = `${minimum}%`;
          style.top = `${maximum}%`;
          break;
        }
        case "tb": {
          style.top = `${minimum}%`;
          style.bottom = `${maximum}%`;
          break;
        }
      }
      return {
        style: styleToString(style)
      };
    }
  });
  const thumbs = makeElementArray(name18("thumb"), {
    stores: [value, position, min, max, disabled, orientation, direction],
    returned: ([$value, $position, $min, $max, $disabled, $orientation, $direction]) => {
      const result = Array.from({ length: $value.length || 1 }, (_, i) => {
        const currentThumb = currentThumbIndex.get();
        if (currentThumb < $value.length) {
          currentThumbIndex.update((prev2) => prev2 + 1);
        }
        const thumbValue = $value[i];
        const thumbPosition = `${$position(thumbValue)}%`;
        const style = {
          position: "absolute"
        };
        switch ($direction) {
          case "lr": {
            style.left = thumbPosition;
            style.translate = "-50% 0";
            break;
          }
          case "rl": {
            style.right = thumbPosition;
            style.translate = "50% 0";
            break;
          }
          case "bt": {
            style.bottom = thumbPosition;
            style.translate = "0 50%";
            break;
          }
          case "tb": {
            style.top = thumbPosition;
            style.translate = "0 -50%";
            break;
          }
        }
        return {
          role: "slider",
          "aria-valuemin": $min,
          "aria-valuemax": $max,
          "aria-valuenow": thumbValue,
          "aria-disabled": disabledAttr($disabled),
          "aria-orientation": $orientation,
          "data-melt-part": "thumb",
          "data-value": thumbValue,
          style: styleToString(style),
          tabindex: $disabled ? -1 : 0
        };
      });
      return result;
    },
    action: (node) => {
      const unsub = addMeltEventListener(node, "keydown", (event2) => {
        if (disabled.get())
          return;
        const target = event2.currentTarget;
        if (!isHTMLElement(target))
          return;
        const thumbs2 = getAllThumbs();
        if (!(thumbs2 == null ? void 0 : thumbs2.length))
          return;
        const index = thumbs2.indexOf(target);
        currentThumbIndex.set(index);
        if (![
          kbd.ARROW_LEFT,
          kbd.ARROW_RIGHT,
          kbd.ARROW_UP,
          kbd.ARROW_DOWN,
          kbd.HOME,
          kbd.END
        ].includes(event2.key)) {
          return;
        }
        event2.preventDefault();
        const $min = min.get();
        const $max = max.get();
        const $step = step.get();
        const $value = value.get();
        const $orientation = orientation.get();
        const $direction = direction.get();
        const thumbValue = $value[index];
        switch (event2.key) {
          case kbd.HOME: {
            updatePosition($min, index);
            break;
          }
          case kbd.END: {
            updatePosition($max, index);
            break;
          }
          case kbd.ARROW_LEFT: {
            if ($orientation !== "horizontal")
              break;
            if (event2.metaKey) {
              const newValue = $direction === "rl" ? $max : $min;
              updatePosition(newValue, index);
            } else if ($direction === "rl" && thumbValue < $max) {
              updatePosition(thumbValue + $step, index);
            } else if ($direction === "lr" && thumbValue > $min) {
              updatePosition(thumbValue - $step, index);
            }
            break;
          }
          case kbd.ARROW_RIGHT: {
            if ($orientation !== "horizontal")
              break;
            if (event2.metaKey) {
              const newValue = $direction === "rl" ? $min : $max;
              updatePosition(newValue, index);
            } else if ($direction === "rl" && thumbValue > $min) {
              updatePosition(thumbValue - $step, index);
            } else if ($direction === "lr" && thumbValue < $max) {
              updatePosition(thumbValue + $step, index);
            }
            break;
          }
          case kbd.ARROW_UP: {
            if (event2.metaKey) {
              const newValue = $direction === "tb" ? $min : $max;
              updatePosition(newValue, index);
            } else if ($direction === "tb" && thumbValue > $min) {
              updatePosition(thumbValue - $step, index);
            } else if ($direction !== "tb" && thumbValue < $max) {
              updatePosition(thumbValue + $step, index);
            }
            break;
          }
          case kbd.ARROW_DOWN: {
            if (event2.metaKey) {
              const newValue = $direction === "tb" ? $max : $min;
              updatePosition(newValue, index);
            } else if ($direction === "tb" && thumbValue < $max) {
              updatePosition(thumbValue + $step, index);
            } else if ($direction !== "tb" && thumbValue > $min) {
              updatePosition(thumbValue - $step, index);
            }
            break;
          }
        }
      });
      return {
        destroy: unsub
      };
    }
  });
  const ticks = makeElementArray(name18("tick"), {
    stores: [value, min, max, step, direction],
    returned: ([$value, $min, $max, $step, $direction]) => {
      const difference = $max - $min;
      let count = Math.ceil(difference / $step);
      if (difference % $step == 0) {
        count++;
      }
      return Array.from({ length: count }, (_, i) => {
        const tickPosition = `${i * ($step / ($max - $min)) * 100}%`;
        const isFirst = i === 0;
        const isLast = i === count - 1;
        const offsetPercentage = isFirst ? 0 : isLast ? -100 : -50;
        const style = {
          position: "absolute"
        };
        switch ($direction) {
          case "lr": {
            style.left = tickPosition;
            style.translate = `${offsetPercentage}% 0`;
            break;
          }
          case "rl": {
            style.right = tickPosition;
            style.translate = `${-offsetPercentage}% 0`;
            break;
          }
          case "bt": {
            style.bottom = tickPosition;
            style.translate = `0 ${-offsetPercentage}%`;
            break;
          }
          case "tb": {
            style.top = tickPosition;
            style.translate = `0 ${offsetPercentage}%`;
            break;
          }
        }
        const tickValue = $min + i * $step;
        const bounded = $value.length === 1 ? tickValue <= $value[0] : $value[0] <= tickValue && tickValue <= $value[$value.length - 1];
        return {
          "data-bounded": bounded ? true : void 0,
          "data-value": tickValue,
          style: styleToString(style)
        };
      });
    }
  });
  effect([root5, min, max, disabled, orientation, direction, step], ([$root, $min, $max, $disabled, $orientation, $direction, $step]) => {
    if (!isBrowser || $disabled)
      return;
    const applyPosition = (clientXY, activeThumbIdx, start, end) => {
      const percent = (clientXY - start) / (end - start);
      const val = percent * ($max - $min) + $min;
      if (val < $min) {
        updatePosition($min, activeThumbIdx);
      } else if (val > $max) {
        updatePosition($max, activeThumbIdx);
      } else {
        const step2 = $step;
        const min2 = $min;
        const currentStep = Math.floor((val - min2) / step2);
        const midpointOfCurrentStep = min2 + currentStep * step2 + step2 / 2;
        const midpointOfNextStep = min2 + (currentStep + 1) * step2 + step2 / 2;
        const newValue = val >= midpointOfCurrentStep && val < midpointOfNextStep ? (currentStep + 1) * step2 + min2 : currentStep * step2 + min2;
        if (newValue <= $max) {
          updatePosition(newValue, activeThumbIdx);
        }
      }
    };
    const getClosestThumb = (e) => {
      const thumbs2 = getAllThumbs();
      if (!thumbs2)
        return;
      thumbs2.forEach((thumb2) => thumb2.blur());
      const distances = thumbs2.map((thumb2) => {
        if ($orientation === "horizontal") {
          const { left, right } = thumb2.getBoundingClientRect();
          return Math.abs(e.clientX - (left + right) / 2);
        } else {
          const { top, bottom } = thumb2.getBoundingClientRect();
          return Math.abs(e.clientY - (top + bottom) / 2);
        }
      });
      const thumb = thumbs2[distances.indexOf(Math.min(...distances))];
      const index = thumbs2.indexOf(thumb);
      return { thumb, index };
    };
    const pointerMove = (e) => {
      if (!isActive.get())
        return;
      e.preventDefault();
      e.stopPropagation();
      const sliderEl = getElementByMeltId($root["data-melt-id"]);
      const closestThumb = activeThumb.get();
      if (!sliderEl || !closestThumb)
        return;
      closestThumb.thumb.focus();
      const { left, right, top, bottom } = sliderEl.getBoundingClientRect();
      switch ($direction) {
        case "lr": {
          applyPosition(e.clientX, closestThumb.index, left, right);
          break;
        }
        case "rl": {
          applyPosition(e.clientX, closestThumb.index, right, left);
          break;
        }
        case "bt": {
          applyPosition(e.clientY, closestThumb.index, bottom, top);
          break;
        }
        case "tb": {
          applyPosition(e.clientY, closestThumb.index, top, bottom);
          break;
        }
      }
    };
    const pointerDown = (e) => {
      if (e.button !== 0)
        return;
      const sliderEl = getElementByMeltId($root["data-melt-id"]);
      const closestThumb = getClosestThumb(e);
      if (!closestThumb || !sliderEl)
        return;
      const target = e.target;
      if (!isHTMLElement(target) || !sliderEl.contains(target)) {
        return;
      }
      e.preventDefault();
      activeThumb.set(closestThumb);
      closestThumb.thumb.focus();
      isActive.set(true);
      pointerMove(e);
    };
    const pointerUp = () => {
      isActive.set(false);
    };
    const unsub = executeCallbacks(addEventListener(document, "pointerdown", pointerDown), addEventListener(document, "pointerup", pointerUp), addEventListener(document, "pointerleave", pointerUp), addEventListener(document, "pointermove", pointerMove));
    return () => {
      unsub();
    };
  });
  effect([step, min, max, value], function fixValue([$step, $min, $max, $value]) {
    const isValidValue = (v) => {
      const snappedValue = snapValueToStep(v, $min, $max, $step);
      return snappedValue === v;
    };
    const gcv = (v) => {
      return snapValueToStep(v, $min, $max, $step);
    };
    if ($value.some((v) => !isValidValue(v))) {
      value.update((prev2) => {
        return prev2.map(gcv);
      });
    }
  });
  return {
    elements: {
      root: root5,
      thumbs,
      range,
      ticks
    },
    states: {
      value
    },
    options
  };
};

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/switch/create.js
var defaults28 = {
  defaultChecked: false,
  disabled: false,
  required: false,
  name: "",
  value: ""
};
var { name: name19 } = createElHelpers("switch");
function createSwitch(props) {
  const propsWithDefaults = { ...defaults28, ...props };
  const options = toWritableStores(omit(propsWithDefaults, "checked"));
  const { disabled, required, name: nameStore, value } = options;
  const checkedWritable = propsWithDefaults.checked ?? writable(propsWithDefaults.defaultChecked);
  const checked = overridable(checkedWritable, propsWithDefaults == null ? void 0 : propsWithDefaults.onCheckedChange);
  function toggleSwitch() {
    if (disabled.get())
      return;
    checked.update((prev2) => !prev2);
  }
  const root5 = makeElement(name19(), {
    stores: [checked, disabled, required],
    returned: ([$checked, $disabled, $required]) => {
      return {
        "data-disabled": disabledAttr($disabled),
        disabled: disabledAttr($disabled),
        "data-state": $checked ? "checked" : "unchecked",
        type: "button",
        role: "switch",
        "aria-checked": $checked ? "true" : "false",
        "aria-required": $required ? "true" : void 0
      };
    },
    action(node) {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        toggleSwitch();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)
          return;
        e.preventDefault();
        toggleSwitch();
      }));
      return {
        destroy: unsub
      };
    }
  });
  const input = makeElement(name19("input"), {
    stores: [checked, nameStore, required, disabled, value],
    returned: ([$checked, $name, $required, $disabled, $value]) => {
      return {
        type: "checkbox",
        "aria-hidden": true,
        hidden: true,
        tabindex: -1,
        name: $name,
        value: $value,
        checked: $checked,
        required: $required,
        disabled: disabledAttr($disabled),
        style: styleToString({
          position: "absolute",
          opacity: 0,
          "pointer-events": "none",
          margin: 0,
          transform: "translateX(-100%)"
        })
      };
    }
  });
  return {
    elements: {
      root: root5,
      input
    },
    states: {
      checked
    },
    options
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/tabs/create.js
var defaults29 = {
  orientation: "horizontal",
  activateOnFocus: true,
  loop: true,
  autoSet: true
};
var { name: name20, selector: selector6 } = createElHelpers("tabs");
function createTabs(props) {
  const withDefaults = { ...defaults29, ...props };
  const options = toWritableStores(omit(withDefaults, "defaultValue", "value", "onValueChange", "autoSet"));
  const { orientation, activateOnFocus, loop } = options;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  let ssrValue = withDefaults.defaultValue ?? value.get();
  const root5 = makeElement(name20(), {
    stores: orientation,
    returned: ($orientation) => {
      return {
        "data-orientation": $orientation
      };
    }
  });
  const list = makeElement(name20("list"), {
    stores: orientation,
    returned: ($orientation) => {
      return {
        role: "tablist",
        "aria-orientation": $orientation,
        "data-orientation": $orientation
      };
    }
  });
  const parseTriggerProps = (props2) => {
    if (typeof props2 === "string") {
      return { value: props2 };
    } else {
      return props2;
    }
  };
  const trigger = makeElement(name20("trigger"), {
    stores: [value, orientation],
    returned: ([$value, $orientation]) => {
      return (props2) => {
        const { value: tabValue, disabled } = parseTriggerProps(props2);
        if (!$value && !ssrValue && withDefaults.autoSet) {
          ssrValue = tabValue;
          $value = tabValue;
          value.set(tabValue);
        }
        const sourceOfTruth = isBrowser ? $value : ssrValue;
        const isActive = sourceOfTruth === tabValue;
        return {
          type: "button",
          role: "tab",
          "data-state": isActive ? "active" : "inactive",
          tabindex: isActive ? 0 : -1,
          "data-value": tabValue,
          "data-orientation": $orientation,
          "data-disabled": disabledAttr(disabled),
          disabled: disabledAttr(disabled)
        };
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "focus", () => {
        const disabled = node.dataset.disabled === "true";
        const tabValue = node.dataset.value;
        if (activateOnFocus.get() && !disabled && tabValue !== void 0) {
          value.set(tabValue);
        }
      }), addMeltEventListener(node, "click", (e) => {
        node.focus();
        e.preventDefault();
        const disabled = node.dataset.disabled === "true";
        if (disabled)
          return;
        const tabValue = node.dataset.value;
        node.focus();
        if (tabValue !== void 0) {
          value.set(tabValue);
        }
      }), addMeltEventListener(node, "keydown", (e) => {
        const tabValue = node.dataset.value;
        if (!tabValue)
          return;
        const el = e.currentTarget;
        if (!isHTMLElement(el))
          return;
        const rootEl = el.closest(selector6());
        if (!isHTMLElement(rootEl))
          return;
        const $loop = loop.get();
        const triggers = Array.from(rootEl.querySelectorAll('[role="tab"]')).filter((trigger2) => isHTMLElement(trigger2));
        const enabledTriggers = triggers.filter((el2) => !el2.hasAttribute("data-disabled"));
        const triggerIdx = enabledTriggers.findIndex((el2) => el2 === e.target);
        const dir = getElemDirection(rootEl);
        const { nextKey, prevKey } = getDirectionalKeys(dir, orientation.get());
        if (e.key === nextKey) {
          e.preventDefault();
          const nextEl = next(enabledTriggers, triggerIdx, $loop);
          nextEl.focus();
        } else if (e.key === prevKey) {
          e.preventDefault();
          const prevEl = prev(enabledTriggers, triggerIdx, $loop);
          prevEl.focus();
        } else if (e.key === kbd.ENTER || e.key === kbd.SPACE) {
          e.preventDefault();
          value.set(tabValue);
        } else if (e.key === kbd.HOME) {
          e.preventDefault();
          const firstTrigger = enabledTriggers[0];
          firstTrigger.focus();
        } else if (e.key === kbd.END) {
          e.preventDefault();
          const lastTrigger = last(enabledTriggers);
          lastTrigger.focus();
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const content = makeElement(name20("content"), {
    stores: value,
    returned: ($value) => {
      return (tabValue) => {
        return {
          role: "tabpanel",
          // TODO: improve
          "aria-labelledby": tabValue,
          hidden: isBrowser ? $value === tabValue ? void 0 : true : ssrValue === tabValue ? void 0 : true,
          tabindex: 0
        };
      };
    }
  });
  return {
    elements: {
      root: root5,
      list,
      trigger,
      content
    },
    states: {
      value
    },
    options
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/tags-input/create.js
var { name: name21, attribute, selector: selector7 } = createElHelpers("tags-input");

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/toast/create.js
var { name: name22 } = createElHelpers("toast");

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/toggle/create.js
var defaults30 = {
  defaultPressed: false,
  disabled: false
};
function createToggle(props) {
  const withDefaults = { ...defaults30, ...props };
  const options = toWritableStores(omit(withDefaults, "pressed"));
  const { disabled } = options;
  const pressedWritable = withDefaults.pressed ?? writable(withDefaults.defaultPressed);
  const pressed = overridable(pressedWritable, withDefaults == null ? void 0 : withDefaults.onPressedChange);
  function handleToggle() {
    const $disabled = disabled.get();
    if ($disabled)
      return;
    pressed.update((v) => !v);
  }
  const root5 = makeElement("toggle", {
    stores: [pressed, disabled],
    returned: ([$pressed, $disabled]) => {
      return {
        "data-disabled": disabledAttr($disabled),
        disabled: disabledAttr($disabled),
        "data-state": $pressed ? "on" : "off",
        "aria-pressed": $pressed,
        type: "button"
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        handleToggle();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)
          return;
        e.preventDefault();
        handleToggle();
      }));
      return {
        destroy: unsub
      };
    }
  });
  return {
    elements: {
      root: root5
    },
    states: {
      pressed
    },
    options
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/toggle-group/create.js
var defaults31 = {
  type: "single",
  orientation: "horizontal",
  loop: true,
  rovingFocus: true,
  disabled: false,
  defaultValue: ""
};
var { name: name23, selector: selector8 } = createElHelpers("toggle-group");
var createToggleGroup = (props) => {
  const withDefaults = { ...defaults31, ...props };
  const options = toWritableStores(omit(withDefaults, "value"));
  const { type, orientation, loop, rovingFocus, disabled } = options;
  const defaultValue = withDefaults.defaultValue ? withDefaults.defaultValue : withDefaults.type === "single" ? void 0 : [];
  const valueWritable = withDefaults.value ?? writable(defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  const root5 = makeElement(name23(), {
    stores: orientation,
    returned: ($orientation) => {
      return {
        role: "group",
        "data-orientation": $orientation
      };
    }
  });
  const item = makeElement(name23("item"), {
    stores: [value, disabled, orientation, type],
    returned: ([$value, $disabled, $orientation, $type]) => {
      return (props2) => {
        const itemValue = typeof props2 === "string" ? props2 : props2.value;
        const argDisabled = typeof props2 === "string" ? false : !!props2.disabled;
        const disabled2 = $disabled || argDisabled;
        const pressed = Array.isArray($value) ? $value.includes(itemValue) : $value === itemValue;
        const isSingle = $type === "single";
        const isMultiple = $type === "multiple" || $type === void 0;
        return {
          disabled: disabledAttr(disabled2),
          pressed,
          "data-orientation": $orientation,
          "data-disabled": disabledAttr(disabled2),
          "data-state": pressed ? "on" : "off",
          "data-value": itemValue,
          "aria-pressed": isMultiple ? pressed : void 0,
          "aria-checked": isSingle ? pressed : void 0,
          type: "button",
          role: isSingle ? "radio" : void 0,
          tabindex: pressed ? 0 : -1
        };
      };
    },
    action: (node) => {
      let unsub = noop;
      const parentGroup = node.closest(selector8());
      if (!isHTMLElement(parentGroup))
        return {};
      const items = Array.from(parentGroup.querySelectorAll(selector8("item")));
      const $value = value.get();
      const anyPressed = Array.isArray($value) ? $value.length > 0 : $value ? true : false;
      if (!anyPressed && items[0] === node) {
        node.tabIndex = 0;
      }
      function getNodeProps() {
        const itemValue = node.dataset.value;
        const disabled2 = node.dataset.disabled === "true";
        return { value: itemValue, disabled: disabled2 };
      }
      function handleValueUpdate() {
        const { value: itemValue, disabled: disabled2 } = getNodeProps();
        if (itemValue === void 0 || disabled2)
          return;
        value.update(($value2) => {
          if (Array.isArray($value2)) {
            if ($value2.includes(itemValue)) {
              return $value2.filter((i) => i !== itemValue);
            }
            return [...$value2, itemValue];
          }
          return $value2 === itemValue ? void 0 : itemValue;
        });
      }
      unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        handleValueUpdate();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key === kbd.SPACE || e.key === kbd.ENTER) {
          e.preventDefault();
          handleValueUpdate();
          return;
        }
        if (!rovingFocus.get())
          return;
        const el = e.currentTarget;
        if (!isHTMLElement(el))
          return;
        const root6 = el.closest(selector8());
        if (!isHTMLElement(root6))
          return;
        const items2 = Array.from(root6.querySelectorAll(selector8("item") + ":not([data-disabled])")).filter((item2) => isHTMLElement(item2));
        const currentIndex = items2.indexOf(el);
        const dir = getElemDirection(el);
        const $orientation = orientation.get();
        const nextKey = {
          horizontal: dir === "rtl" ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,
          vertical: kbd.ARROW_DOWN
        }[$orientation ?? "horizontal"];
        const prevKey = {
          horizontal: dir === "rtl" ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,
          vertical: kbd.ARROW_UP
        }[$orientation ?? "horizontal"];
        const $loop = loop.get();
        if (e.key === nextKey) {
          e.preventDefault();
          const nextIndex = currentIndex + 1;
          if (nextIndex >= items2.length && $loop) {
            handleRovingFocus(items2[0]);
          } else {
            handleRovingFocus(items2[nextIndex]);
          }
        } else if (e.key === prevKey) {
          e.preventDefault();
          const prevIndex = currentIndex - 1;
          if (prevIndex < 0 && $loop) {
            handleRovingFocus(items2[items2.length - 1]);
          } else {
            handleRovingFocus(items2[prevIndex]);
          }
        } else if (e.key === kbd.HOME) {
          e.preventDefault();
          handleRovingFocus(items2[0]);
        } else if (e.key === kbd.END) {
          e.preventDefault();
          handleRovingFocus(items2[items2.length - 1]);
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const isPressed = derived(value, ($value) => {
    return (itemValue) => {
      return Array.isArray($value) ? $value.includes(itemValue) : $value === itemValue;
    };
  });
  return {
    elements: {
      root: root5,
      item
    },
    states: {
      value
    },
    helpers: {
      isPressed
    },
    options
  };
};

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/toolbar/create.js
var defaults32 = {
  loop: true,
  orientation: "horizontal"
};
var { name: name24, selector: selector9 } = createElHelpers("toolbar");
var createToolbar = (props) => {
  const withDefaults = { ...defaults32, ...props };
  const options = toWritableStores(withDefaults);
  const { loop, orientation } = options;
  const root5 = makeElement(name24(), {
    stores: orientation,
    returned: ($orientation) => {
      return {
        role: "toolbar",
        "data-orientation": $orientation
      };
    }
  });
  const button = makeElement(name24("button"), {
    returned: () => ({
      role: "button",
      type: "button"
    }),
    action: (node) => {
      setNodeTabIndex(node);
      const unsub = addMeltEventListener(node, "keydown", handleKeyDown);
      return {
        destroy: unsub
      };
    }
  });
  const link = makeElement(name24("link"), {
    returned: () => ({
      role: "link"
    }),
    action: (node) => {
      setNodeTabIndex(node);
      const unsub = addMeltEventListener(node, "keydown", handleKeyDown);
      return {
        destroy: unsub
      };
    }
  });
  const separator = makeElement(name24("separator"), {
    stores: orientation,
    returned: ($orientation) => {
      return {
        role: "separator",
        "data-orientation": $orientation === "horizontal" ? "vertical" : "horizontal",
        "aria-orientation": $orientation === "horizontal" ? "vertical" : "horizontal"
      };
    }
  });
  const groupDefaults = {
    type: "single",
    disabled: false
  };
  const createToolbarGroup = (props2) => {
    const groupWithDefaults = { ...groupDefaults, ...props2 };
    const options2 = toWritableStores(groupWithDefaults);
    const { type, disabled } = options2;
    const defaultValue = groupWithDefaults.defaultValue ? groupWithDefaults.defaultValue : groupWithDefaults.type === "single" ? void 0 : [];
    const valueWritable = groupWithDefaults.value ?? writable(defaultValue);
    const value = overridable(valueWritable, groupWithDefaults == null ? void 0 : groupWithDefaults.onValueChange);
    const { name: name27 } = createElHelpers("toolbar-group");
    const group = makeElement(name27(), {
      stores: orientation,
      returned: ($orientation) => {
        return {
          role: "group",
          "data-orientation": $orientation
        };
      }
    });
    const item = makeElement(name27("item"), {
      stores: [disabled, type, value, orientation],
      returned: ([$disabled, $type, $value, $orientation]) => {
        return (props3) => {
          const itemValue = typeof props3 === "string" ? props3 : props3.value;
          const argDisabled = typeof props3 === "string" ? false : !!props3.disabled;
          const disabled2 = $disabled || argDisabled;
          const pressed = Array.isArray($value) ? $value.includes(itemValue) : $value === itemValue;
          const isSingle = $type === "single";
          const isMultiple = $type === "multiple";
          return {
            disabled: disabledAttr(disabled2),
            pressed,
            "data-orientation": $orientation,
            "data-disabled": disabledAttr(disabled2),
            "data-value": itemValue,
            "data-state": pressed ? "on" : "off",
            "aria-checked": isSingle ? pressed : void 0,
            "aria-pressed": isMultiple ? pressed : void 0,
            type: "button",
            role: isSingle ? "radio" : void 0,
            "data-melt-toolbar-item": ""
          };
        };
      },
      action: (node) => {
        setNodeTabIndex(node);
        function getNodeProps() {
          const itemValue = node.dataset.value;
          const disabled2 = node.dataset.disabled === "true";
          return { value: itemValue, disabled: disabled2 };
        }
        function handleValueUpdate() {
          const { value: itemValue, disabled: disabled2 } = getNodeProps();
          if (itemValue === void 0 || disabled2)
            return;
          value.update(($value) => {
            if (Array.isArray($value)) {
              if ($value.includes(itemValue)) {
                return $value.filter((i) => i !== itemValue);
              }
              $value.push(itemValue);
              return $value;
            }
            return $value === itemValue ? void 0 : itemValue;
          });
        }
        const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
          handleValueUpdate();
        }), addMeltEventListener(node, "keydown", (e) => {
          if (e.key === kbd.ENTER || e.key === kbd.SPACE) {
            e.preventDefault();
            handleValueUpdate();
            return;
          }
          handleKeyDown(e);
        }));
        return {
          destroy: unsub
        };
      }
    });
    const isPressed = derived(value, ($value) => {
      return (itemValue) => {
        return Array.isArray($value) ? $value.includes(itemValue) : $value === itemValue;
      };
    });
    return {
      elements: {
        group,
        item
      },
      states: {
        value
      },
      helpers: {
        isPressed
      },
      options: options2
    };
  };
  function handleKeyDown(e) {
    const $orientation = orientation.get();
    const $loop = loop.get();
    const dir = "ltr";
    const nextKey = {
      horizontal: dir === "rtl" ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,
      vertical: kbd.ARROW_DOWN
    }[$orientation ?? "horizontal"];
    const prevKey = {
      horizontal: dir === "rtl" ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,
      vertical: kbd.ARROW_UP
    }[$orientation ?? "horizontal"];
    const el = e.currentTarget;
    if (!isHTMLElement(el))
      return;
    const root6 = el.closest("[data-melt-toolbar]");
    if (!isHTMLElement(root6))
      return;
    const items = getToolbarItems(root6);
    const currentIndex = items.indexOf(el);
    if (e.key === nextKey) {
      e.preventDefault();
      const nextIndex = currentIndex + 1;
      if (nextIndex >= items.length && $loop) {
        handleRovingFocus(items[0]);
      } else {
        handleRovingFocus(items[nextIndex]);
      }
    } else if (e.key === prevKey) {
      e.preventDefault();
      const prevIndex = currentIndex - 1;
      if (prevIndex < 0 && $loop) {
        handleRovingFocus(items[items.length - 1]);
      } else {
        handleRovingFocus(items[prevIndex]);
      }
    } else if (e.key === kbd.HOME) {
      e.preventDefault();
      handleRovingFocus(items[0]);
    } else if (e.key === kbd.END) {
      e.preventDefault();
      handleRovingFocus(items[items.length - 1]);
    }
  }
  return {
    elements: {
      root: root5,
      button,
      separator,
      link
    },
    builders: {
      createToolbarGroup
    },
    options
  };
};
function setNodeTabIndex(node) {
  const parentToolbar = node.closest("[data-melt-toolbar]");
  if (!isHTMLElement(parentToolbar))
    return;
  const items = getToolbarItems(parentToolbar);
  if (items[0] === node) {
    node.tabIndex = 0;
  } else {
    node.tabIndex = -1;
  }
}
function getToolbarItems(element2) {
  return Array.from(element2.querySelectorAll(`${selector9("item")}, ${selector9("button")}, ${selector9("link")}`)).filter((el) => isHTMLElement(el));
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/tooltip/create.js
var defaults33 = {
  positioning: {
    placement: "bottom"
  },
  arrowSize: 8,
  defaultOpen: false,
  closeOnPointerDown: true,
  openDelay: 1e3,
  closeDelay: 0,
  forceVisible: false,
  portal: void 0,
  closeOnEscape: true,
  disableHoverableContent: false,
  group: void 0
};
var { name: name25 } = createElHelpers("tooltip");
var groupMap = /* @__PURE__ */ new Map();
var tooltipIdParts = ["trigger", "content"];
function createTooltip(props) {
  const withDefaults = { ...defaults33, ...props };
  const options = toWritableStores(omit(withDefaults, "open", "ids"));
  const { positioning, arrowSize, closeOnPointerDown, openDelay, closeDelay, forceVisible, portal, closeOnEscape, disableHoverableContent, group } = options;
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const openReason = writable(null);
  const ids = toWritableStores({ ...generateIds(tooltipIdParts), ...withDefaults.ids });
  let clickedTrigger = false;
  const getEl = (part) => {
    if (!isBrowser)
      return null;
    return document.getElementById(ids[part].get());
  };
  let openTimeout = null;
  let closeTimeout = null;
  function openTooltip(reason) {
    if (closeTimeout) {
      window.clearTimeout(closeTimeout);
      closeTimeout = null;
    }
    if (!openTimeout) {
      openTimeout = window.setTimeout(() => {
        open.set(true);
        openReason.update((prev2) => prev2 ?? reason);
        openTimeout = null;
      }, openDelay.get());
    }
  }
  function closeTooltip(isBlur) {
    if (openTimeout) {
      window.clearTimeout(openTimeout);
      openTimeout = null;
    }
    if (isBlur && isMouseInTooltipArea) {
      openReason.set("pointer");
      return;
    }
    if (!closeTimeout) {
      closeTimeout = window.setTimeout(() => {
        open.set(false);
        openReason.set(null);
        if (isBlur)
          clickedTrigger = false;
        closeTimeout = null;
      }, closeDelay.get());
    }
  }
  const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => {
    return $open || $forceVisible;
  });
  const trigger = makeElement(name25("trigger"), {
    stores: [ids.content, ids.trigger, open],
    returned: ([$contentId, $triggerId, $open]) => {
      return {
        "aria-describedby": $contentId,
        id: $triggerId,
        "data-state": $open ? "open" : "closed"
      };
    },
    action: (node) => {
      const keydownHandler = (e) => {
        if (closeOnEscape.get() && e.key === kbd.ESCAPE) {
          if (openTimeout) {
            window.clearTimeout(openTimeout);
            openTimeout = null;
          }
          open.set(false);
        }
      };
      const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", () => {
        const $closeOnPointerDown = closeOnPointerDown.get();
        if (!$closeOnPointerDown)
          return;
        open.set(false);
        clickedTrigger = true;
        if (openTimeout) {
          window.clearTimeout(openTimeout);
          openTimeout = null;
        }
      }), addMeltEventListener(node, "pointerenter", (e) => {
        if (isTouch(e))
          return;
        openTooltip("pointer");
      }), addMeltEventListener(node, "pointerleave", (e) => {
        if (isTouch(e))
          return;
        if (openTimeout) {
          window.clearTimeout(openTimeout);
          openTimeout = null;
        }
      }), addMeltEventListener(node, "focus", () => {
        if (clickedTrigger)
          return;
        openTooltip("focus");
      }), addMeltEventListener(node, "blur", () => closeTooltip(true)), addMeltEventListener(node, "keydown", keydownHandler), addEventListener(document, "keydown", keydownHandler));
      return {
        destroy: unsub
      };
    }
  });
  const content = makeElement(name25("content"), {
    stores: [isVisible, open, portal, ids.content],
    returned: ([$isVisible, $open, $portal, $contentId]) => {
      return removeUndefined({
        role: "tooltip",
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: $isVisible ? void 0 : styleToString({ display: "none" }),
        id: $contentId,
        "data-portal": portalAttr($portal),
        "data-state": $open ? "open" : "closed"
      });
    },
    action: (node) => {
      let unsubFloating = noop;
      let unsubPortal = noop;
      const unsubDerived = effect([isVisible, positioning, portal], ([$isVisible, $positioning, $portal]) => {
        unsubPortal();
        unsubFloating();
        const triggerEl = getEl("trigger");
        if (!$isVisible || !triggerEl)
          return;
        tick().then(() => {
          unsubPortal();
          unsubFloating();
          const portalDest = getPortalDestination(node, $portal);
          if (portalDest)
            unsubPortal = usePortal(node, portalDest).destroy;
          unsubFloating = useFloating(triggerEl, node, $positioning).destroy;
        });
      });
      function handleScroll(e) {
        if (!open.get())
          return;
        const target = e.target;
        if (!isElement(target) && !isDocument(target))
          return;
        const triggerEl = getEl("trigger");
        if (triggerEl && target.contains(triggerEl)) {
          closeTooltip();
        }
      }
      const unsubEvents = executeCallbacks(addMeltEventListener(node, "pointerenter", () => openTooltip("pointer")), addMeltEventListener(node, "pointerdown", () => openTooltip("pointer")), addEventListener(window, "scroll", handleScroll, { capture: true }));
      return {
        destroy() {
          unsubEvents();
          unsubPortal();
          unsubFloating();
          unsubDerived();
        }
      };
    }
  });
  const arrow2 = makeElement(name25("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  let isMouseInTooltipArea = false;
  effect(open, ($open) => {
    const currentGroup = group.get();
    if (currentGroup === void 0 || currentGroup === false) {
      return;
    }
    if (!$open) {
      if (groupMap.get(currentGroup) === open) {
        groupMap.delete(currentGroup);
      }
      return;
    }
    const currentOpen = groupMap.get(currentGroup);
    currentOpen == null ? void 0 : currentOpen.set(false);
    groupMap.set(currentGroup, open);
  });
  effect([open, openReason], ([$open, $openReason]) => {
    if (!$open || !isBrowser)
      return;
    return executeCallbacks(addEventListener(document, "mousemove", (e) => {
      const contentEl = getEl("content");
      const triggerEl = getEl("trigger");
      if (!contentEl || !triggerEl)
        return;
      const polygonElements = disableHoverableContent.get() ? [triggerEl] : [triggerEl, contentEl];
      const polygon = makeHullFromElements(polygonElements);
      isMouseInTooltipArea = pointInPolygon({
        x: e.clientX,
        y: e.clientY
      }, polygon);
      if ($openReason !== "pointer")
        return;
      if (!isMouseInTooltipArea) {
        closeTooltip();
      }
    }));
  });
  return {
    ids,
    elements: {
      trigger,
      content,
      arrow: arrow2
    },
    states: { open },
    options
  };
}

// node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/tree/create.js
var { name: name26 } = createElHelpers("tree-view");

// node_modules/bits-ui/dist/internal/attrs.js
function createBitAttrs(bit, parts) {
  const attrs = {};
  parts.forEach((part) => {
    attrs[part] = {
      [`data-${bit}-${part}`]: ""
    };
  });
  return (part) => attrs[part];
}
function disabledAttrs(disabled) {
  return disabled ? { "aria-disabled": "true", "data-disabled": "" } : { "aria-disabled": void 0, "data-disabled": void 0 };
}

// node_modules/bits-ui/dist/internal/events.js
function createDispatcher() {
  const dispatch = createEventDispatcher();
  return (e) => {
    const { originalEvent } = e.detail;
    const { cancelable } = e;
    const type = originalEvent.type;
    const shouldContinue = dispatch(type, { originalEvent, currentTarget: originalEvent.currentTarget }, { cancelable });
    if (!shouldContinue) {
      e.preventDefault();
    }
  };
}

// node_modules/bits-ui/dist/internal/id.js
function generateId2() {
  return nanoid(10);
}

// node_modules/bits-ui/dist/internal/is.js
var isBrowser2 = typeof document !== "undefined";

// node_modules/bits-ui/dist/internal/object.js
function removeUndefined2(obj) {
  const result = {};
  for (const key in obj) {
    const value = obj[key];
    if (value !== void 0) {
      result[key] = value;
    }
  }
  return result;
}

// node_modules/bits-ui/dist/internal/style.js
function styleToString2(style) {
  return Object.keys(style).reduce((str, key) => {
    if (style[key] === void 0)
      return str;
    return `${str}${key}:${style[key]};`;
  }, "");
}
function getSrOnlyStyles() {
  return styleToString2({
    position: "absolute",
    width: "1px",
    height: "1px",
    padding: "0",
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    borderWidth: "0"
  });
}

// node_modules/bits-ui/dist/internal/updater.js
function getOptionUpdater(options) {
  return function(key, value) {
    if (value === void 0)
      return;
    const store = options[key];
    if (store) {
      store.set(value);
    }
  };
}

// node_modules/bits-ui/dist/internal/focus.js
function handleCalendarInitialFocus(calendar) {
  if (!isBrowser2)
    return;
  const selectedDay = calendar.querySelector("[data-selected]");
  if (selectedDay)
    return focusWithoutScroll(selectedDay);
  const today = calendar.querySelector("[data-today]");
  if (today)
    return focusWithoutScroll(today);
  const firstDay = calendar.querySelector("[data-calendar-date]");
  if (firstDay)
    return focusWithoutScroll(firstDay);
}
function focusWithoutScroll(element2) {
  const scrollPosition = {
    x: window.pageXOffset || document.documentElement.scrollLeft,
    y: window.pageYOffset || document.documentElement.scrollTop
  };
  element2.focus();
  window.scrollTo(scrollPosition.x, scrollPosition.y);
}

// node_modules/bits-ui/dist/bits/accordion/ctx.js
function getAccordionData() {
  const NAME = "accordion";
  const ITEM_NAME = "accordion-item";
  const PARTS = ["root", "content", "header", "item", "trigger"];
  return { NAME, ITEM_NAME, PARTS };
}
function setCtx(props) {
  const initAccordion = createAccordion(removeUndefined2(props));
  const { NAME, PARTS } = getAccordionData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const accordion = {
    ...initAccordion,
    getAttrs: getAttrs2,
    updateOption: getOptionUpdater(initAccordion.options)
  };
  setContext(NAME, accordion);
  return accordion;
}
function getCtx() {
  const { NAME } = getAccordionData();
  return getContext(NAME);
}
function setItem(props) {
  const { ITEM_NAME } = getAccordionData();
  setContext(ITEM_NAME, { ...props });
  const ctx = getCtx();
  return { ...ctx, props };
}
function getItemProps() {
  const { ITEM_NAME } = getAccordionData();
  return getContext(ITEM_NAME);
}
function getContent() {
  const ctx = getCtx();
  const { value: props } = getItemProps();
  return {
    ...ctx,
    props
  };
}
function getTrigger() {
  const ctx = getCtx();
  const { value, disabled } = getItemProps();
  return {
    ...ctx,
    props: { value, disabled }
  };
}

// node_modules/bits-ui/dist/internal/arrays.js
function arraysAreEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  return arr1.every((value, index) => value === arr2[index]);
}

// node_modules/bits-ui/dist/bits/accordion/components/accordion.svelte
mark_module_start();
Accordion[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion.svelte";
var root_3 = add_locations(template(`<div><!></div>`), Accordion[FILENAME], [[51, 1]]);
function Accordion($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "multiple",
    "value",
    "onValueChange",
    "disabled",
    "asChild",
    "el"
  ]);
  push($$props, false, Accordion);
  const $$stores = setup_stores();
  const $root = () => (validate_store(root5, "root"), store_get(root5, "$root", $$stores));
  const builder = mutable_source();
  let multiple = prop($$props, "multiple", 0, false);
  let value = prop($$props, "value", 12, () => void 0);
  let onValueChange = prop($$props, "onValueChange", 8, () => void 0);
  let disabled = prop($$props, "disabled", 0, false);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { root: root5 },
    states: { value: localValue },
    updateOption,
    getAttrs: getAttrs2
  } = setCtx({
    multiple: multiple(),
    disabled: disabled(),
    defaultValue: value(),
    onValueChange: ({ next: next2 }) => {
      var _a, _b;
      if (Array.isArray(next2)) {
        if (!Array.isArray(value()) || !arraysAreEqual(value(), next2)) {
          (_a = onValueChange()) == null ? void 0 : _a(next2);
          value(next2);
          return next2;
        }
        return next2;
      }
      if (value() !== next2) {
        (_b = onValueChange()) == null ? void 0 : _b(next2);
        value(next2);
      }
      return next2;
    }
  });
  const attrs = getAttrs2("root");
  legacy_pre_effect(() => deep_read_state(value()), () => {
    value() !== void 0 && localValue.set(Array.isArray(value()) ? [...value()] : value());
  });
  legacy_pre_effect(() => deep_read_state(multiple()), () => {
    updateOption("multiple", multiple());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => $root(), () => {
    set(builder, $root());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_3();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Accordion);
  const filename = Accordion.filename;
  const $$original = Accordion;
  Accordion = hmr(s);
  Accordion.filename = filename;
  Accordion[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var accordion_default = Accordion;
mark_module_end(Accordion);

// node_modules/bits-ui/dist/bits/accordion/components/accordion-item.svelte
mark_module_start();
Accordion_item[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion-item.svelte";
var root_2 = add_locations(template(`<div><!></div>`), Accordion_item[FILENAME], [[22, 1]]);
function Accordion_item($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["value", "disabled", "asChild", "el"]);
  push($$props, false, Accordion_item);
  const $$stores = setup_stores();
  const $item = () => (validate_store(item, "item"), store_get(item, "$item", $$stores));
  const builder = mutable_source();
  let value = prop($$props, "value");
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { item }, props, getAttrs: getAttrs2 } = setItem({ value: value(), disabled: disabled() });
  const attrs = getAttrs2("item");
  legacy_pre_effect(() => $item(), () => {
    set(builder, $item()(props));
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Accordion_item);
  const filename = Accordion_item.filename;
  const $$original = Accordion_item;
  Accordion_item = hmr(s);
  Accordion_item.filename = filename;
  Accordion_item[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var accordion_item_default = Accordion_item;
mark_module_end(Accordion_item);

// node_modules/bits-ui/dist/bits/accordion/components/accordion-header.svelte
mark_module_start();
Accordion_header[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion-header.svelte";
var root_22 = add_locations(template(`<div><!></div>`), Accordion_header[FILENAME], [[20, 1]]);
function Accordion_header($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["level", "asChild", "el"]);
  push($$props, false, Accordion_header);
  const $$stores = setup_stores();
  const $header = () => (validate_store(header, "header"), store_get(header, "$header", $$stores));
  const builder = mutable_source();
  let level = prop($$props, "level", 0, 3);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { heading: header }, getAttrs: getAttrs2 } = getCtx();
  const attrs = getAttrs2("header");
  legacy_pre_effect(
    () => ($header(), deep_read_state(level())),
    () => {
      set(builder, $header()(level()));
    }
  );
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_22();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Accordion_header);
  const filename = Accordion_header.filename;
  const $$original = Accordion_header;
  Accordion_header = hmr(s);
  Accordion_header.filename = filename;
  Accordion_header[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var accordion_header_default = Accordion_header;
mark_module_end(Accordion_header);

// node_modules/bits-ui/dist/bits/accordion/components/accordion-trigger.svelte
mark_module_start();
Accordion_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion-trigger.svelte";
var root_23 = add_locations(template(`<button><!></button>`), Accordion_trigger[FILENAME], [[22, 1]]);
function Accordion_trigger($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Accordion_trigger);
  const $$stores = setup_stores();
  const $trigger = () => (validate_store(trigger, "trigger"), store_get(trigger, "$trigger", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { trigger }, props, getAttrs: getAttrs2 } = getTrigger();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("trigger");
  legacy_pre_effect(() => $trigger(), () => {
    set(builder, $trigger()(props));
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_23();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-keydown", button, dispatch, false);
      event("m-click", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Accordion_trigger);
  const filename = Accordion_trigger.filename;
  const $$original = Accordion_trigger;
  Accordion_trigger = hmr(s);
  Accordion_trigger.filename = filename;
  Accordion_trigger[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var accordion_trigger_default = Accordion_trigger;
mark_module_end(Accordion_trigger);

// node_modules/bits-ui/dist/bits/accordion/components/accordion-content.svelte
mark_module_start();
Accordion_content[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion-content.svelte";
var root_32 = add_locations(template(`<div><!></div>`), Accordion_content[FILENAME], [[27, 1]]);
var root_5 = add_locations(template(`<div><!></div>`), Accordion_content[FILENAME], [[36, 1]]);
var root_7 = add_locations(template(`<div><!></div>`), Accordion_content[FILENAME], [[46, 1]]);
var root_9 = add_locations(template(`<div><!></div>`), Accordion_content[FILENAME], [[50, 1]]);
var root_11 = add_locations(template(`<div><!></div>`), Accordion_content[FILENAME], [[54, 1]]);
function Accordion_content($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "el"
  ]);
  push($$props, false, Accordion_content);
  const $$stores = setup_stores();
  const $content = () => (validate_store(content, "content"), store_get(content, "$content", $$stores));
  const $isSelected = () => (validate_store(isSelected, "isSelected"), store_get(isSelected, "$isSelected", $$stores));
  const builder = mutable_source();
  let transition2 = prop($$props, "transition", 8, () => void 0);
  let transitionConfig = prop($$props, "transitionConfig", 8, () => void 0);
  let inTransition = prop($$props, "inTransition", 8, () => void 0);
  let inTransitionConfig = prop($$props, "inTransitionConfig", 8, () => void 0);
  let outTransition = prop($$props, "outTransition", 8, () => void 0);
  let outTransitionConfig = prop($$props, "outTransitionConfig", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { content },
    helpers: { isSelected },
    props,
    getAttrs: getAttrs2
  } = getContent();
  const attrs = getAttrs2("content");
  legacy_pre_effect(() => $content(), () => {
    set(builder, $content()(props));
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => asChild() && $isSelected()(props),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      if_block(
        node_2,
        () => transition2() && $isSelected()(props),
        ($$anchor3) => {
          var div = root_32();
          bind_this(div, ($$value) => el($$value), () => el());
          transition(3, div, transition2, transitionConfig);
          let attributes;
          var node_3 = child(div);
          slot(
            node_3,
            default_slot($$props),
            {
              get builder() {
                return get2(builder);
              }
            },
            null
          );
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
          action(div, ($$node) => get2(builder).action($$node));
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          if_block(
            node_4,
            () => inTransition() && outTransition() && $isSelected()(props),
            ($$anchor4) => {
              var div_1 = root_5();
              bind_this(div_1, ($$value) => el($$value), () => el());
              transition(1, div_1, inTransition, inTransitionConfig);
              transition(2, div_1, outTransition, outTransitionConfig);
              let attributes_1;
              var node_5 = child(div_1);
              slot(
                node_5,
                default_slot($$props),
                {
                  get builder() {
                    return get2(builder);
                  }
                },
                null
              );
              reset(div_1);
              template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get2(builder), ...$$restProps }, true, ""));
              action(div_1, ($$node) => get2(builder).action($$node));
              append($$anchor4, div_1);
            },
            ($$anchor4) => {
              var fragment_4 = comment();
              var node_6 = first_child(fragment_4);
              if_block(
                node_6,
                () => inTransition() && $isSelected()(props),
                ($$anchor5) => {
                  var div_2 = root_7();
                  bind_this(div_2, ($$value) => el($$value), () => el());
                  transition(1, div_2, inTransition, inTransitionConfig);
                  let attributes_2;
                  var node_7 = child(div_2);
                  slot(
                    node_7,
                    default_slot($$props),
                    {
                      get builder() {
                        return get2(builder);
                      }
                    },
                    null
                  );
                  reset(div_2);
                  template_effect(() => attributes_2 = set_attributes(div_2, attributes_2, { ...get2(builder), ...$$restProps }, true, ""));
                  action(div_2, ($$node) => get2(builder).action($$node));
                  append($$anchor5, div_2);
                },
                ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_8 = first_child(fragment_5);
                  if_block(
                    node_8,
                    () => outTransition() && $isSelected()(props),
                    ($$anchor6) => {
                      var div_3 = root_9();
                      bind_this(div_3, ($$value) => el($$value), () => el());
                      transition(2, div_3, outTransition, outTransitionConfig);
                      let attributes_3;
                      var node_9 = child(div_3);
                      slot(
                        node_9,
                        default_slot($$props),
                        {
                          get builder() {
                            return get2(builder);
                          }
                        },
                        null
                      );
                      reset(div_3);
                      template_effect(() => attributes_3 = set_attributes(div_3, attributes_3, { ...get2(builder), ...$$restProps }, true, ""));
                      action(div_3, ($$node) => get2(builder).action($$node));
                      append($$anchor6, div_3);
                    },
                    ($$anchor6) => {
                      var fragment_6 = comment();
                      var node_10 = first_child(fragment_6);
                      if_block(
                        node_10,
                        () => $isSelected()(props),
                        ($$anchor7) => {
                          var div_4 = root_11();
                          bind_this(div_4, ($$value) => el($$value), () => el());
                          let attributes_4;
                          var node_11 = child(div_4);
                          slot(
                            node_11,
                            default_slot($$props),
                            {
                              get builder() {
                                return get2(builder);
                              }
                            },
                            null
                          );
                          reset(div_4);
                          template_effect(() => attributes_4 = set_attributes(div_4, attributes_4, { ...get2(builder), ...$$restProps }, true, ""));
                          action(div_4, ($$node) => get2(builder).action($$node));
                          append($$anchor7, div_4);
                        },
                        null,
                        true
                      );
                      append($$anchor6, fragment_6);
                    },
                    true
                  );
                  append($$anchor5, fragment_5);
                },
                true
              );
              append($$anchor4, fragment_4);
            },
            true
          );
          append($$anchor3, fragment_3);
        },
        true
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Accordion_content);
  const filename = Accordion_content.filename;
  const $$original = Accordion_content;
  Accordion_content = hmr(s);
  Accordion_content.filename = filename;
  Accordion_content[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var accordion_content_default = Accordion_content;
mark_module_end(Accordion_content);

// node_modules/bits-ui/dist/bits/alert-dialog/index.js
var alert_dialog_exports = {};
__export(alert_dialog_exports, {
  Action: () => alert_dialog_action_default,
  Cancel: () => alert_dialog_cancel_default,
  Content: () => alert_dialog_content_default,
  Description: () => alert_dialog_description_default,
  Overlay: () => alert_dialog_overlay_default,
  Portal: () => alert_dialog_portal_default,
  Root: () => alert_dialog_default,
  Title: () => alert_dialog_title_default,
  Trigger: () => alert_dialog_trigger_default
});

// node_modules/bits-ui/dist/bits/alert-dialog/ctx.js
function getAlertDialogData() {
  const NAME = "alert-dialog";
  const PARTS = [
    "action",
    "cancel",
    "content",
    "description",
    "overlay",
    "portal",
    "title",
    "trigger"
  ];
  return { NAME, PARTS };
}
function setCtx2(props) {
  const { NAME, PARTS } = getAlertDialogData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const initAlertDialog = createDialog({
    ...removeUndefined2(props),
    role: "alertdialog",
    forceVisible: true
  });
  const alertDialog = {
    ...initAlertDialog,
    getAttrs: getAttrs2,
    updateOption: getOptionUpdater(initAlertDialog.options)
  };
  setContext(NAME, alertDialog);
  return {
    ...alertDialog,
    updateOption: getOptionUpdater(alertDialog.options),
    getAttrs: getAttrs2
  };
}
function getCtx2() {
  const { NAME } = getAlertDialogData();
  return getContext(NAME);
}

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog.svelte
mark_module_start();
Alert_dialog[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog.svelte";
function Alert_dialog($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Alert_dialog);
  const $$stores = setup_stores();
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  let preventScroll = prop($$props, "preventScroll", 8, () => void 0);
  let closeOnEscape = prop($$props, "closeOnEscape", 8, () => void 0);
  let closeOnOutsideClick = prop($$props, "closeOnOutsideClick", 0, false);
  let portal = prop($$props, "portal", 8, () => void 0);
  let open = prop($$props, "open", 12, () => void 0);
  let onOpenChange = prop($$props, "onOpenChange", 8, () => void 0);
  let openFocus = prop($$props, "openFocus", 8, () => void 0);
  let closeFocus = prop($$props, "closeFocus", 8, () => void 0);
  let onOutsideClick = prop($$props, "onOutsideClick", 8, () => void 0);
  const {
    states: { open: localOpen },
    updateOption,
    ids
  } = setCtx2({
    closeOnEscape: closeOnEscape(),
    preventScroll: preventScroll(),
    closeOnOutsideClick: closeOnOutsideClick(),
    portal: portal(),
    forceVisible: true,
    defaultOpen: open(),
    openFocus: openFocus(),
    closeFocus: closeFocus(),
    onOutsideClick: onOutsideClick(),
    onOpenChange: ({ next: next2 }) => {
      var _a;
      if (open() !== next2) {
        (_a = onOpenChange()) == null ? void 0 : _a(next2);
        open(next2);
      }
      return next2;
    }
  });
  const idValues = derived([ids.content, ids.description, ids.title], ([$contentId, $descriptionId, $titleId]) => ({
    content: $contentId,
    description: $descriptionId,
    title: $titleId
  }));
  legacy_pre_effect(() => deep_read_state(open()), () => {
    open() !== void 0 && localOpen.set(open());
  });
  legacy_pre_effect(() => deep_read_state(preventScroll()), () => {
    updateOption("preventScroll", preventScroll());
  });
  legacy_pre_effect(() => deep_read_state(closeOnEscape()), () => {
    updateOption("closeOnEscape", closeOnEscape());
  });
  legacy_pre_effect(
    () => deep_read_state(closeOnOutsideClick()),
    () => {
      updateOption("closeOnOutsideClick", closeOnOutsideClick());
    }
  );
  legacy_pre_effect(() => deep_read_state(portal()), () => {
    updateOption("portal", portal());
  });
  legacy_pre_effect(() => deep_read_state(openFocus()), () => {
    updateOption("openFocus", openFocus());
  });
  legacy_pre_effect(() => deep_read_state(closeFocus()), () => {
    updateOption("closeFocus", closeFocus());
  });
  legacy_pre_effect(() => deep_read_state(onOutsideClick()), () => {
    updateOption("onOutsideClick", onOutsideClick());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get ids() {
        return $idValues();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Alert_dialog);
  const filename = Alert_dialog.filename;
  const $$original = Alert_dialog;
  Alert_dialog = hmr(s);
  Alert_dialog.filename = filename;
  Alert_dialog[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var alert_dialog_default = Alert_dialog;
mark_module_end(Alert_dialog);

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-title.svelte
mark_module_start();
Alert_dialog_title[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-title.svelte";
function Alert_dialog_title($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["level", "asChild", "id", "el"]);
  push($$props, false, Alert_dialog_title);
  const $$stores = setup_stores();
  const $title = () => (validate_store(title, "title"), store_get(title, "$title", $$stores));
  const builder = mutable_source();
  let level = prop($$props, "level", 0, "h2");
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { title }, ids, getAttrs: getAttrs2 } = getCtx2();
  const attrs = getAttrs2("title");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.title.set(id());
    }
  });
  legacy_pre_effect(() => $title(), () => {
    set(builder, $title());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      validate_void_dynamic_element(level);
      validate_dynamic_element_tag(level);
      element(
        node_2,
        level,
        false,
        ($$element, $$anchor3) => {
          bind_this($$element, ($$value) => el($$value), () => el());
          let attributes;
          template_effect(() => attributes = set_dynamic_element_attributes($$element, attributes, { ...get2(builder), ...$$restProps }, ""));
          action($$element, ($$node) => get2(builder).action($$node));
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          slot(
            node_3,
            default_slot($$props),
            {
              get builder() {
                return get2(builder);
              }
            },
            null
          );
          append($$anchor3, fragment_3);
        },
        void 0,
        [26, 1]
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Alert_dialog_title);
  const filename = Alert_dialog_title.filename;
  const $$original = Alert_dialog_title;
  Alert_dialog_title = hmr(s);
  Alert_dialog_title.filename = filename;
  Alert_dialog_title[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var alert_dialog_title_default = Alert_dialog_title;
mark_module_end(Alert_dialog_title);

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-action.svelte
mark_module_start();
Alert_dialog_action[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-action.svelte";
var root_24 = add_locations(template(`<button><!></button>`), Alert_dialog_action[FILENAME], [[21, 1]]);
function Alert_dialog_action($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Alert_dialog_action);
  const $$stores = setup_stores();
  const $close = () => (validate_store(close, "close"), store_get(close, "$close", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { close }, getAttrs: getAttrs2 } = getCtx2();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("action");
  legacy_pre_effect(() => $close(), () => {
    set(builder, $close());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_24();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Alert_dialog_action);
  const filename = Alert_dialog_action.filename;
  const $$original = Alert_dialog_action;
  Alert_dialog_action = hmr(s);
  Alert_dialog_action.filename = filename;
  Alert_dialog_action[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var alert_dialog_action_default = Alert_dialog_action;
mark_module_end(Alert_dialog_action);

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-cancel.svelte
mark_module_start();
Alert_dialog_cancel[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-cancel.svelte";
var root_25 = add_locations(template(`<button><!></button>`), Alert_dialog_cancel[FILENAME], [[21, 1]]);
function Alert_dialog_cancel($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Alert_dialog_cancel);
  const $$stores = setup_stores();
  const $close = () => (validate_store(close, "close"), store_get(close, "$close", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { close }, getAttrs: getAttrs2 } = getCtx2();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("cancel");
  legacy_pre_effect(() => $close(), () => {
    set(builder, $close());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_25();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Alert_dialog_cancel);
  const filename = Alert_dialog_cancel.filename;
  const $$original = Alert_dialog_cancel;
  Alert_dialog_cancel = hmr(s);
  Alert_dialog_cancel.filename = filename;
  Alert_dialog_cancel[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var alert_dialog_cancel_default = Alert_dialog_cancel;
mark_module_end(Alert_dialog_cancel);

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-portal.svelte
mark_module_start();
Alert_dialog_portal[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-portal.svelte";
var root_26 = add_locations(template(`<div><!></div>`), Alert_dialog_portal[FILENAME], [[19, 1]]);
function Alert_dialog_portal($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Alert_dialog_portal);
  const $$stores = setup_stores();
  const $portalled = () => (validate_store(portalled, "portalled"), store_get(portalled, "$portalled", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { portalled }, getAttrs: getAttrs2 } = getCtx2();
  const attrs = getAttrs2("portal");
  legacy_pre_effect(() => $portalled(), () => {
    set(builder, $portalled());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_26();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Alert_dialog_portal);
  const filename = Alert_dialog_portal.filename;
  const $$original = Alert_dialog_portal;
  Alert_dialog_portal = hmr(s);
  Alert_dialog_portal.filename = filename;
  Alert_dialog_portal[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var alert_dialog_portal_default = Alert_dialog_portal;
mark_module_end(Alert_dialog_portal);

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-content.svelte
mark_module_start();
Alert_dialog_content[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-content.svelte";
var root_33 = add_locations(template(`<div><!></div>`), Alert_dialog_content[FILENAME], [[32, 1]]);
var root_52 = add_locations(template(`<div><!></div>`), Alert_dialog_content[FILENAME], [[48, 1]]);
var root_72 = add_locations(template(`<div><!></div>`), Alert_dialog_content[FILENAME], [[65, 1]]);
var root_92 = add_locations(template(`<div><!></div>`), Alert_dialog_content[FILENAME], [[81, 1]]);
var root_112 = add_locations(template(`<div><!></div>`), Alert_dialog_content[FILENAME], [[97, 1]]);
function Alert_dialog_content($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "id",
    "asChild",
    "el"
  ]);
  push($$props, false, Alert_dialog_content);
  const $$stores = setup_stores();
  const $content = () => (validate_store(content, "content"), store_get(content, "$content", $$stores));
  const $open = () => (validate_store(open, "open"), store_get(open, "$open", $$stores));
  const builder = mutable_source();
  let transition2 = prop($$props, "transition", 8, () => void 0);
  let transitionConfig = prop($$props, "transitionConfig", 8, () => void 0);
  let inTransition = prop($$props, "inTransition", 8, () => void 0);
  let inTransitionConfig = prop($$props, "inTransitionConfig", 8, () => void 0);
  let outTransition = prop($$props, "outTransition", 8, () => void 0);
  let outTransitionConfig = prop($$props, "outTransitionConfig", 8, () => void 0);
  let id = prop($$props, "id", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { content },
    states: { open },
    ids,
    getAttrs: getAttrs2
  } = getCtx2();
  const attrs = getAttrs2("content");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.content.set(id());
    }
  });
  legacy_pre_effect(() => $content(), () => {
    set(builder, $content());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => asChild() && $open(),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      if_block(
        node_2,
        () => transition2() && $open(),
        ($$anchor3) => {
          var div = root_33();
          bind_this(div, ($$value) => el($$value), () => el());
          transition(3, div, transition2, transitionConfig);
          let attributes;
          var node_3 = child(div);
          slot(
            node_3,
            default_slot($$props),
            {
              get builder() {
                return get2(builder);
              }
            },
            null
          );
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
          action(div, ($$node) => get2(builder).action($$node));
          event("pointerdown", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("pointermove", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("pointerup", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("touchcancel", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("touchend", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("touchmove", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("touchstart", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          if_block(
            node_4,
            () => inTransition() && outTransition() && $open(),
            ($$anchor4) => {
              var div_1 = root_52();
              bind_this(div_1, ($$value) => el($$value), () => el());
              transition(1, div_1, inTransition, inTransitionConfig);
              transition(2, div_1, outTransition, outTransitionConfig);
              let attributes_1;
              var node_5 = child(div_1);
              slot(
                node_5,
                default_slot($$props),
                {
                  get builder() {
                    return get2(builder);
                  }
                },
                null
              );
              reset(div_1);
              template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get2(builder), ...$$restProps }, true, ""));
              action(div_1, ($$node) => get2(builder).action($$node));
              event("pointerdown", div_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("pointermove", div_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("pointerup", div_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("touchcancel", div_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("touchend", div_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("touchmove", div_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("touchstart", div_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              append($$anchor4, div_1);
            },
            ($$anchor4) => {
              var fragment_4 = comment();
              var node_6 = first_child(fragment_4);
              if_block(
                node_6,
                () => inTransition() && $open(),
                ($$anchor5) => {
                  var div_2 = root_72();
                  bind_this(div_2, ($$value) => el($$value), () => el());
                  transition(1, div_2, inTransition, inTransitionConfig);
                  let attributes_2;
                  var node_7 = child(div_2);
                  slot(
                    node_7,
                    default_slot($$props),
                    {
                      get builder() {
                        return get2(builder);
                      }
                    },
                    null
                  );
                  reset(div_2);
                  template_effect(() => attributes_2 = set_attributes(div_2, attributes_2, { ...get2(builder), ...$$restProps }, true, ""));
                  action(div_2, ($$node) => get2(builder).action($$node));
                  event("pointerdown", div_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("pointermove", div_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("pointerup", div_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("touchcancel", div_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("touchend", div_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("touchmove", div_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("touchstart", div_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  append($$anchor5, div_2);
                },
                ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_8 = first_child(fragment_5);
                  if_block(
                    node_8,
                    () => outTransition() && $open(),
                    ($$anchor6) => {
                      var div_3 = root_92();
                      bind_this(div_3, ($$value) => el($$value), () => el());
                      transition(2, div_3, outTransition, outTransitionConfig);
                      let attributes_3;
                      var node_9 = child(div_3);
                      slot(
                        node_9,
                        default_slot($$props),
                        {
                          get builder() {
                            return get2(builder);
                          }
                        },
                        null
                      );
                      reset(div_3);
                      template_effect(() => attributes_3 = set_attributes(div_3, attributes_3, { ...get2(builder), ...$$restProps }, true, ""));
                      action(div_3, ($$node) => get2(builder).action($$node));
                      event("pointerdown", div_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("pointermove", div_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("pointerup", div_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("touchcancel", div_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("touchend", div_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("touchmove", div_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("touchstart", div_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      append($$anchor6, div_3);
                    },
                    ($$anchor6) => {
                      var fragment_6 = comment();
                      var node_10 = first_child(fragment_6);
                      if_block(
                        node_10,
                        $open,
                        ($$anchor7) => {
                          var div_4 = root_112();
                          bind_this(div_4, ($$value) => el($$value), () => el());
                          let attributes_4;
                          var node_11 = child(div_4);
                          slot(
                            node_11,
                            default_slot($$props),
                            {
                              get builder() {
                                return get2(builder);
                              }
                            },
                            null
                          );
                          reset(div_4);
                          template_effect(() => attributes_4 = set_attributes(div_4, attributes_4, { ...get2(builder), ...$$restProps }, true, ""));
                          action(div_4, ($$node) => get2(builder).action($$node));
                          event("pointerdown", div_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("pointermove", div_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("pointerup", div_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("touchcancel", div_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("touchend", div_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("touchmove", div_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("touchstart", div_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          append($$anchor7, div_4);
                        },
                        null,
                        true
                      );
                      append($$anchor6, fragment_6);
                    },
                    true
                  );
                  append($$anchor5, fragment_5);
                },
                true
              );
              append($$anchor4, fragment_4);
            },
            true
          );
          append($$anchor3, fragment_3);
        },
        true
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Alert_dialog_content);
  const filename = Alert_dialog_content.filename;
  const $$original = Alert_dialog_content;
  Alert_dialog_content = hmr(s);
  Alert_dialog_content.filename = filename;
  Alert_dialog_content[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var alert_dialog_content_default = Alert_dialog_content;
mark_module_end(Alert_dialog_content);

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-overlay.svelte
mark_module_start();
Alert_dialog_overlay[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-overlay.svelte";
var root_34 = add_locations(template(`<div></div>`), Alert_dialog_overlay[FILENAME], [[26, 1]]);
var root_53 = add_locations(template(`<div></div>`), Alert_dialog_overlay[FILENAME], [[33, 1]]);
var root_73 = add_locations(template(`<div></div>`), Alert_dialog_overlay[FILENAME], [[41, 1]]);
var root_93 = add_locations(template(`<div></div>`), Alert_dialog_overlay[FILENAME], [[48, 1]]);
var root_113 = add_locations(template(`<div></div>`), Alert_dialog_overlay[FILENAME], [[55, 1]]);
function Alert_dialog_overlay($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "el"
  ]);
  push($$props, false, Alert_dialog_overlay);
  const $$stores = setup_stores();
  const $overlay = () => (validate_store(overlay, "overlay"), store_get(overlay, "$overlay", $$stores));
  const $open = () => (validate_store(open, "open"), store_get(open, "$open", $$stores));
  const builder = mutable_source();
  let transition2 = prop($$props, "transition", 8, () => void 0);
  let transitionConfig = prop($$props, "transitionConfig", 8, () => void 0);
  let inTransition = prop($$props, "inTransition", 8, () => void 0);
  let inTransitionConfig = prop($$props, "inTransitionConfig", 8, () => void 0);
  let outTransition = prop($$props, "outTransition", 8, () => void 0);
  let outTransitionConfig = prop($$props, "outTransitionConfig", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { overlay },
    states: { open },
    getAttrs: getAttrs2
  } = getCtx2();
  const attrs = getAttrs2("overlay");
  legacy_pre_effect(() => $overlay(), () => {
    set(builder, $overlay());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => asChild() && $open(),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      if_block(
        node_2,
        () => transition2() && $open(),
        ($$anchor3) => {
          var div = root_34();
          bind_this(div, ($$value) => el($$value), () => el());
          transition(3, div, transition2, transitionConfig);
          let attributes;
          template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
          action(div, ($$node) => get2(builder).action($$node));
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          if_block(
            node_3,
            () => inTransition() && outTransition() && $open(),
            ($$anchor4) => {
              var div_1 = root_53();
              bind_this(div_1, ($$value) => el($$value), () => el());
              transition(1, div_1, inTransition, inTransitionConfig);
              transition(2, div_1, outTransition, outTransitionConfig);
              let attributes_1;
              template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get2(builder), ...$$restProps }, true, ""));
              action(div_1, ($$node) => get2(builder).action($$node));
              append($$anchor4, div_1);
            },
            ($$anchor4) => {
              var fragment_4 = comment();
              var node_4 = first_child(fragment_4);
              if_block(
                node_4,
                () => inTransition() && $open(),
                ($$anchor5) => {
                  var div_2 = root_73();
                  bind_this(div_2, ($$value) => el($$value), () => el());
                  transition(1, div_2, inTransition, inTransitionConfig);
                  let attributes_2;
                  template_effect(() => attributes_2 = set_attributes(div_2, attributes_2, { ...get2(builder), ...$$restProps }, true, ""));
                  action(div_2, ($$node) => get2(builder).action($$node));
                  append($$anchor5, div_2);
                },
                ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_5 = first_child(fragment_5);
                  if_block(
                    node_5,
                    () => outTransition() && $open(),
                    ($$anchor6) => {
                      var div_3 = root_93();
                      bind_this(div_3, ($$value) => el($$value), () => el());
                      transition(2, div_3, outTransition, outTransitionConfig);
                      let attributes_3;
                      template_effect(() => attributes_3 = set_attributes(div_3, attributes_3, { ...get2(builder), ...$$restProps }, true, ""));
                      action(div_3, ($$node) => get2(builder).action($$node));
                      append($$anchor6, div_3);
                    },
                    ($$anchor6) => {
                      var fragment_6 = comment();
                      var node_6 = first_child(fragment_6);
                      if_block(
                        node_6,
                        $open,
                        ($$anchor7) => {
                          var div_4 = root_113();
                          bind_this(div_4, ($$value) => el($$value), () => el());
                          let attributes_4;
                          template_effect(() => attributes_4 = set_attributes(div_4, attributes_4, { ...get2(builder), ...$$restProps }, true, ""));
                          action(div_4, ($$node) => get2(builder).action($$node));
                          append($$anchor7, div_4);
                        },
                        null,
                        true
                      );
                      append($$anchor6, fragment_6);
                    },
                    true
                  );
                  append($$anchor5, fragment_5);
                },
                true
              );
              append($$anchor4, fragment_4);
            },
            true
          );
          append($$anchor3, fragment_3);
        },
        true
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Alert_dialog_overlay);
  const filename = Alert_dialog_overlay.filename;
  const $$original = Alert_dialog_overlay;
  Alert_dialog_overlay = hmr(s);
  Alert_dialog_overlay.filename = filename;
  Alert_dialog_overlay[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var alert_dialog_overlay_default = Alert_dialog_overlay;
mark_module_end(Alert_dialog_overlay);

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-trigger.svelte
mark_module_start();
Alert_dialog_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-trigger.svelte";
var root_27 = add_locations(template(`<button><!></button>`), Alert_dialog_trigger[FILENAME], [[21, 1]]);
function Alert_dialog_trigger($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Alert_dialog_trigger);
  const $$stores = setup_stores();
  const $trigger = () => (validate_store(trigger, "trigger"), store_get(trigger, "$trigger", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { trigger }, getAttrs: getAttrs2 } = getCtx2();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("trigger");
  legacy_pre_effect(() => $trigger(), () => {
    set(builder, $trigger());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_27();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Alert_dialog_trigger);
  const filename = Alert_dialog_trigger.filename;
  const $$original = Alert_dialog_trigger;
  Alert_dialog_trigger = hmr(s);
  Alert_dialog_trigger.filename = filename;
  Alert_dialog_trigger[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var alert_dialog_trigger_default = Alert_dialog_trigger;
mark_module_end(Alert_dialog_trigger);

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-description.svelte
mark_module_start();
Alert_dialog_description[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-description.svelte";
var root_28 = add_locations(template(`<div><!></div>`), Alert_dialog_description[FILENAME], [[25, 1]]);
function Alert_dialog_description($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Alert_dialog_description);
  const $$stores = setup_stores();
  const $description = () => (validate_store(description, "description"), store_get(description, "$description", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { description }, ids, getAttrs: getAttrs2 } = getCtx2();
  const attrs = getAttrs2("description");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.description.set(id());
    }
  });
  legacy_pre_effect(() => $description(), () => {
    set(builder, $description());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_28();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Alert_dialog_description);
  const filename = Alert_dialog_description.filename;
  const $$original = Alert_dialog_description;
  Alert_dialog_description = hmr(s);
  Alert_dialog_description.filename = filename;
  Alert_dialog_description[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var alert_dialog_description_default = Alert_dialog_description;
mark_module_end(Alert_dialog_description);

// node_modules/bits-ui/dist/bits/aspect-ratio/index.js
var aspect_ratio_exports = {};
__export(aspect_ratio_exports, {
  Root: () => aspect_ratio_default
});

// node_modules/bits-ui/dist/bits/aspect-ratio/components/aspect-ratio.svelte
mark_module_start();
Aspect_ratio[FILENAME] = "node_modules/bits-ui/dist/bits/aspect-ratio/components/aspect-ratio.svelte";
var root = add_locations(template(`<div><div><!></div></div>`), Aspect_ratio[FILENAME], [[8, 0, [[9, 1]]]]);
function Aspect_ratio($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["ratio", "el"]);
  push($$props, false, Aspect_ratio);
  let ratio = prop($$props, "ratio", 0, 1 / 1);
  let el = prop($$props, "el", 12, () => void 0);
  const attrs = { "data-aspect-ratio-root": "" };
  var div = root();
  set_style(div, "position", "relative");
  set_style(div, "width", "100%");
  var div_1 = child(div);
  bind_this(div_1, ($$value) => el($$value), () => el());
  let attributes;
  var node = child(div_1);
  slot(node, default_slot($$props), {}, null);
  reset(div_1);
  reset(div);
  template_effect(() => {
    set_style(div, "padding-bottom", `${(ratio() ? 100 / ratio() : 0) ?? ""}%`);
    attributes = set_attributes(div_1, attributes, { ...$$restProps, ...attrs }, true, "");
    set_style(div_1, "position", "absolute");
    set_style(div_1, "top", "0");
    set_style(div_1, "right", "0");
    set_style(div_1, "bottom", "0");
    set_style(div_1, "left", "0");
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Aspect_ratio);
  const filename = Aspect_ratio.filename;
  const $$original = Aspect_ratio;
  Aspect_ratio = hmr(s);
  Aspect_ratio.filename = filename;
  Aspect_ratio[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var aspect_ratio_default = Aspect_ratio;
mark_module_end(Aspect_ratio);

// node_modules/bits-ui/dist/bits/avatar/index.js
var avatar_exports = {};
__export(avatar_exports, {
  Fallback: () => avatar_fallback_default,
  Image: () => avatar_image_default,
  Root: () => avatar_default
});

// node_modules/bits-ui/dist/bits/avatar/ctx.js
function getAvatarData() {
  const NAME = "avatar";
  const PARTS = ["root", "image", "fallback"];
  return {
    NAME,
    PARTS
  };
}
function setCtx3(props) {
  const { NAME, PARTS } = getAvatarData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const avatar = { ...createAvatar(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(NAME, avatar);
  return {
    ...avatar,
    updateOption: getOptionUpdater(avatar.options)
  };
}
function getImage(src = "") {
  const { NAME } = getAvatarData();
  const avatar = getContext(NAME);
  if (!src) {
    avatar.options.src.set("");
  } else {
    avatar.options.src.set(src);
  }
  return avatar;
}
function getCtx3() {
  const { NAME } = getAvatarData();
  return getContext(NAME);
}

// node_modules/bits-ui/dist/bits/avatar/components/avatar.svelte
mark_module_start();
Avatar[FILENAME] = "node_modules/bits-ui/dist/bits/avatar/components/avatar.svelte";
var root_29 = add_locations(template(`<div><!></div>`), Avatar[FILENAME], [[30, 1]]);
function Avatar($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "delayMs",
    "loadingStatus",
    "onLoadingStatusChange",
    "asChild",
    "el"
  ]);
  push($$props, false, Avatar);
  let delayMs = prop($$props, "delayMs", 8, () => void 0);
  let loadingStatus = prop($$props, "loadingStatus", 12, () => void 0);
  let onLoadingStatusChange = prop($$props, "onLoadingStatusChange", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    states: { loadingStatus: localLoadingStatus },
    updateOption,
    getAttrs: getAttrs2
  } = setCtx3({
    src: "",
    delayMs: delayMs(),
    onLoadingStatusChange: ({ next: next2 }) => {
      var _a;
      loadingStatus(next2);
      (_a = onLoadingStatusChange()) == null ? void 0 : _a(next2);
      return next2;
    }
  });
  const attrs = getAttrs2("root");
  legacy_pre_effect(() => deep_read_state(loadingStatus()), () => {
    loadingStatus() !== void 0 && localLoadingStatus.set(loadingStatus());
  });
  legacy_pre_effect(() => deep_read_state(delayMs()), () => {
    updateOption("delayMs", delayMs());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_29();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(node_2, default_slot($$props), { attrs }, null);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Avatar);
  const filename = Avatar.filename;
  const $$original = Avatar;
  Avatar = hmr(s);
  Avatar.filename = filename;
  Avatar[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var avatar_default = Avatar;
mark_module_end(Avatar);

// node_modules/bits-ui/dist/bits/avatar/components/avatar-image.svelte
mark_module_start();
Avatar_image[FILENAME] = "node_modules/bits-ui/dist/bits/avatar/components/avatar-image.svelte";
var root_210 = add_locations(template(`<img>`), Avatar_image[FILENAME], [[21, 1]]);
function Avatar_image($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["src", "alt", "asChild", "el"]);
  push($$props, false, Avatar_image);
  const $$stores = setup_stores();
  const $image = () => (validate_store(get2(image), "image"), store_get(get2(image), "$image", $$stores));
  const image = mutable_source();
  const builder = mutable_source();
  let src = prop($$props, "src", 8, () => void 0);
  let alt = prop($$props, "alt", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const attrs = { "data-bits-avatar-image": "" };
  legacy_pre_effect(() => deep_read_state(src()), () => {
    store_unsub(set(image, getImage(src()).elements.image), "$image", $$stores);
  });
  legacy_pre_effect(() => $image(), () => {
    set(builder, $image());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var img = root_210();
      bind_this(img, ($$value) => el($$value), () => el());
      let attributes;
      template_effect(() => attributes = set_attributes(
        img,
        attributes,
        {
          ...get2(builder),
          alt: alt(),
          ...$$restProps
        },
        true,
        ""
      ));
      action(img, ($$node) => get2(builder).action($$node));
      handle_lazy_img(img);
      replay_events(img);
      append($$anchor2, img);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Avatar_image);
  const filename = Avatar_image.filename;
  const $$original = Avatar_image;
  Avatar_image = hmr(s);
  Avatar_image.filename = filename;
  Avatar_image[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var avatar_image_default = Avatar_image;
mark_module_end(Avatar_image);

// node_modules/bits-ui/dist/bits/avatar/components/avatar-fallback.svelte
mark_module_start();
Avatar_fallback[FILENAME] = "node_modules/bits-ui/dist/bits/avatar/components/avatar-fallback.svelte";
var root_211 = add_locations(template(`<span><!></span>`), Avatar_fallback[FILENAME], [[19, 1]]);
function Avatar_fallback($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Avatar_fallback);
  const $$stores = setup_stores();
  const $fallback = () => (validate_store(fallback, "fallback"), store_get(fallback, "$fallback", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { fallback }, getAttrs: getAttrs2 } = getCtx3();
  const attrs = getAttrs2("fallback");
  legacy_pre_effect(() => $fallback(), () => {
    set(builder, $fallback());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_211();
      bind_this(span, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(span);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(span);
      template_effect(() => attributes = set_attributes(span, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(span, ($$node) => get2(builder).action($$node));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Avatar_fallback);
  const filename = Avatar_fallback.filename;
  const $$original = Avatar_fallback;
  Avatar_fallback = hmr(s);
  Avatar_fallback.filename = filename;
  Avatar_fallback[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var avatar_fallback_default = Avatar_fallback;
mark_module_end(Avatar_fallback);

// node_modules/bits-ui/dist/bits/button/index.js
var button_exports = {};
__export(button_exports, {
  Root: () => button_default
});

// node_modules/bits-ui/dist/helpers/builders.js
function builderActions(node, params) {
  const unsubs = [];
  params.builders.forEach((builder) => {
    const act = builder.action(node);
    if (act) {
      unsubs.push(act);
    }
  });
  return {
    destroy: () => {
      unsubs.forEach((unsub) => {
        if (unsub.destroy) {
          unsub.destroy();
        }
      });
    }
  };
}
function getAttrs(builders) {
  const attrs = {};
  builders.forEach((builder) => {
    Object.keys(builder).forEach((key) => {
      if (key !== "action") {
        attrs[key] = builder[key];
      }
    });
  });
  return attrs;
}

// node_modules/bits-ui/dist/bits/button/components/button.svelte
mark_module_start();
Button[FILENAME] = "node_modules/bits-ui/dist/bits/button/components/button.svelte";
function Button($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["href", "type", "builders", "el"]);
  push($$props, false, Button);
  let href = prop($$props, "href", 8, () => void 0);
  let type = prop($$props, "type", 8, () => void 0);
  let builders = prop($$props, "builders", 8, () => []);
  let el = prop($$props, "el", 12, () => void 0);
  const attrs = { "data-button-root": "" };
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => builders() && builders().length,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      validate_void_dynamic_element(() => href() ? "a" : "button");
      validate_dynamic_element_tag(() => href() ? "a" : "button");
      element(
        node_1,
        () => href() ? "a" : "button",
        false,
        ($$element, $$anchor3) => {
          bind_this($$element, ($$value) => el($$value), () => el());
          let attributes;
          template_effect(() => attributes = set_dynamic_element_attributes(
            $$element,
            attributes,
            {
              type: href() ? void 0 : type(),
              href: href(),
              tabindex: "0",
              ...getAttrs(builders()),
              ...$$restProps,
              ...attrs
            },
            ""
          ));
          event("click", $$element, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("change", $$element, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("keydown", $$element, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("keyup", $$element, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("mouseenter", $$element, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("mouseleave", $$element, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("mousedown", $$element, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("pointerdown", $$element, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("mouseup", $$element, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("pointerup", $$element, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          action($$element, ($$node, $$action_arg) => builderActions($$node, $$action_arg), () => ({ builders: builders() }));
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          slot(node_2, default_slot($$props), {}, null);
          append($$anchor3, fragment_2);
        },
        void 0,
        [13, 1]
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_3 = comment();
      var node_3 = first_child(fragment_3);
      validate_void_dynamic_element(() => href() ? "a" : "button");
      validate_dynamic_element_tag(() => href() ? "a" : "button");
      element(
        node_3,
        () => href() ? "a" : "button",
        false,
        ($$element_1, $$anchor3) => {
          bind_this($$element_1, ($$value) => el($$value), () => el());
          let attributes_1;
          template_effect(() => attributes_1 = set_dynamic_element_attributes(
            $$element_1,
            attributes_1,
            {
              type: href() ? void 0 : type(),
              href: href(),
              tabindex: "0",
              ...$$restProps,
              ...attrs
            },
            ""
          ));
          event("click", $$element_1, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("change", $$element_1, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("keydown", $$element_1, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("keyup", $$element_1, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("mouseenter", $$element_1, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("mouseleave", $$element_1, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("mousedown", $$element_1, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("pointerdown", $$element_1, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("mouseup", $$element_1, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("pointerup", $$element_1, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          var fragment_4 = comment();
          var node_4 = first_child(fragment_4);
          slot(node_4, default_slot($$props), {}, null);
          append($$anchor3, fragment_4);
        },
        void 0,
        [38, 1]
      );
      append($$anchor2, fragment_3);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Button);
  const filename = Button.filename;
  const $$original = Button;
  Button = hmr(s);
  Button.filename = filename;
  Button[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var button_default = Button;
mark_module_end(Button);

// node_modules/bits-ui/dist/bits/calendar/index.js
var calendar_exports = {};
__export(calendar_exports, {
  Cell: () => calendar_cell_default,
  Day: () => calendar_day_default,
  Grid: () => calendar_grid_default,
  GridBody: () => calendar_grid_body_default,
  GridHead: () => calendar_grid_head_default,
  GridRow: () => calendar_grid_row_default,
  HeadCell: () => calendar_head_cell_default,
  Header: () => calendar_header_default,
  Heading: () => calendar_heading_default,
  NextButton: () => calendar_next_button_default,
  PrevButton: () => calendar_prev_button_default,
  Root: () => calendar_default
});

// node_modules/bits-ui/dist/bits/calendar/ctx.js
function getCalendarData() {
  const NAME = "calendar";
  const PARTS = [
    "root",
    "prev-button",
    "next-button",
    "heading",
    "grid",
    "day",
    "header",
    "grid-head",
    "head-cell",
    "grid-body",
    "cell",
    "grid-row"
  ];
  return { NAME, PARTS };
}
function setCtx4(props) {
  const { NAME, PARTS } = getCalendarData();
  const getCalendarAttrs = createBitAttrs(NAME, PARTS);
  const calendar = { ...createCalendar(removeUndefined2(props)), getCalendarAttrs };
  setContext(NAME, calendar);
  return {
    ...calendar,
    updateOption: getOptionUpdater(calendar.options)
  };
}
function getCtx4() {
  const { NAME } = getCalendarData();
  const ctx = getContext(NAME);
  return ctx;
}

// node_modules/bits-ui/dist/bits/calendar/components/calendar.svelte
mark_module_start();
Calendar[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar.svelte";
var root_212 = add_locations(template(`<div><!></div>`), Calendar[FILENAME], [[132, 1]]);
function Calendar($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "placeholder",
    "onPlaceholderChange",
    "value",
    "onValueChange",
    "preventDeselect",
    "minValue",
    "maxValue",
    "pagedNavigation",
    "weekStartsOn",
    "locale",
    "isDateUnavailable",
    "isDateDisabled",
    "disabled",
    "readonly",
    "fixedWeeks",
    "calendarLabel",
    "weekdayFormat",
    "multiple",
    "asChild",
    "id",
    "numberOfMonths",
    "initialFocus",
    "el"
  ]);
  push($$props, false, Calendar);
  const $$stores = setup_stores();
  const $calendar = () => (validate_store(calendar, "calendar"), store_get(calendar, "$calendar", $$stores));
  const $localMonths = () => (validate_store(localMonths, "localMonths"), store_get(localMonths, "$localMonths", $$stores));
  const $weekdays = () => (validate_store(weekdays, "weekdays"), store_get(weekdays, "$weekdays", $$stores));
  const builder = mutable_source();
  let placeholder = prop($$props, "placeholder", 12, () => void 0);
  let onPlaceholderChange = prop($$props, "onPlaceholderChange", 8, () => void 0);
  let value = prop($$props, "value", 12, () => void 0);
  let onValueChange = prop($$props, "onValueChange", 8, () => void 0);
  let preventDeselect = prop($$props, "preventDeselect", 8, () => void 0);
  let minValue = prop($$props, "minValue", 8, () => void 0);
  let maxValue = prop($$props, "maxValue", 8, () => void 0);
  let pagedNavigation = prop($$props, "pagedNavigation", 8, () => void 0);
  let weekStartsOn = prop($$props, "weekStartsOn", 8, () => void 0);
  let locale = prop($$props, "locale", 8, () => void 0);
  let isDateUnavailable = prop($$props, "isDateUnavailable", 8, () => void 0);
  let isDateDisabled = prop($$props, "isDateDisabled", 8, () => void 0);
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let readonly2 = prop($$props, "readonly", 8, () => void 0);
  let fixedWeeks = prop($$props, "fixedWeeks", 8, () => void 0);
  let calendarLabel = prop($$props, "calendarLabel", 8, () => void 0);
  let weekdayFormat = prop($$props, "weekdayFormat", 8, () => void 0);
  let multiple = prop($$props, "multiple", 0, false);
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let numberOfMonths = prop($$props, "numberOfMonths", 8, () => void 0);
  let initialFocus = prop($$props, "initialFocus", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  onMount(() => {
    if (!initialFocus() || !el()) return;
    handleCalendarInitialFocus(el());
  });
  const {
    elements: { calendar },
    states: {
      value: localValue,
      placeholder: localPlaceholder,
      months: localMonths,
      weekdays
    },
    updateOption,
    ids,
    getCalendarAttrs
  } = setCtx4({
    defaultPlaceholder: placeholder(),
    defaultValue: value(),
    preventDeselect: preventDeselect(),
    minValue: minValue(),
    maxValue: maxValue(),
    pagedNavigation: pagedNavigation(),
    weekStartsOn: weekStartsOn(),
    locale: locale(),
    isDateUnavailable: isDateUnavailable(),
    isDateDisabled: isDateDisabled(),
    disabled: disabled(),
    readonly: readonly2(),
    fixedWeeks: fixedWeeks(),
    calendarLabel: calendarLabel(),
    weekdayFormat: weekdayFormat(),
    multiple: multiple(),
    numberOfMonths: numberOfMonths(),
    onPlaceholderChange: ({ next: next2 }) => {
      var _a;
      if (placeholder() !== next2) {
        (_a = onPlaceholderChange()) == null ? void 0 : _a(next2);
        placeholder(next2);
      }
      return next2;
    },
    onValueChange: ({ next: next2 }) => {
      var _a, _b;
      if (Array.isArray(next2)) {
        if (!Array.isArray(value()) || !arraysAreEqual(value(), next2)) {
          (_a = onValueChange()) == null ? void 0 : _a(next2);
          value(next2);
          return next2;
        }
        return next2;
      }
      if (value() !== next2) {
        (_b = onValueChange()) == null ? void 0 : _b(next2);
        value(next2);
      }
      return next2;
    }
  });
  const attrs = getCalendarAttrs("root");
  const dispatch = createDispatcher();
  let months = mutable_source($localMonths());
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.calendar.set(id());
    }
  });
  legacy_pre_effect(() => deep_read_state(value()), () => {
    value() !== void 0 && localValue.set(Array.isArray(value()) ? [...value()] : value());
  });
  legacy_pre_effect(() => deep_read_state(placeholder()), () => {
    placeholder() !== void 0 && localPlaceholder.set(placeholder());
  });
  legacy_pre_effect(() => deep_read_state(preventDeselect()), () => {
    updateOption("preventDeselect", preventDeselect());
  });
  legacy_pre_effect(() => deep_read_state(minValue()), () => {
    updateOption("minValue", minValue());
  });
  legacy_pre_effect(() => deep_read_state(maxValue()), () => {
    updateOption("maxValue", maxValue());
  });
  legacy_pre_effect(() => deep_read_state(pagedNavigation()), () => {
    updateOption("pagedNavigation", pagedNavigation());
  });
  legacy_pre_effect(() => deep_read_state(weekStartsOn()), () => {
    updateOption("weekStartsOn", weekStartsOn());
  });
  legacy_pre_effect(() => deep_read_state(locale()), () => {
    updateOption("locale", locale());
  });
  legacy_pre_effect(() => deep_read_state(isDateUnavailable()), () => {
    updateOption("isDateUnavailable", isDateUnavailable());
  });
  legacy_pre_effect(() => deep_read_state(isDateDisabled()), () => {
    updateOption("isDateDisabled", isDateDisabled());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => deep_read_state(readonly2()), () => {
    updateOption("readonly", readonly2());
  });
  legacy_pre_effect(() => deep_read_state(fixedWeeks()), () => {
    updateOption("fixedWeeks", fixedWeeks());
  });
  legacy_pre_effect(() => deep_read_state(calendarLabel()), () => {
    updateOption("calendarLabel", calendarLabel());
  });
  legacy_pre_effect(() => deep_read_state(weekdayFormat()), () => {
    updateOption("weekdayFormat", weekdayFormat());
  });
  legacy_pre_effect(() => deep_read_state(numberOfMonths()), () => {
    updateOption("numberOfMonths", numberOfMonths());
  });
  legacy_pre_effect(() => $calendar(), () => {
    set(builder, $calendar());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(() => $localMonths(), () => {
    set(months, $localMonths());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get months() {
            return get2(months);
          },
          get weekdays() {
            return $weekdays();
          },
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_212();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get months() {
            return get2(months);
          },
          get weekdays() {
            return $weekdays();
          },
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      event("m-keydown", div, dispatch, false);
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Calendar);
  const filename = Calendar.filename;
  const $$original = Calendar;
  Calendar = hmr(s);
  Calendar.filename = filename;
  Calendar[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var calendar_default = Calendar;
mark_module_end(Calendar);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-day.svelte
mark_module_start();
Calendar_day[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-day.svelte";
var root_213 = add_locations(template(`<div><!></div>`), Calendar_day[FILENAME], [[30, 1]]);
function Calendar_day($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["date", "month", "asChild", "el"]);
  push($$props, false, Calendar_day);
  const $$stores = setup_stores();
  const $cell = () => (validate_store(cell, "cell"), store_get(cell, "$cell", $$stores));
  const $isDateDisabled = () => (validate_store(isDateDisabled, "isDateDisabled"), store_get(isDateDisabled, "$isDateDisabled", $$stores));
  const $isDateUnavailable = () => (validate_store(isDateUnavailable, "isDateUnavailable"), store_get(isDateUnavailable, "$isDateUnavailable", $$stores));
  const $isDateSelected = () => (validate_store(isDateSelected, "isDateSelected"), store_get(isDateSelected, "$isDateSelected", $$stores));
  const builder = mutable_source();
  const disabled = mutable_source();
  const unavailable = mutable_source();
  const selected = mutable_source();
  let date = prop($$props, "date");
  let month = prop($$props, "month");
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { cell },
    helpers: {
      isDateDisabled,
      isDateUnavailable,
      isDateSelected
    },
    getCalendarAttrs
  } = getCtx4();
  const attrs = getCalendarAttrs("day");
  const dispatch = createDispatcher();
  legacy_pre_effect(
    () => ($cell(), deep_read_state(date()), deep_read_state(month())),
    () => {
      set(builder, $cell()(date(), month()));
    }
  );
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(
    () => ($isDateDisabled(), deep_read_state(date())),
    () => {
      set(disabled, $isDateDisabled()(date()));
    }
  );
  legacy_pre_effect(
    () => ($isDateUnavailable(), deep_read_state(date())),
    () => {
      set(unavailable, $isDateUnavailable()(date()));
    }
  );
  legacy_pre_effect(
    () => ($isDateSelected(), deep_read_state(date())),
    () => {
      set(selected, $isDateSelected()(date()));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get disabled() {
            return get2(disabled);
          },
          get unavailable() {
            return get2(unavailable);
          },
          get selected() {
            return get2(selected);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_213();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get disabled() {
            return get2(disabled);
          },
          get unavailable() {
            return get2(unavailable);
          },
          get selected() {
            return get2(selected);
          }
        },
        ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, date().day));
          append($$anchor3, text2);
        }
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      event("m-click", div, dispatch, false);
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Calendar_day);
  const filename = Calendar_day.filename;
  const $$original = Calendar_day;
  Calendar_day = hmr(s);
  Calendar_day.filename = filename;
  Calendar_day[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var calendar_day_default = Calendar_day;
mark_module_end(Calendar_day);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid.svelte
mark_module_start();
Calendar_grid[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-grid.svelte";
var root_214 = add_locations(template(`<table><!></table>`), Calendar_grid[FILENAME], [[19, 1]]);
function Calendar_grid($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Calendar_grid);
  const $$stores = setup_stores();
  const $grid = () => (validate_store(grid, "grid"), store_get(grid, "$grid", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { grid }, getCalendarAttrs } = getCtx4();
  const attrs = getCalendarAttrs("grid");
  legacy_pre_effect(() => $grid(), () => {
    set(builder, $grid());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var table = root_214();
      bind_this(table, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(table);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(table);
      template_effect(() => attributes = set_attributes(table, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(table, ($$node) => get2(builder).action($$node));
      append($$anchor2, table);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Calendar_grid);
  const filename = Calendar_grid.filename;
  const $$original = Calendar_grid;
  Calendar_grid = hmr(s);
  Calendar_grid.filename = filename;
  Calendar_grid[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var calendar_grid_default = Calendar_grid;
mark_module_end(Calendar_grid);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-body.svelte
mark_module_start();
Calendar_grid_body[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-body.svelte";
var root_215 = add_locations(template(`<tbody><!></tbody>`), Calendar_grid_body[FILENAME], [[11, 1]]);
function Calendar_grid_body($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Calendar_grid_body);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getCalendarAttrs } = getCtx4();
  const attrs = getCalendarAttrs("grid-body");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var tbody = root_215();
      bind_this(tbody, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(tbody);
      slot(node_2, default_slot($$props), { attrs }, null);
      reset(tbody);
      template_effect(() => attributes = set_attributes(tbody, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, tbody);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Calendar_grid_body);
  const filename = Calendar_grid_body.filename;
  const $$original = Calendar_grid_body;
  Calendar_grid_body = hmr(s);
  Calendar_grid_body.filename = filename;
  Calendar_grid_body[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var calendar_grid_body_default = Calendar_grid_body;
mark_module_end(Calendar_grid_body);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-cell.svelte
mark_module_start();
Calendar_cell[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-cell.svelte";
var root_216 = add_locations(template(`<td><!></td>`), Calendar_cell[FILENAME], [[21, 1]]);
function Calendar_cell($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["date", "asChild", "el"]);
  push($$props, false, Calendar_cell);
  const $$stores = setup_stores();
  const $isDateDisabled = () => (validate_store(isDateDisabled, "isDateDisabled"), store_get(isDateDisabled, "$isDateDisabled", $$stores));
  const $isDateUnavailable = () => (validate_store(isDateUnavailable, "isDateUnavailable"), store_get(isDateUnavailable, "$isDateUnavailable", $$stores));
  const attrs = mutable_source();
  let date = prop($$props, "date");
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    helpers: { isDateDisabled, isDateUnavailable },
    getCalendarAttrs
  } = getCtx4();
  legacy_pre_effect(
    () => ($isDateDisabled(), deep_read_state(date()), $isDateUnavailable()),
    () => {
      set(attrs, {
        ...getCalendarAttrs("cell"),
        "aria-disabled": $isDateDisabled()(date()) || $isDateUnavailable()(date()),
        "data-disabled": $isDateDisabled()(date()) ? "" : void 0,
        role: "gridcell"
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get attrs() {
            return get2(attrs);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var td = root_216();
      bind_this(td, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(td);
      slot(
        node_2,
        default_slot($$props),
        {
          get attrs() {
            return get2(attrs);
          }
        },
        null
      );
      reset(td);
      template_effect(() => attributes = set_attributes(td, attributes, { ...$$restProps, ...get2(attrs) }, true, ""));
      append($$anchor2, td);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Calendar_cell);
  const filename = Calendar_cell.filename;
  const $$original = Calendar_cell;
  Calendar_cell = hmr(s);
  Calendar_cell.filename = filename;
  Calendar_cell[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var calendar_cell_default = Calendar_cell;
mark_module_end(Calendar_cell);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-head.svelte
mark_module_start();
Calendar_grid_head[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-head.svelte";
var root_217 = add_locations(template(`<thead><!></thead>`), Calendar_grid_head[FILENAME], [[14, 1]]);
function Calendar_grid_head($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Calendar_grid_head);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getCalendarAttrs } = getCtx4();
  const attrs = {
    ...getCalendarAttrs("grid-head"),
    "aria-hidden": true
  };
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var thead = root_217();
      bind_this(thead, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(thead);
      slot(node_2, default_slot($$props), { attrs }, null);
      reset(thead);
      template_effect(() => attributes = set_attributes(thead, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, thead);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Calendar_grid_head);
  const filename = Calendar_grid_head.filename;
  const $$original = Calendar_grid_head;
  Calendar_grid_head = hmr(s);
  Calendar_grid_head.filename = filename;
  Calendar_grid_head[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var calendar_grid_head_default = Calendar_grid_head;
mark_module_end(Calendar_grid_head);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-head-cell.svelte
mark_module_start();
Calendar_head_cell[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-head-cell.svelte";
var root_218 = add_locations(template(`<th><!></th>`), Calendar_head_cell[FILENAME], [[11, 1]]);
function Calendar_head_cell($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Calendar_head_cell);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getCalendarAttrs } = getCtx4();
  const attrs = getCalendarAttrs("head-cell");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var th = root_218();
      bind_this(th, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(th);
      slot(node_2, default_slot($$props), { attrs }, null);
      reset(th);
      template_effect(() => attributes = set_attributes(th, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, th);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Calendar_head_cell);
  const filename = Calendar_head_cell.filename;
  const $$original = Calendar_head_cell;
  Calendar_head_cell = hmr(s);
  Calendar_head_cell.filename = filename;
  Calendar_head_cell[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var calendar_head_cell_default = Calendar_head_cell;
mark_module_end(Calendar_head_cell);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-row.svelte
mark_module_start();
Calendar_grid_row[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-row.svelte";
var root_219 = add_locations(template(`<tr><!></tr>`), Calendar_grid_row[FILENAME], [[11, 1]]);
function Calendar_grid_row($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Calendar_grid_row);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getCalendarAttrs } = getCtx4();
  const attrs = getCalendarAttrs("grid-row");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var tr = root_219();
      bind_this(tr, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(tr);
      slot(node_2, default_slot($$props), { attrs }, null);
      reset(tr);
      template_effect(() => attributes = set_attributes(tr, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, tr);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Calendar_grid_row);
  const filename = Calendar_grid_row.filename;
  const $$original = Calendar_grid_row;
  Calendar_grid_row = hmr(s);
  Calendar_grid_row.filename = filename;
  Calendar_grid_row[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var calendar_grid_row_default = Calendar_grid_row;
mark_module_end(Calendar_grid_row);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-header.svelte
mark_module_start();
Calendar_header[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-header.svelte";
var root_220 = add_locations(template(`<header><!></header>`), Calendar_header[FILENAME], [[11, 1]]);
function Calendar_header($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Calendar_header);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getCalendarAttrs } = getCtx4();
  const attrs = getCalendarAttrs("header");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var header = root_220();
      bind_this(header, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(header);
      slot(node_2, default_slot($$props), { attrs }, null);
      reset(header);
      template_effect(() => attributes = set_attributes(header, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, header);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Calendar_header);
  const filename = Calendar_header.filename;
  const $$original = Calendar_header;
  Calendar_header = hmr(s);
  Calendar_header.filename = filename;
  Calendar_header[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var calendar_header_default = Calendar_header;
mark_module_end(Calendar_header);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-heading.svelte
mark_module_start();
Calendar_heading[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-heading.svelte";
var root_221 = add_locations(template(`<div><!></div>`), Calendar_heading[FILENAME], [[20, 1]]);
function Calendar_heading($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Calendar_heading);
  const $$stores = setup_stores();
  const $heading = () => (validate_store(heading, "heading"), store_get(heading, "$heading", $$stores));
  const $headingValue = () => (validate_store(headingValue, "headingValue"), store_get(headingValue, "$headingValue", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { heading },
    states: { headingValue },
    getCalendarAttrs
  } = getCtx4();
  const attrs = getCalendarAttrs("heading");
  legacy_pre_effect(() => $heading(), () => {
    set(builder, $heading());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get headingValue() {
            return $headingValue();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_221();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get headingValue() {
            return $headingValue();
          }
        },
        ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, $headingValue()));
          append($$anchor3, text2);
        }
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Calendar_heading);
  const filename = Calendar_heading.filename;
  const $$original = Calendar_heading;
  Calendar_heading = hmr(s);
  Calendar_heading.filename = filename;
  Calendar_heading[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var calendar_heading_default = Calendar_heading;
mark_module_end(Calendar_heading);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-next-button.svelte
mark_module_start();
Calendar_next_button[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-next-button.svelte";
var root_222 = add_locations(template(`<button><!></button>`), Calendar_next_button[FILENAME], [[21, 1]]);
function Calendar_next_button($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Calendar_next_button);
  const $$stores = setup_stores();
  const $nextButton = () => (validate_store(nextButton, "nextButton"), store_get(nextButton, "$nextButton", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { nextButton }, getCalendarAttrs } = getCtx4();
  const attrs = getCalendarAttrs("next-button");
  const dispatch = createDispatcher();
  legacy_pre_effect(() => $nextButton(), () => {
    set(builder, $nextButton());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_222();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Calendar_next_button);
  const filename = Calendar_next_button.filename;
  const $$original = Calendar_next_button;
  Calendar_next_button = hmr(s);
  Calendar_next_button.filename = filename;
  Calendar_next_button[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var calendar_next_button_default = Calendar_next_button;
mark_module_end(Calendar_next_button);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-prev-button.svelte
mark_module_start();
Calendar_prev_button[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-prev-button.svelte";
var root_223 = add_locations(template(`<button><!></button>`), Calendar_prev_button[FILENAME], [[21, 1]]);
function Calendar_prev_button($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Calendar_prev_button);
  const $$stores = setup_stores();
  const $prevButton = () => (validate_store(prevButton, "prevButton"), store_get(prevButton, "$prevButton", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { prevButton }, getCalendarAttrs } = getCtx4();
  const attrs = getCalendarAttrs("prev-button");
  const dispatch = createDispatcher();
  legacy_pre_effect(() => $prevButton(), () => {
    set(builder, $prevButton());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_223();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Calendar_prev_button);
  const filename = Calendar_prev_button.filename;
  const $$original = Calendar_prev_button;
  Calendar_prev_button = hmr(s);
  Calendar_prev_button.filename = filename;
  Calendar_prev_button[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var calendar_prev_button_default = Calendar_prev_button;
mark_module_end(Calendar_prev_button);

// node_modules/bits-ui/dist/bits/checkbox/index.js
var checkbox_exports = {};
__export(checkbox_exports, {
  Indicator: () => checkbox_indicator_default,
  Input: () => checkbox_input_default,
  Root: () => checkbox_default
});

// node_modules/bits-ui/dist/bits/checkbox/ctx.js
function getCheckboxData() {
  const NAME = "checkbox";
  const PARTS = ["root", "input", "indicator"];
  return {
    NAME,
    PARTS
  };
}
function setCtx5(props) {
  const { NAME, PARTS } = getCheckboxData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const checkbox = { ...createCheckbox(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(NAME, checkbox);
  return {
    ...checkbox,
    updateOption: getOptionUpdater(checkbox.options)
  };
}
function getCtx5() {
  const { NAME } = getCheckboxData();
  return getContext(NAME);
}

// node_modules/bits-ui/dist/bits/checkbox/components/checkbox.svelte
mark_module_start();
Checkbox[FILENAME] = "node_modules/bits-ui/dist/bits/checkbox/components/checkbox.svelte";
var root_35 = add_locations(template(`<button><!></button>`), Checkbox[FILENAME], [[53, 1]]);
function Checkbox($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "checked",
    "disabled",
    "name",
    "required",
    "value",
    "onCheckedChange",
    "asChild",
    "el"
  ]);
  push($$props, false, Checkbox);
  const $$stores = setup_stores();
  const $root = () => (validate_store(root5, "root"), store_get(root5, "$root", $$stores));
  const attrs = mutable_source();
  const builder = mutable_source();
  let checked = prop($$props, "checked", 4, false);
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let name27 = prop($$props, "name", 8, () => void 0);
  let required = prop($$props, "required", 8, () => void 0);
  let value = prop($$props, "value", 8, () => void 0);
  let onCheckedChange = prop($$props, "onCheckedChange", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { root: root5 },
    states: { checked: localChecked },
    updateOption,
    getAttrs: getAttrs2
  } = setCtx5({
    defaultChecked: checked(),
    disabled: disabled(),
    name: name27(),
    required: required(),
    value: value(),
    onCheckedChange: ({ next: next2 }) => {
      var _a;
      if (checked() !== next2) {
        (_a = onCheckedChange()) == null ? void 0 : _a(next2);
        checked(next2);
      }
      return next2;
    }
  });
  const dispatch = createDispatcher();
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    set(attrs, {
      ...getAttrs2("root"),
      disabled: disabled() ? true : void 0
    });
  });
  legacy_pre_effect(() => deep_read_state(checked()), () => {
    checked() !== void 0 && localChecked.set(checked());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => deep_read_state(name27()), () => {
    updateOption("name", name27());
  });
  legacy_pre_effect(() => deep_read_state(required()), () => {
    updateOption("required", required());
  });
  legacy_pre_effect(() => deep_read_state(value()), () => {
    updateOption("value", value());
  });
  legacy_pre_effect(() => $root(), () => {
    set(builder, $root());
  });
  legacy_pre_effect(() => (get2(builder), get2(attrs)), () => {
    Object.assign(get2(builder), get2(attrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_35();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Checkbox);
  const filename = Checkbox.filename;
  const $$original = Checkbox;
  Checkbox = hmr(s);
  Checkbox.filename = filename;
  Checkbox[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var checkbox_default = Checkbox;
mark_module_end(Checkbox);

// node_modules/bits-ui/dist/bits/checkbox/components/checkbox-indicator.svelte
mark_module_start();
Checkbox_indicator[FILENAME] = "node_modules/bits-ui/dist/bits/checkbox/components/checkbox-indicator.svelte";
var root_224 = add_locations(template(`<div><!></div>`), Checkbox_indicator[FILENAME], [[26, 1]]);
function Checkbox_indicator($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Checkbox_indicator);
  const $$stores = setup_stores();
  const $checked = () => (validate_store(checked, "checked"), store_get(checked, "$checked", $$stores));
  const $isChecked = () => (validate_store(isChecked, "isChecked"), store_get(isChecked, "$isChecked", $$stores));
  const $isIndeterminate = () => (validate_store(isIndeterminate, "isIndeterminate"), store_get(isIndeterminate, "$isIndeterminate", $$stores));
  const attrs = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    helpers: { isChecked, isIndeterminate },
    states: { checked },
    getAttrs: getAttrs2
  } = getCtx5();
  function getStateAttr(state) {
    if (state === "indeterminate") return "indeterminate";
    if (state) return "checked";
    return "unchecked";
  }
  legacy_pre_effect(() => $checked(), () => {
    set(attrs, {
      ...getAttrs2("indicator"),
      "data-state": getStateAttr($checked())
    });
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get attrs() {
            return get2(attrs);
          },
          get isChecked() {
            return $isChecked();
          },
          get isIndeterminate() {
            return $isIndeterminate();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_224();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get attrs() {
            return get2(attrs);
          },
          get isChecked() {
            return $isChecked();
          },
          get isIndeterminate() {
            return $isIndeterminate();
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, ...get2(attrs) }, true, ""));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Checkbox_indicator);
  const filename = Checkbox_indicator.filename;
  const $$original = Checkbox_indicator;
  Checkbox_indicator = hmr(s);
  Checkbox_indicator.filename = filename;
  Checkbox_indicator[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var checkbox_indicator_default = Checkbox_indicator;
mark_module_end(Checkbox_indicator);

// node_modules/bits-ui/dist/bits/checkbox/components/checkbox-input.svelte
mark_module_start();
Checkbox_input[FILENAME] = "node_modules/bits-ui/dist/bits/checkbox/components/checkbox-input.svelte";
var root2 = add_locations(template(`<input>`), Checkbox_input[FILENAME], [[10, 0]]);
function Checkbox_input($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["el"]);
  push($$props, false, Checkbox_input);
  const $$stores = setup_stores();
  const $input = () => (validate_store(input, "input"), store_get(input, "$input", $$stores));
  const $value = () => (validate_store(value, "value"), store_get(value, "$value", $$stores));
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { input }, options: { value } } = getCtx5();
  init();
  var input_1 = root2();
  bind_this(input_1, ($$value) => el($$value), () => el());
  remove_input_defaults(input_1);
  let attributes;
  template_effect(() => attributes = set_attributes(
    input_1,
    attributes,
    {
      ...$input(),
      value: $value() ?? "on",
      ...$$restProps
    },
    true,
    ""
  ));
  action(input_1, ($$node) => $input().action($$node));
  append($$anchor, input_1);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Checkbox_input);
  const filename = Checkbox_input.filename;
  const $$original = Checkbox_input;
  Checkbox_input = hmr(s);
  Checkbox_input.filename = filename;
  Checkbox_input[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var checkbox_input_default = Checkbox_input;
mark_module_end(Checkbox_input);

// node_modules/bits-ui/dist/bits/collapsible/index.js
var collapsible_exports = {};
__export(collapsible_exports, {
  Content: () => collapsible_content_default,
  Root: () => collapsible_default,
  Trigger: () => collapsible_trigger_default
});

// node_modules/bits-ui/dist/bits/collapsible/ctx.js
function getCollapsibleData() {
  const NAME = "collapsible";
  const PARTS = ["root", "content", "trigger"];
  return {
    NAME,
    PARTS
  };
}
function setCtx6(props) {
  const { NAME, PARTS } = getCollapsibleData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const collapsible = { ...createCollapsible(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(NAME, collapsible);
  return {
    ...collapsible,
    updateOption: getOptionUpdater(collapsible.options)
  };
}
function getCtx6() {
  const { NAME } = getCollapsibleData();
  return getContext(NAME);
}

// node_modules/bits-ui/dist/bits/collapsible/components/collapsible.svelte
mark_module_start();
Collapsible[FILENAME] = "node_modules/bits-ui/dist/bits/collapsible/components/collapsible.svelte";
var root_36 = add_locations(template(`<div><!></div>`), Collapsible[FILENAME], [[39, 1]]);
function Collapsible($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "disabled",
    "open",
    "onOpenChange",
    "asChild",
    "el"
  ]);
  push($$props, false, Collapsible);
  const $$stores = setup_stores();
  const $root = () => (validate_store(root5, "root"), store_get(root5, "$root", $$stores));
  const builder = mutable_source();
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let open = prop($$props, "open", 12, () => void 0);
  let onOpenChange = prop($$props, "onOpenChange", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { root: root5 },
    states: { open: localOpen },
    updateOption,
    getAttrs: getAttrs2
  } = setCtx6({
    disabled: disabled(),
    forceVisible: true,
    defaultOpen: open(),
    onOpenChange: ({ next: next2 }) => {
      var _a;
      if (open() !== next2) {
        (_a = onOpenChange()) == null ? void 0 : _a(next2);
        open(next2);
      }
      return next2;
    }
  });
  const attrs = getAttrs2("root");
  legacy_pre_effect(() => deep_read_state(open()), () => {
    open() !== void 0 && localOpen.set(open());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => $root(), () => {
    set(builder, $root());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_36();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Collapsible);
  const filename = Collapsible.filename;
  const $$original = Collapsible;
  Collapsible = hmr(s);
  Collapsible.filename = filename;
  Collapsible[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var collapsible_default = Collapsible;
mark_module_end(Collapsible);

// node_modules/bits-ui/dist/bits/collapsible/components/collapsible-content.svelte
mark_module_start();
Collapsible_content[FILENAME] = "node_modules/bits-ui/dist/bits/collapsible/components/collapsible-content.svelte";
var root_37 = add_locations(template(`<div><!></div>`), Collapsible_content[FILENAME], [[26, 1]]);
var root_54 = add_locations(template(`<div><!></div>`), Collapsible_content[FILENAME], [[35, 1]]);
var root_74 = add_locations(template(`<div><!></div>`), Collapsible_content[FILENAME], [[45, 1]]);
var root_94 = add_locations(template(`<div><!></div>`), Collapsible_content[FILENAME], [[49, 1]]);
var root_114 = add_locations(template(`<div><!></div>`), Collapsible_content[FILENAME], [[53, 1]]);
function Collapsible_content($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "el"
  ]);
  push($$props, false, Collapsible_content);
  const $$stores = setup_stores();
  const $content = () => (validate_store(content, "content"), store_get(content, "$content", $$stores));
  const $open = () => (validate_store(open, "open"), store_get(open, "$open", $$stores));
  const builder = mutable_source();
  let transition2 = prop($$props, "transition", 8, () => void 0);
  let transitionConfig = prop($$props, "transitionConfig", 8, () => void 0);
  let inTransition = prop($$props, "inTransition", 8, () => void 0);
  let inTransitionConfig = prop($$props, "inTransitionConfig", 8, () => void 0);
  let outTransition = prop($$props, "outTransition", 8, () => void 0);
  let outTransitionConfig = prop($$props, "outTransitionConfig", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { content },
    states: { open },
    getAttrs: getAttrs2
  } = getCtx6();
  const attrs = getAttrs2("content");
  legacy_pre_effect(() => $content(), () => {
    set(builder, $content());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => asChild() && $open(),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      if_block(
        node_2,
        () => transition2() && $open(),
        ($$anchor3) => {
          var div = root_37();
          bind_this(div, ($$value) => el($$value), () => el());
          transition(3, div, transition2, transitionConfig);
          let attributes;
          var node_3 = child(div);
          slot(
            node_3,
            default_slot($$props),
            {
              get builder() {
                return get2(builder);
              }
            },
            null
          );
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
          action(div, ($$node) => get2(builder).action($$node));
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          if_block(
            node_4,
            () => inTransition() && outTransition() && $open(),
            ($$anchor4) => {
              var div_1 = root_54();
              bind_this(div_1, ($$value) => el($$value), () => el());
              transition(1, div_1, inTransition, inTransitionConfig);
              transition(2, div_1, outTransition, outTransitionConfig);
              let attributes_1;
              var node_5 = child(div_1);
              slot(
                node_5,
                default_slot($$props),
                {
                  get builder() {
                    return get2(builder);
                  }
                },
                null
              );
              reset(div_1);
              template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get2(builder), ...$$restProps }, true, ""));
              action(div_1, ($$node) => get2(builder).action($$node));
              append($$anchor4, div_1);
            },
            ($$anchor4) => {
              var fragment_4 = comment();
              var node_6 = first_child(fragment_4);
              if_block(
                node_6,
                () => inTransition() && $open(),
                ($$anchor5) => {
                  var div_2 = root_74();
                  bind_this(div_2, ($$value) => el($$value), () => el());
                  transition(1, div_2, inTransition, inTransitionConfig);
                  let attributes_2;
                  var node_7 = child(div_2);
                  slot(
                    node_7,
                    default_slot($$props),
                    {
                      get builder() {
                        return get2(builder);
                      }
                    },
                    null
                  );
                  reset(div_2);
                  template_effect(() => attributes_2 = set_attributes(div_2, attributes_2, { ...get2(builder), ...$$restProps }, true, ""));
                  action(div_2, ($$node) => get2(builder).action($$node));
                  append($$anchor5, div_2);
                },
                ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_8 = first_child(fragment_5);
                  if_block(
                    node_8,
                    () => outTransition() && $open(),
                    ($$anchor6) => {
                      var div_3 = root_94();
                      bind_this(div_3, ($$value) => el($$value), () => el());
                      transition(2, div_3, outTransition, outTransitionConfig);
                      let attributes_3;
                      var node_9 = child(div_3);
                      slot(
                        node_9,
                        default_slot($$props),
                        {
                          get builder() {
                            return get2(builder);
                          }
                        },
                        null
                      );
                      reset(div_3);
                      template_effect(() => attributes_3 = set_attributes(div_3, attributes_3, { ...get2(builder), ...$$restProps }, true, ""));
                      action(div_3, ($$node) => get2(builder).action($$node));
                      append($$anchor6, div_3);
                    },
                    ($$anchor6) => {
                      var fragment_6 = comment();
                      var node_10 = first_child(fragment_6);
                      if_block(
                        node_10,
                        $open,
                        ($$anchor7) => {
                          var div_4 = root_114();
                          bind_this(div_4, ($$value) => el($$value), () => el());
                          let attributes_4;
                          var node_11 = child(div_4);
                          slot(
                            node_11,
                            default_slot($$props),
                            {
                              get builder() {
                                return get2(builder);
                              }
                            },
                            null
                          );
                          reset(div_4);
                          template_effect(() => attributes_4 = set_attributes(div_4, attributes_4, { ...get2(builder), ...$$restProps }, true, ""));
                          action(div_4, ($$node) => get2(builder).action($$node));
                          append($$anchor7, div_4);
                        },
                        null,
                        true
                      );
                      append($$anchor6, fragment_6);
                    },
                    true
                  );
                  append($$anchor5, fragment_5);
                },
                true
              );
              append($$anchor4, fragment_4);
            },
            true
          );
          append($$anchor3, fragment_3);
        },
        true
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Collapsible_content);
  const filename = Collapsible_content.filename;
  const $$original = Collapsible_content;
  Collapsible_content = hmr(s);
  Collapsible_content.filename = filename;
  Collapsible_content[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var collapsible_content_default = Collapsible_content;
mark_module_end(Collapsible_content);

// node_modules/bits-ui/dist/bits/collapsible/components/collapsible-trigger.svelte
mark_module_start();
Collapsible_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/collapsible/components/collapsible-trigger.svelte";
var root_225 = add_locations(template(`<button><!></button>`), Collapsible_trigger[FILENAME], [[21, 1]]);
function Collapsible_trigger($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Collapsible_trigger);
  const $$stores = setup_stores();
  const $trigger = () => (validate_store(trigger, "trigger"), store_get(trigger, "$trigger", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { trigger }, getAttrs: getAttrs2 } = getCtx6();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("trigger");
  legacy_pre_effect(() => $trigger(), () => {
    set(builder, $trigger());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_225();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Collapsible_trigger);
  const filename = Collapsible_trigger.filename;
  const $$original = Collapsible_trigger;
  Collapsible_trigger = hmr(s);
  Collapsible_trigger.filename = filename;
  Collapsible_trigger[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var collapsible_trigger_default = Collapsible_trigger;
mark_module_end(Collapsible_trigger);

// node_modules/bits-ui/dist/bits/combobox/index.js
var combobox_exports = {};
__export(combobox_exports, {
  Arrow: () => combobox_arrow_default,
  Content: () => combobox_content_default,
  Group: () => combobox_group_default,
  GroupLabel: () => combobox_group_label_default,
  HiddenInput: () => combobox_hidden_input_default,
  Input: () => combobox_input_default,
  Item: () => combobox_item_default,
  ItemIndicator: () => combobox_item_indicator_default,
  Label: () => combobox_label_default,
  Root: () => combobox_default,
  Separator: () => separator_default
});

// node_modules/bits-ui/dist/bits/floating/helpers.js
function getPositioningUpdater(store) {
  return (props = {}) => {
    return updatePositioning(store, props);
  };
}
function updatePositioning(store, props) {
  const defaultPositioningProps = {
    side: "bottom",
    align: "center",
    sideOffset: 0,
    alignOffset: 0,
    sameWidth: false,
    avoidCollisions: true,
    collisionPadding: 8,
    fitViewport: false,
    strategy: "absolute",
    overlap: false
  };
  const withDefaults = { ...defaultPositioningProps, ...props };
  store.update((prev2) => {
    return {
      ...prev2,
      placement: joinPlacement(withDefaults.side, withDefaults.align),
      offset: {
        ...prev2.offset,
        mainAxis: withDefaults.sideOffset,
        crossAxis: withDefaults.alignOffset
      },
      gutter: 0,
      sameWidth: withDefaults.sameWidth,
      flip: withDefaults.avoidCollisions,
      overflowPadding: withDefaults.collisionPadding,
      boundary: withDefaults.collisionBoundary,
      fitViewport: withDefaults.fitViewport,
      strategy: withDefaults.strategy,
      overlap: withDefaults.overlap
    };
  });
}
function joinPlacement(side, align) {
  if (align === "center")
    return side;
  return `${side}-${align}`;
}

// node_modules/bits-ui/dist/bits/combobox/ctx.js
function getSelectData() {
  const NAME = "combobox";
  const GROUP_NAME = "combobox-group";
  const ITEM_NAME = "combobox-item";
  const PARTS = [
    "content",
    "menu",
    "input",
    "item",
    "label",
    "group",
    "group-label",
    "arrow",
    "hidden-input",
    "indicator"
  ];
  return {
    NAME,
    GROUP_NAME,
    ITEM_NAME,
    PARTS
  };
}
function getCtx7() {
  const { NAME } = getSelectData();
  return getContext(NAME);
}
function setCtx7(props) {
  const { NAME, PARTS } = getSelectData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const combobox = {
    ...createCombobox({ ...removeUndefined2(props), forceVisible: true }),
    getAttrs: getAttrs2
  };
  setContext(NAME, combobox);
  return {
    ...combobox,
    updateOption: getOptionUpdater(combobox.options)
  };
}
function setGroupCtx() {
  const { GROUP_NAME } = getSelectData();
  const id = generateId2();
  setContext(GROUP_NAME, id);
  const { elements: { group }, getAttrs: getAttrs2 } = getCtx7();
  return { group, id, getAttrs: getAttrs2 };
}
function setItemCtx(value) {
  const { ITEM_NAME } = getSelectData();
  const combobox = getCtx7();
  setContext(ITEM_NAME, value);
  return combobox;
}
function getGroupLabel() {
  const { GROUP_NAME } = getSelectData();
  const id = getContext(GROUP_NAME);
  const { elements: { groupLabel }, getAttrs: getAttrs2 } = getCtx7();
  return { groupLabel, id, getAttrs: getAttrs2 };
}
function getItemIndicator() {
  const { ITEM_NAME } = getSelectData();
  const { helpers: { isSelected }, getAttrs: getAttrs2 } = getCtx7();
  const value = getContext(ITEM_NAME);
  return {
    value,
    isSelected,
    getAttrs: getAttrs2
  };
}
function setArrow(size2 = 8) {
  var _a;
  const combobox = getCtx7();
  (_a = combobox.options.arrowSize) == null ? void 0 : _a.set(size2);
  return combobox;
}
function updatePositioning2(props) {
  const defaultPlacement = {
    side: "bottom",
    align: "center",
    sameWidth: true
  };
  const withDefaults = { ...defaultPlacement, ...props };
  const { options: { positioning } } = getCtx7();
  const updater = getPositioningUpdater(positioning);
  updater(withDefaults);
}

// node_modules/bits-ui/dist/bits/combobox/components/combobox.svelte
mark_module_start();
Combobox[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox.svelte";
function Combobox($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Combobox);
  const $$stores = setup_stores();
  const $localTouchedInput = () => (validate_store(localTouchedInput, "localTouchedInput"), store_get(localTouchedInput, "$localTouchedInput", $$stores));
  const $localInputValue = () => (validate_store(localInputValue, "localInputValue"), store_get(localInputValue, "$localInputValue", $$stores));
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  let required = prop($$props, "required", 8, () => void 0);
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let preventScroll = prop($$props, "preventScroll", 8, () => void 0);
  let loop = prop($$props, "loop", 8, () => void 0);
  let closeOnEscape = prop($$props, "closeOnEscape", 8, () => void 0);
  let closeOnOutsideClick = prop($$props, "closeOnOutsideClick", 8, () => void 0);
  let portal = prop($$props, "portal", 8, () => void 0);
  let name27 = prop($$props, "name", 8, () => void 0);
  let multiple = prop($$props, "multiple", 0, false);
  let selected = prop($$props, "selected", 12, () => void 0);
  let onSelectedChange = prop($$props, "onSelectedChange", 8, () => void 0);
  let open = prop($$props, "open", 12, () => void 0);
  let onOpenChange = prop($$props, "onOpenChange", 8, () => void 0);
  let items = prop($$props, "items", 8, () => []);
  let onOutsideClick = prop($$props, "onOutsideClick", 8, () => void 0);
  let inputValue = prop($$props, "inputValue", 4, "");
  let touchedInput = prop($$props, "touchedInput", 4, false);
  const {
    states: {
      open: localOpen,
      selected: localSelected,
      inputValue: localInputValue,
      touchedInput: localTouchedInput
    },
    updateOption,
    ids
  } = setCtx7({
    required: required(),
    disabled: disabled(),
    preventScroll: preventScroll(),
    loop: loop(),
    closeOnEscape: closeOnEscape(),
    closeOnOutsideClick: closeOnOutsideClick(),
    portal: portal(),
    name: name27(),
    onOutsideClick: onOutsideClick(),
    multiple: multiple(),
    forceVisible: true,
    defaultSelected: Array.isArray(selected()) ? [...selected()] : selected(),
    defaultOpen: open(),
    onSelectedChange: ({ next: next2 }) => {
      var _a, _b;
      if (Array.isArray(next2)) {
        if (!Array.isArray(selected()) || !arraysAreEqual(selected(), next2)) {
          (_a = onSelectedChange()) == null ? void 0 : _a(next2);
          selected(next2);
          return next2;
        }
        return next2;
      }
      if (selected() !== next2) {
        (_b = onSelectedChange()) == null ? void 0 : _b(next2);
        selected(next2);
      }
      inputValue((next2 == null ? void 0 : next2.label) ?? (typeof (next2 == null ? void 0 : next2.value) === "string" ? next2 == null ? void 0 : next2.value : ""));
      localInputValue.set(inputValue());
      return next2;
    },
    onOpenChange: ({ next: next2 }) => {
      var _a;
      if (open() !== next2) {
        (_a = onOpenChange()) == null ? void 0 : _a(next2);
        open(next2);
      }
      return next2;
    },
    items: items()
  });
  const idValues = derived([ids.menu, ids.trigger, ids.label], ([$menuId, $triggerId, $labelId]) => ({
    menu: $menuId,
    trigger: $triggerId,
    label: $labelId
  }));
  legacy_pre_effect(() => $localTouchedInput(), () => {
    touchedInput($localTouchedInput());
  });
  legacy_pre_effect(
    () => ($localTouchedInput(), $localInputValue()),
    () => {
      if ($localTouchedInput()) inputValue($localInputValue());
    }
  );
  legacy_pre_effect(() => deep_read_state(inputValue()), () => {
    inputValue() !== void 0 && localInputValue.set(inputValue());
  });
  legacy_pre_effect(() => deep_read_state(open()), () => {
    open() !== void 0 && localOpen.set(open());
  });
  legacy_pre_effect(() => deep_read_state(selected()), () => {
    selected() !== void 0 && localSelected.set(Array.isArray(selected()) ? [...selected()] : selected());
  });
  legacy_pre_effect(() => deep_read_state(required()), () => {
    updateOption("required", required());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => deep_read_state(preventScroll()), () => {
    updateOption("preventScroll", preventScroll());
  });
  legacy_pre_effect(() => deep_read_state(loop()), () => {
    updateOption("loop", loop());
  });
  legacy_pre_effect(() => deep_read_state(closeOnEscape()), () => {
    updateOption("closeOnEscape", closeOnEscape());
  });
  legacy_pre_effect(
    () => deep_read_state(closeOnOutsideClick()),
    () => {
      updateOption("closeOnOutsideClick", closeOnOutsideClick());
    }
  );
  legacy_pre_effect(() => deep_read_state(portal()), () => {
    updateOption("portal", portal());
  });
  legacy_pre_effect(() => deep_read_state(name27()), () => {
    updateOption("name", name27());
  });
  legacy_pre_effect(() => deep_read_state(multiple()), () => {
    updateOption("multiple", multiple());
  });
  legacy_pre_effect(() => deep_read_state(onOutsideClick()), () => {
    updateOption("onOutsideClick", onOutsideClick());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get ids() {
        return $idValues();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Combobox);
  const filename = Combobox.filename;
  const $$original = Combobox;
  Combobox = hmr(s);
  Combobox.filename = filename;
  Combobox[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var combobox_default = Combobox;
mark_module_end(Combobox);

// node_modules/bits-ui/dist/bits/combobox/components/combobox-content.svelte
mark_module_start();
Combobox_content[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox-content.svelte";
var root_38 = add_locations(template(`<div><!></div>`), Combobox_content[FILENAME], [[57, 1]]);
var root_55 = add_locations(template(`<div><!></div>`), Combobox_content[FILENAME], [[68, 1]]);
var root_75 = add_locations(template(`<div><!></div>`), Combobox_content[FILENAME], [[80, 1]]);
var root_95 = add_locations(template(`<div><!></div>`), Combobox_content[FILENAME], [[90, 1]]);
var root_115 = add_locations(template(`<div><!></div>`), Combobox_content[FILENAME], [[101, 1]]);
function Combobox_content($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "side",
    "align",
    "sideOffset",
    "alignOffset",
    "collisionPadding",
    "avoidCollisions",
    "collisionBoundary",
    "sameWidth",
    "fitViewport",
    "el"
  ]);
  push($$props, false, Combobox_content);
  const $$stores = setup_stores();
  const $menu = () => (validate_store(menu, "menu"), store_get(menu, "$menu", $$stores));
  const $open = () => (validate_store(open, "open"), store_get(open, "$open", $$stores));
  const builder = mutable_source();
  let transition2 = prop($$props, "transition", 8, () => void 0);
  let transitionConfig = prop($$props, "transitionConfig", 8, () => void 0);
  let inTransition = prop($$props, "inTransition", 8, () => void 0);
  let inTransitionConfig = prop($$props, "inTransitionConfig", 8, () => void 0);
  let outTransition = prop($$props, "outTransition", 8, () => void 0);
  let outTransitionConfig = prop($$props, "outTransitionConfig", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let side = prop($$props, "side", 0, "bottom");
  let align = prop($$props, "align", 0, "center");
  let sideOffset = prop($$props, "sideOffset", 0, 0);
  let alignOffset = prop($$props, "alignOffset", 0, 0);
  let collisionPadding = prop($$props, "collisionPadding", 0, 8);
  let avoidCollisions = prop($$props, "avoidCollisions", 0, true);
  let collisionBoundary = prop($$props, "collisionBoundary", 8, () => void 0);
  let sameWidth = prop($$props, "sameWidth", 0, true);
  let fitViewport = prop($$props, "fitViewport", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { menu },
    states: { open },
    ids,
    getAttrs: getAttrs2
  } = getCtx7();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("content");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.menu.set(id());
    }
  });
  legacy_pre_effect(() => $menu(), () => {
    set(builder, $menu());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(
    () => ($open(), deep_read_state(side()), deep_read_state(align()), deep_read_state(sideOffset()), deep_read_state(alignOffset()), deep_read_state(collisionPadding()), deep_read_state(avoidCollisions()), deep_read_state(collisionBoundary()), deep_read_state(sameWidth()), deep_read_state(fitViewport())),
    () => {
      if ($open()) updatePositioning2({
        side: side(),
        align: align(),
        sideOffset: sideOffset(),
        alignOffset: alignOffset(),
        collisionPadding: collisionPadding(),
        avoidCollisions: avoidCollisions(),
        collisionBoundary: collisionBoundary(),
        sameWidth: sameWidth(),
        fitViewport: fitViewport()
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => asChild() && $open(),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      if_block(
        node_2,
        () => transition2() && $open(),
        ($$anchor3) => {
          var div = root_38();
          bind_this(div, ($$value) => el($$value), () => el());
          transition(3, div, transition2, transitionConfig);
          let attributes;
          var node_3 = child(div);
          slot(
            node_3,
            default_slot($$props),
            {
              get builder() {
                return get2(builder);
              }
            },
            null
          );
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
          action(div, ($$node) => get2(builder).action($$node));
          event("m-pointerleave", div, dispatch, false);
          event("keydown", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          if_block(
            node_4,
            () => inTransition() && outTransition() && $open(),
            ($$anchor4) => {
              var div_1 = root_55();
              bind_this(div_1, ($$value) => el($$value), () => el());
              transition(1, div_1, inTransition, inTransitionConfig);
              transition(2, div_1, outTransition, outTransitionConfig);
              let attributes_1;
              var node_5 = child(div_1);
              slot(
                node_5,
                default_slot($$props),
                {
                  get builder() {
                    return get2(builder);
                  }
                },
                null
              );
              reset(div_1);
              template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get2(builder), ...$$restProps }, true, ""));
              action(div_1, ($$node) => get2(builder).action($$node));
              event("m-pointerleave", div_1, dispatch, false);
              event("keydown", div_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              append($$anchor4, div_1);
            },
            ($$anchor4) => {
              var fragment_4 = comment();
              var node_6 = first_child(fragment_4);
              if_block(
                node_6,
                () => inTransition() && $open(),
                ($$anchor5) => {
                  var div_2 = root_75();
                  transition(1, div_2, inTransition, inTransitionConfig);
                  let attributes_2;
                  var node_7 = child(div_2);
                  slot(
                    node_7,
                    default_slot($$props),
                    {
                      get builder() {
                        return get2(builder);
                      }
                    },
                    null
                  );
                  reset(div_2);
                  template_effect(() => attributes_2 = set_attributes(div_2, attributes_2, { ...get2(builder), ...$$restProps }, true, ""));
                  action(div_2, ($$node) => get2(builder).action($$node));
                  event("m-pointerleave", div_2, dispatch, false);
                  event("keydown", div_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  append($$anchor5, div_2);
                },
                ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_8 = first_child(fragment_5);
                  if_block(
                    node_8,
                    () => outTransition() && $open(),
                    ($$anchor6) => {
                      var div_3 = root_95();
                      bind_this(div_3, ($$value) => el($$value), () => el());
                      transition(2, div_3, outTransition, outTransitionConfig);
                      let attributes_3;
                      var node_9 = child(div_3);
                      slot(
                        node_9,
                        default_slot($$props),
                        {
                          get builder() {
                            return get2(builder);
                          }
                        },
                        null
                      );
                      reset(div_3);
                      template_effect(() => attributes_3 = set_attributes(div_3, attributes_3, { ...get2(builder), ...$$restProps }, true, ""));
                      action(div_3, ($$node) => get2(builder).action($$node));
                      event("m-pointerleave", div_3, dispatch, false);
                      event("keydown", div_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      append($$anchor6, div_3);
                    },
                    ($$anchor6) => {
                      var fragment_6 = comment();
                      var node_10 = first_child(fragment_6);
                      if_block(
                        node_10,
                        $open,
                        ($$anchor7) => {
                          var div_4 = root_115();
                          bind_this(div_4, ($$value) => el($$value), () => el());
                          let attributes_4;
                          var node_11 = child(div_4);
                          slot(
                            node_11,
                            default_slot($$props),
                            {
                              get builder() {
                                return get2(builder);
                              }
                            },
                            null
                          );
                          reset(div_4);
                          template_effect(() => attributes_4 = set_attributes(div_4, attributes_4, { ...get2(builder), ...$$restProps }, true, ""));
                          action(div_4, ($$node) => get2(builder).action($$node));
                          event("m-pointerleave", div_4, dispatch, false);
                          event("keydown", div_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          append($$anchor7, div_4);
                        },
                        null,
                        true
                      );
                      append($$anchor6, fragment_6);
                    },
                    true
                  );
                  append($$anchor5, fragment_5);
                },
                true
              );
              append($$anchor4, fragment_4);
            },
            true
          );
          append($$anchor3, fragment_3);
        },
        true
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Combobox_content);
  const filename = Combobox_content.filename;
  const $$original = Combobox_content;
  Combobox_content = hmr(s);
  Combobox_content.filename = filename;
  Combobox_content[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var combobox_content_default = Combobox_content;
mark_module_end(Combobox_content);

// node_modules/bits-ui/dist/bits/combobox/components/combobox-input.svelte
mark_module_start();
Combobox_input[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox-input.svelte";
var root_226 = add_locations(template(`<input>`), Combobox_input[FILENAME], [[28, 1]]);
function Combobox_input($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "placeholder", "el", "id"]);
  push($$props, false, Combobox_input);
  const $$stores = setup_stores();
  const $input = () => (validate_store(input, "input"), store_get(input, "$input", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let placeholder = prop($$props, "placeholder", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  let id = prop($$props, "id", 8, () => void 0);
  const { elements: { input }, ids, getAttrs: getAttrs2 } = getCtx7();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("input");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.trigger.set(id());
    }
  });
  legacy_pre_effect(() => $input(), () => {
    set(builder, $input());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get placeholder() {
            return placeholder();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var input_1 = root_226();
      bind_this(input_1, ($$value) => el($$value), () => el());
      remove_input_defaults(input_1);
      let attributes;
      template_effect(() => attributes = set_attributes(
        input_1,
        attributes,
        {
          ...get2(builder),
          ...$$restProps,
          placeholder: placeholder()
        },
        true,
        ""
      ));
      action(input_1, ($$node) => get2(builder).action($$node));
      event("m-click", input_1, dispatch, false);
      event("m-keydown", input_1, dispatch, false);
      event("m-input", input_1, dispatch, false);
      append($$anchor2, input_1);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Combobox_input);
  const filename = Combobox_input.filename;
  const $$original = Combobox_input;
  Combobox_input = hmr(s);
  Combobox_input.filename = filename;
  Combobox_input[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var combobox_input_default = Combobox_input;
mark_module_end(Combobox_input);

// node_modules/bits-ui/dist/bits/combobox/components/combobox-item.svelte
mark_module_start();
Combobox_item[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox-item.svelte";
var root_227 = add_locations(template(`<div><!></div>`), Combobox_item[FILENAME], [[31, 1]]);
function Combobox_item($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "value",
    "disabled",
    "label",
    "asChild",
    "el"
  ]);
  push($$props, false, Combobox_item);
  const $$stores = setup_stores();
  const $item = () => (validate_store(item, "item"), store_get(item, "$item", $$stores));
  const $isSelectedStore = () => (validate_store(isSelectedStore, "isSelectedStore"), store_get(isSelectedStore, "$isSelectedStore", $$stores));
  const builder = mutable_source();
  const isSelected = mutable_source();
  let value = prop($$props, "value");
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let label = prop($$props, "label", 12, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { option: item },
    helpers: { isSelected: isSelectedStore },
    getAttrs: getAttrs2
  } = setItemCtx(value());
  const dispatch = createDispatcher();
  const attrs = getAttrs2("item");
  legacy_pre_effect(
    () => (deep_read_state(label()), deep_read_state(value())),
    () => {
      if (!label() && typeof value() === "string") label(value());
    }
  );
  legacy_pre_effect(
    () => ($item(), deep_read_state(value()), deep_read_state(disabled()), deep_read_state(label())),
    () => {
      set(builder, $item()({
        value: value(),
        disabled: disabled(),
        label: label()
      }));
    }
  );
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(
    () => ($isSelectedStore(), deep_read_state(value())),
    () => {
      set(isSelected, $isSelectedStore()(value()));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get isSelected() {
            return get2(isSelected);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_227();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get isSelected() {
            return get2(isSelected);
          }
        },
        ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, label() || value()));
          append($$anchor3, text2);
        }
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      event("m-click", div, dispatch, false);
      event("m-pointermove", div, dispatch, false);
      event("focusin", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event("keydown", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event("focusout", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event("pointerleave", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Combobox_item);
  const filename = Combobox_item.filename;
  const $$original = Combobox_item;
  Combobox_item = hmr(s);
  Combobox_item.filename = filename;
  Combobox_item[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var combobox_item_default = Combobox_item;
mark_module_end(Combobox_item);

// node_modules/bits-ui/dist/bits/combobox/components/combobox-label.svelte
mark_module_start();
Combobox_label[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox-label.svelte";
var root_228 = add_locations(template(`<label><!></label>`), Combobox_label[FILENAME], [[19, 1]]);
function Combobox_label($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Combobox_label);
  const $$stores = setup_stores();
  const $label = () => (validate_store(label, "label"), store_get(label, "$label", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { label }, getAttrs: getAttrs2 } = getCtx7();
  const attrs = getAttrs2("label");
  legacy_pre_effect(() => $label(), () => {
    set(builder, $label());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var label_1 = root_228();
      bind_this(label_1, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(label_1);
      slot(node_2, default_slot($$props), {}, null);
      reset(label_1);
      template_effect(() => attributes = set_attributes(
        label_1,
        attributes,
        {
          ...get2(builder),
          ...$$restProps,
          for: get2(builder).id
        },
        true,
        ""
      ));
      action(label_1, ($$node) => get2(builder).action($$node));
      append($$anchor2, label_1);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Combobox_label);
  const filename = Combobox_label.filename;
  const $$original = Combobox_label;
  Combobox_label = hmr(s);
  Combobox_label.filename = filename;
  Combobox_label[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var combobox_label_default = Combobox_label;
mark_module_end(Combobox_label);

// node_modules/bits-ui/dist/bits/combobox/components/combobox-group.svelte
mark_module_start();
Combobox_group[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox-group.svelte";
var root_229 = add_locations(template(`<div><!></div>`), Combobox_group[FILENAME], [[16, 1]]);
function Combobox_group($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Combobox_group);
  const $$stores = setup_stores();
  const $group = () => (validate_store(group, "group"), store_get(group, "$group", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { group, id, getAttrs: getAttrs2 } = setGroupCtx();
  const attrs = getAttrs2("group");
  legacy_pre_effect(() => $group(), () => {
    set(builder, $group()(id));
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_229();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Combobox_group);
  const filename = Combobox_group.filename;
  const $$original = Combobox_group;
  Combobox_group = hmr(s);
  Combobox_group.filename = filename;
  Combobox_group[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var combobox_group_default = Combobox_group;
mark_module_end(Combobox_group);

// node_modules/bits-ui/dist/bits/combobox/components/combobox-group-label.svelte
mark_module_start();
Combobox_group_label[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox-group-label.svelte";
var root_230 = add_locations(template(`<div><!></div>`), Combobox_group_label[FILENAME], [[22, 1]]);
function Combobox_group_label($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Combobox_group_label);
  const $$stores = setup_stores();
  const $groupLabel = () => (validate_store(groupLabel, "groupLabel"), store_get(groupLabel, "$groupLabel", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { ids, getAttrs: getAttrs2 } = getCtx7();
  const { groupLabel, id: groupId } = getGroupLabel();
  const attrs = getAttrs2("group-label");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.label.set(id());
    }
  });
  legacy_pre_effect(() => $groupLabel(), () => {
    set(builder, $groupLabel()(groupId));
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_230();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Combobox_group_label);
  const filename = Combobox_group_label.filename;
  const $$original = Combobox_group_label;
  Combobox_group_label = hmr(s);
  Combobox_group_label.filename = filename;
  Combobox_group_label[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var combobox_group_label_default = Combobox_group_label;
mark_module_end(Combobox_group_label);

// node_modules/bits-ui/dist/bits/combobox/components/combobox-arrow.svelte
mark_module_start();
Combobox_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox-arrow.svelte";
var root_231 = add_locations(template(`<div></div>`), Combobox_arrow[FILENAME], [[20, 1]]);
function Combobox_arrow($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el", "size"]);
  push($$props, false, Combobox_arrow);
  const $$stores = setup_stores();
  const $arrow = () => (validate_store(arrow2, "arrow"), store_get(arrow2, "$arrow", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  let size2 = prop($$props, "size", 0, 8);
  const { elements: { arrow: arrow2 }, getAttrs: getAttrs2 } = setArrow(size2());
  const attrs = getAttrs2("arrow");
  legacy_pre_effect(() => $arrow(), () => {
    set(builder, $arrow());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_231();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Combobox_arrow);
  const filename = Combobox_arrow.filename;
  const $$original = Combobox_arrow;
  Combobox_arrow = hmr(s);
  Combobox_arrow.filename = filename;
  Combobox_arrow[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var combobox_arrow_default = Combobox_arrow;
mark_module_end(Combobox_arrow);

// node_modules/bits-ui/dist/bits/combobox/components/combobox-hidden-input.svelte
mark_module_start();
Combobox_hidden_input[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox-hidden-input.svelte";
var root_232 = add_locations(template(`<input>`), Combobox_hidden_input[FILENAME], [[24, 1]]);
function Combobox_hidden_input($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Combobox_hidden_input);
  const $$stores = setup_stores();
  const $disabled = () => (validate_store(disabled, "disabled"), store_get(disabled, "$disabled", $$stores));
  const $hiddenInput = () => (validate_store(hiddenInput, "hiddenInput"), store_get(hiddenInput, "$hiddenInput", $$stores));
  const attrs = mutable_source();
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { hiddenInput },
    options: { disabled },
    getAttrs: getAttrs2
  } = getCtx7();
  legacy_pre_effect(() => $disabled(), () => {
    set(attrs, {
      ...getAttrs2("input"),
      disabled: $disabled() ? true : void 0
    });
  });
  legacy_pre_effect(() => $hiddenInput(), () => {
    set(builder, $hiddenInput());
  });
  legacy_pre_effect(() => (get2(builder), get2(attrs)), () => {
    Object.assign(get2(builder), get2(attrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var input = root_232();
      bind_this(input, ($$value) => el($$value), () => el());
      remove_input_defaults(input);
      let attributes;
      template_effect(() => attributes = set_attributes(input, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(input, ($$node) => get2(builder).action($$node));
      append($$anchor2, input);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Combobox_hidden_input);
  const filename = Combobox_hidden_input.filename;
  const $$original = Combobox_hidden_input;
  Combobox_hidden_input = hmr(s);
  Combobox_hidden_input.filename = filename;
  Combobox_hidden_input[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var combobox_hidden_input_default = Combobox_hidden_input;
mark_module_end(Combobox_hidden_input);

// node_modules/bits-ui/dist/bits/separator/ctx.js
function getSeparatorData() {
  const NAME = "separator";
  const PARTS = ["root"];
  return {
    NAME,
    PARTS
  };
}
function setCtx8(props) {
  const { NAME, PARTS } = getSeparatorData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const separator = { ...createSeparator(removeUndefined2(props)), getAttrs: getAttrs2 };
  return {
    ...separator,
    updateOption: getOptionUpdater(separator.options)
  };
}

// node_modules/bits-ui/dist/bits/separator/components/separator.svelte
mark_module_start();
Separator[FILENAME] = "node_modules/bits-ui/dist/bits/separator/components/separator.svelte";
var root_39 = add_locations(template(`<div></div>`), Separator[FILENAME], [[26, 1]]);
function Separator($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "orientation",
    "decorative",
    "asChild",
    "el"
  ]);
  push($$props, false, Separator);
  const $$stores = setup_stores();
  const $root = () => (validate_store(root5, "root"), store_get(root5, "$root", $$stores));
  const builder = mutable_source();
  let orientation = prop($$props, "orientation", 0, "horizontal");
  let decorative = prop($$props, "decorative", 0, true);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { root: root5 }, updateOption, getAttrs: getAttrs2 } = setCtx8({
    orientation: orientation(),
    decorative: decorative()
  });
  const attrs = getAttrs2("root");
  legacy_pre_effect(() => deep_read_state(orientation()), () => {
    updateOption("orientation", orientation());
  });
  legacy_pre_effect(() => deep_read_state(decorative()), () => {
    updateOption("decorative", decorative());
  });
  legacy_pre_effect(() => $root(), () => {
    set(builder, $root());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_39();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Separator);
  const filename = Separator.filename;
  const $$original = Separator;
  Separator = hmr(s);
  Separator.filename = filename;
  Separator[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var separator_default = Separator;
mark_module_end(Separator);

// node_modules/bits-ui/dist/bits/combobox/components/combobox-item-indicator.svelte
mark_module_start();
Combobox_item_indicator[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox-item-indicator.svelte";
var root_233 = add_locations(template(`<div><!></div>`), Combobox_item_indicator[FILENAME], [[11, 1]]);
function Combobox_item_indicator($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Combobox_item_indicator);
  const $$stores = setup_stores();
  const $isSelected = () => (validate_store(isSelected, "isSelected"), store_get(isSelected, "$isSelected", $$stores));
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { isSelected, value, getAttrs: getAttrs2 } = getItemIndicator();
  const attrs = getAttrs2("indicator");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          attrs,
          get isSelected() {
            return $isSelected()(value);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_233();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      if_block(node_2, () => $isSelected()(value), ($$anchor3) => {
        var fragment_2 = comment();
        var node_3 = first_child(fragment_2);
        slot(
          node_3,
          default_slot($$props),
          {
            attrs,
            get isSelected() {
              return $isSelected()(value);
            }
          },
          null
        );
        append($$anchor3, fragment_2);
      });
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Combobox_item_indicator);
  const filename = Combobox_item_indicator.filename;
  const $$original = Combobox_item_indicator;
  Combobox_item_indicator = hmr(s);
  Combobox_item_indicator.filename = filename;
  Combobox_item_indicator[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var combobox_item_indicator_default = Combobox_item_indicator;
mark_module_end(Combobox_item_indicator);

// node_modules/bits-ui/dist/bits/context-menu/index.js
var context_menu_exports = {};
__export(context_menu_exports, {
  Arrow: () => menu_arrow_default,
  CheckboxIndicator: () => menu_checkbox_indicator_default,
  CheckboxItem: () => menu_checkbox_item_default,
  Content: () => context_menu_content_default,
  Group: () => menu_group_default,
  Item: () => menu_item_default,
  Label: () => menu_label_default,
  RadioGroup: () => menu_radio_group_default,
  RadioIndicator: () => menu_radio_indicator_default,
  RadioItem: () => menu_radio_item_default,
  Root: () => context_menu_default,
  Separator: () => menu_separator_default,
  Sub: () => menu_sub_default,
  SubContent: () => menu_sub_content_default,
  SubTrigger: () => menu_sub_trigger_default,
  Trigger: () => context_menu_trigger_default
});

// node_modules/bits-ui/dist/bits/context-menu/ctx.js
function getContextMenuData() {
  const NAME = "menu";
  const PARTS = [
    "arrow",
    "checkbox-indicator",
    "checkbox-item",
    "content",
    "group",
    "item",
    "label",
    "radio-group",
    "radio-item",
    "separator",
    "sub-content",
    "sub-trigger",
    "trigger"
  ];
  return {
    NAME,
    PARTS
  };
}
function setCtx9(props) {
  const { NAME, PARTS } = getContextMenuData();
  const getAttrs2 = createBitAttrs("menu", PARTS);
  const contextMenu = { ...createContextMenu(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(NAME, contextMenu);
  return {
    ...contextMenu,
    updateOption: getOptionUpdater(contextMenu.options)
  };
}
function getCtx8() {
  const { NAME } = getContextMenuData();
  return getContext(NAME);
}
function updatePositioning3(props) {
  const defaultPlacement = {
    side: "bottom",
    align: "start"
  };
  const withDefaults = { ...defaultPlacement, ...props };
  const { options: { positioning } } = getCtx8();
  const updater = getPositioningUpdater(positioning);
  updater(withDefaults);
}

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu.svelte
mark_module_start();
Context_menu[FILENAME] = "node_modules/bits-ui/dist/bits/context-menu/components/context-menu.svelte";
function Context_menu($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Context_menu);
  const $$stores = setup_stores();
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  let closeOnOutsideClick = prop($$props, "closeOnOutsideClick", 8, () => void 0);
  let closeOnEscape = prop($$props, "closeOnEscape", 8, () => void 0);
  let portal = prop($$props, "portal", 8, () => void 0);
  let open = prop($$props, "open", 12, () => void 0);
  let onOpenChange = prop($$props, "onOpenChange", 8, () => void 0);
  let preventScroll = prop($$props, "preventScroll", 8, () => void 0);
  let loop = prop($$props, "loop", 8, () => void 0);
  let dir = prop($$props, "dir", 8, () => void 0);
  let typeahead = prop($$props, "typeahead", 8, () => void 0);
  let closeFocus = prop($$props, "closeFocus", 8, () => void 0);
  let disableFocusFirstItem = prop($$props, "disableFocusFirstItem", 8, () => void 0);
  let onOutsideClick = prop($$props, "onOutsideClick", 8, () => void 0);
  let closeOnItemClick = prop($$props, "closeOnItemClick", 8, () => void 0);
  const {
    states: { open: localOpen },
    updateOption,
    ids
  } = setCtx9({
    closeOnOutsideClick: closeOnOutsideClick(),
    closeOnEscape: closeOnEscape(),
    portal: portal(),
    forceVisible: true,
    defaultOpen: open(),
    preventScroll: preventScroll(),
    loop: loop(),
    dir: dir(),
    typeahead: typeahead(),
    disableFocusFirstItem: disableFocusFirstItem(),
    closeFocus: closeFocus(),
    onOutsideClick: onOutsideClick(),
    closeOnItemClick: closeOnItemClick(),
    onOpenChange: ({ next: next2 }) => {
      var _a;
      if (open() !== next2) {
        (_a = onOpenChange()) == null ? void 0 : _a(next2);
        open(next2);
      }
      return next2;
    }
  });
  const idValues = derived([ids.menu, ids.trigger], ([$menuId, $triggerId]) => ({ menu: $menuId, trigger: $triggerId }));
  legacy_pre_effect(() => deep_read_state(open()), () => {
    open() !== void 0 && localOpen.set(open());
  });
  legacy_pre_effect(() => deep_read_state(closeOnItemClick()), () => {
    updateOption("closeOnItemClick", closeOnItemClick());
  });
  legacy_pre_effect(
    () => deep_read_state(closeOnOutsideClick()),
    () => {
      updateOption("closeOnOutsideClick", closeOnOutsideClick());
    }
  );
  legacy_pre_effect(() => deep_read_state(closeOnEscape()), () => {
    updateOption("closeOnEscape", closeOnEscape());
  });
  legacy_pre_effect(() => deep_read_state(portal()), () => {
    updateOption("portal", portal());
  });
  legacy_pre_effect(() => deep_read_state(preventScroll()), () => {
    updateOption("preventScroll", preventScroll());
  });
  legacy_pre_effect(() => deep_read_state(loop()), () => {
    updateOption("loop", loop());
  });
  legacy_pre_effect(() => deep_read_state(dir()), () => {
    updateOption("dir", dir());
  });
  legacy_pre_effect(() => deep_read_state(closeFocus()), () => {
    updateOption("closeFocus", closeFocus());
  });
  legacy_pre_effect(
    () => deep_read_state(disableFocusFirstItem()),
    () => {
      updateOption("disableFocusFirstItem", disableFocusFirstItem());
    }
  );
  legacy_pre_effect(() => deep_read_state(typeahead()), () => {
    updateOption("typeahead", typeahead());
  });
  legacy_pre_effect(() => deep_read_state(onOutsideClick()), () => {
    updateOption("onOutsideClick", onOutsideClick());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get ids() {
        return $idValues();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Context_menu);
  const filename = Context_menu.filename;
  const $$original = Context_menu;
  Context_menu = hmr(s);
  Context_menu.filename = filename;
  Context_menu[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var context_menu_default = Context_menu;
mark_module_end(Context_menu);

// node_modules/bits-ui/dist/bits/menu/ctx.js
function getMenuData() {
  const NAME = "menu";
  const SUB_NAME = "menu-submenu";
  const RADIO_GROUP_NAME = "menu-radiogroup";
  const CHECKBOX_ITEM_NAME = "menu-checkboxitem";
  const RADIO_ITEM_NAME = "menu-radioitem";
  const GROUP_NAME = "menu-group";
  const PARTS = [
    "arrow",
    "checkbox-indicator",
    "checkbox-item",
    "content",
    "group",
    "item",
    "label",
    "radio-group",
    "radio-item",
    "radio-indicator",
    "separator",
    "sub-content",
    "sub-trigger",
    "trigger"
  ];
  return {
    NAME,
    SUB_NAME,
    RADIO_GROUP_NAME,
    CHECKBOX_ITEM_NAME,
    RADIO_ITEM_NAME,
    GROUP_NAME,
    PARTS
  };
}
function getCtx9() {
  const { NAME } = getMenuData();
  return getContext(NAME);
}
function setCtx10(props) {
  const { NAME, PARTS } = getMenuData();
  const getAttrs2 = createBitAttrs("menu", PARTS);
  const dropdownMenu = {
    ...createDropdownMenu({ ...removeUndefined2(props), forceVisible: true }),
    getAttrs: getAttrs2
  };
  setContext(NAME, dropdownMenu);
  return {
    ...dropdownMenu,
    updateOption: getOptionUpdater(dropdownMenu.options)
  };
}
function setSubMenuCtx(props) {
  const { SUB_NAME } = getMenuData();
  const { builders: { createSubmenu }, getAttrs: getAttrs2 } = getCtx9();
  const sub = { ...createSubmenu(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(SUB_NAME, sub);
  return {
    ...sub,
    updateOption: getOptionUpdater(sub.options)
  };
}
function setRadioGroupCtx(props) {
  const { RADIO_GROUP_NAME } = getMenuData();
  const { builders: { createMenuRadioGroup }, getAttrs: getAttrs2 } = getCtx9();
  const radioGroup = createMenuRadioGroup(props);
  setContext(RADIO_GROUP_NAME, { ...radioGroup, getAttrs: getAttrs2 });
  return {
    ...radioGroup,
    getAttrs: getAttrs2
  };
}
function setRadioItem(value) {
  const { RADIO_ITEM_NAME, RADIO_GROUP_NAME } = getMenuData();
  const dropdownMenu = getContext(RADIO_GROUP_NAME);
  setContext(RADIO_ITEM_NAME, { ...dropdownMenu, value });
  return {
    ...dropdownMenu,
    value
  };
}
function getRadioIndicator() {
  const { RADIO_ITEM_NAME } = getMenuData();
  const radioItem = getContext(RADIO_ITEM_NAME);
  return {
    ...radioItem
  };
}
function getSubTrigger() {
  const { SUB_NAME } = getMenuData();
  const submenu = getContext(SUB_NAME);
  return submenu;
}
function getSubmenuCtx() {
  const { SUB_NAME } = getMenuData();
  return getContext(SUB_NAME);
}
function setCheckboxItem(props) {
  const { CHECKBOX_ITEM_NAME } = getMenuData();
  const { builders: { createCheckboxItem }, getAttrs: getAttrs2 } = getCtx9();
  const checkboxItem = createCheckboxItem(removeUndefined2(props));
  setContext(CHECKBOX_ITEM_NAME, checkboxItem.states.checked);
  return {
    ...checkboxItem,
    updateOption: getOptionUpdater(checkboxItem.options),
    getAttrs: getAttrs2
  };
}
function getCheckboxIndicator() {
  const { CHECKBOX_ITEM_NAME } = getMenuData();
  return getContext(CHECKBOX_ITEM_NAME);
}
function setGroupCtx2() {
  const { GROUP_NAME } = getMenuData();
  const { elements: { group }, getAttrs: getAttrs2 } = getCtx9();
  const id = generateId2();
  setContext(GROUP_NAME, id);
  return { group, id, getAttrs: getAttrs2 };
}
function getGroupLabel2() {
  const { GROUP_NAME } = getMenuData();
  const id = getContext(GROUP_NAME) ?? generateId2();
  const { elements: { groupLabel }, getAttrs: getAttrs2 } = getCtx9();
  return { groupLabel, id, getAttrs: getAttrs2 };
}
function setArrow2(size2 = 8) {
  const menu = getCtx9();
  menu.options.arrowSize.set(size2);
  return menu;
}
function updatePositioning4(props) {
  const defaultPlacement = {
    side: "bottom",
    align: "center"
  };
  const withDefaults = { ...defaultPlacement, ...props };
  const { options: { positioning } } = getCtx9();
  const updater = getPositioningUpdater(positioning);
  updater(withDefaults);
}
function updateSubPositioning(props) {
  const defaultSubPlacement = {
    side: "right",
    align: "start"
  };
  const withDefaults = { ...defaultSubPlacement, ...props };
  const { options: { positioning } } = getSubmenuCtx();
  const updater = getPositioningUpdater(positioning);
  updater(withDefaults);
}

// node_modules/bits-ui/dist/bits/menu/components/menu-sub.svelte
mark_module_start();
Menu_sub[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-sub.svelte";
function Menu_sub($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Menu_sub);
  const $$stores = setup_stores();
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let open = prop($$props, "open", 12, () => void 0);
  let onOpenChange = prop($$props, "onOpenChange", 8, () => void 0);
  const { updateOption, ids, states: { subOpen } } = setSubMenuCtx({
    disabled: disabled(),
    onOpenChange: ({ next: next2 }) => {
      var _a;
      if (open() !== next2) {
        (_a = onOpenChange()) == null ? void 0 : _a(next2);
        open(next2);
      }
      return next2;
    }
  });
  const idValues = derived([ids.menu, ids.trigger], ([$menuId, $triggerId]) => ({ menu: $menuId, trigger: $triggerId }));
  legacy_pre_effect(() => deep_read_state(open()), () => {
    open() !== void 0 && subOpen.set(open());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get subIds() {
        return $idValues();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menu_sub);
  const filename = Menu_sub.filename;
  const $$original = Menu_sub;
  Menu_sub = hmr(s);
  Menu_sub.filename = filename;
  Menu_sub[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menu_sub_default = Menu_sub;
mark_module_end(Menu_sub);

// node_modules/bits-ui/dist/bits/menu/components/menu-item.svelte
mark_module_start();
Menu_item[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-item.svelte";
function Menu_item($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["href", "asChild", "disabled", "el"]);
  push($$props, false, Menu_item);
  const $$stores = setup_stores();
  const $item = () => (validate_store(item, "item"), store_get(item, "$item", $$stores));
  const builder = mutable_source();
  const attrs = mutable_source();
  let href = prop($$props, "href", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let disabled = prop($$props, "disabled", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { item }, getAttrs: getAttrs2 } = getCtx9();
  const dispatch = createDispatcher();
  legacy_pre_effect(() => $item(), () => {
    set(builder, $item());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    set(attrs, {
      ...getAttrs2("item"),
      ...disabledAttrs(disabled())
    });
  });
  legacy_pre_effect(() => (get2(builder), get2(attrs)), () => {
    Object.assign(get2(builder), get2(attrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      validate_void_dynamic_element(() => href() ? "a" : "div");
      validate_dynamic_element_tag(() => href() ? "a" : "div");
      element(
        node_2,
        () => href() ? "a" : "div",
        false,
        ($$element, $$anchor3) => {
          bind_this($$element, ($$value) => el($$value), () => el());
          let attributes;
          template_effect(() => attributes = set_dynamic_element_attributes(
            $$element,
            attributes,
            {
              href: href(),
              ...get2(builder),
              ...$$restProps
            },
            ""
          ));
          action($$element, ($$node) => get2(builder).action($$node));
          event("m-click", $$element, dispatch, false);
          event("m-focusin", $$element, dispatch, false);
          event("m-focusout", $$element, dispatch, false);
          event("m-keydown", $$element, dispatch, false);
          event("m-pointerdown", $$element, dispatch, false);
          event("m-pointerleave", $$element, dispatch, false);
          event("m-pointermove", $$element, dispatch, false);
          event("pointerenter", $$element, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          slot(
            node_3,
            default_slot($$props),
            {
              get builder() {
                return get2(builder);
              }
            },
            null
          );
          append($$anchor3, fragment_3);
        },
        void 0,
        [25, 1]
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menu_item);
  const filename = Menu_item.filename;
  const $$original = Menu_item;
  Menu_item = hmr(s);
  Menu_item.filename = filename;
  Menu_item[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menu_item_default = Menu_item;
mark_module_end(Menu_item);

// node_modules/bits-ui/dist/bits/menu/components/menu-group.svelte
mark_module_start();
Menu_group[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-group.svelte";
var root_234 = add_locations(template(`<div><!></div>`), Menu_group[FILENAME], [[16, 1]]);
function Menu_group($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Menu_group);
  const $$stores = setup_stores();
  const $group = () => (validate_store(group, "group"), store_get(group, "$group", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { group, id, getAttrs: getAttrs2 } = setGroupCtx2();
  const attrs = getAttrs2("group");
  legacy_pre_effect(() => $group(), () => {
    set(builder, $group()(id));
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_234();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menu_group);
  const filename = Menu_group.filename;
  const $$original = Menu_group;
  Menu_group = hmr(s);
  Menu_group.filename = filename;
  Menu_group[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menu_group_default = Menu_group;
mark_module_end(Menu_group);

// node_modules/bits-ui/dist/bits/menu/components/menu-label.svelte
mark_module_start();
Menu_label[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-label.svelte";
var root_235 = add_locations(template(`<div><!></div>`), Menu_label[FILENAME], [[16, 1]]);
function Menu_label($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Menu_label);
  const $$stores = setup_stores();
  const $groupLabel = () => (validate_store(groupLabel, "groupLabel"), store_get(groupLabel, "$groupLabel", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { groupLabel, id, getAttrs: getAttrs2 } = getGroupLabel2();
  const attrs = getAttrs2("label");
  legacy_pre_effect(() => $groupLabel(), () => {
    set(builder, $groupLabel()(id));
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_235();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menu_label);
  const filename = Menu_label.filename;
  const $$original = Menu_label;
  Menu_label = hmr(s);
  Menu_label.filename = filename;
  Menu_label[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menu_label_default = Menu_label;
mark_module_end(Menu_label);

// node_modules/bits-ui/dist/bits/menu/components/menu-arrow.svelte
mark_module_start();
Menu_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-arrow.svelte";
var root_236 = add_locations(template(`<div></div>`), Menu_arrow[FILENAME], [[20, 1]]);
function Menu_arrow($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "asChild", "el"]);
  push($$props, false, Menu_arrow);
  const $$stores = setup_stores();
  const $arrow = () => (validate_store(arrow2, "arrow"), store_get(arrow2, "$arrow", $$stores));
  const builder = mutable_source();
  let size2 = prop($$props, "size", 0, 8);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { arrow: arrow2 }, getAttrs: getAttrs2 } = setArrow2(size2());
  const attrs = getAttrs2("arrow");
  legacy_pre_effect(() => $arrow(), () => {
    set(builder, $arrow());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_236();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menu_arrow);
  const filename = Menu_arrow.filename;
  const $$original = Menu_arrow;
  Menu_arrow = hmr(s);
  Menu_arrow.filename = filename;
  Menu_arrow[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menu_arrow_default = Menu_arrow;
mark_module_end(Menu_arrow);

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu-content.svelte
mark_module_start();
Context_menu_content[FILENAME] = "node_modules/bits-ui/dist/bits/context-menu/components/context-menu-content.svelte";
var root_310 = add_locations(template(`<div><!></div>`), Context_menu_content[FILENAME], [[51, 1]]);
var root_56 = add_locations(template(`<div><!></div>`), Context_menu_content[FILENAME], [[61, 1]]);
var root_76 = add_locations(template(`<div><!></div>`), Context_menu_content[FILENAME], [[72, 1]]);
var root_96 = add_locations(template(`<div><!></div>`), Context_menu_content[FILENAME], [[82, 1]]);
var root_116 = add_locations(template(`<div><!></div>`), Context_menu_content[FILENAME], [[92, 1]]);
function Context_menu_content($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "alignOffset",
    "collisionPadding",
    "avoidCollisions",
    "collisionBoundary",
    "fitViewport",
    "strategy",
    "overlap",
    "el"
  ]);
  push($$props, false, Context_menu_content);
  const $$stores = setup_stores();
  const $menu = () => (validate_store(menu, "menu"), store_get(menu, "$menu", $$stores));
  const $open = () => (validate_store(open, "open"), store_get(open, "$open", $$stores));
  const builder = mutable_source();
  let transition2 = prop($$props, "transition", 8, () => void 0);
  let transitionConfig = prop($$props, "transitionConfig", 8, () => void 0);
  let inTransition = prop($$props, "inTransition", 8, () => void 0);
  let inTransitionConfig = prop($$props, "inTransitionConfig", 8, () => void 0);
  let outTransition = prop($$props, "outTransition", 8, () => void 0);
  let outTransitionConfig = prop($$props, "outTransitionConfig", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let alignOffset = prop($$props, "alignOffset", 0, 0);
  let collisionPadding = prop($$props, "collisionPadding", 0, 8);
  let avoidCollisions = prop($$props, "avoidCollisions", 0, true);
  let collisionBoundary = prop($$props, "collisionBoundary", 8, () => void 0);
  let fitViewport = prop($$props, "fitViewport", 0, false);
  let strategy = prop($$props, "strategy", 0, "absolute");
  let overlap = prop($$props, "overlap", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { menu },
    states: { open },
    ids,
    getAttrs: getAttrs2
  } = getCtx8();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("content");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.menu.set(id());
    }
  });
  legacy_pre_effect(() => $menu(), () => {
    set(builder, $menu());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(
    () => (deep_read_state(alignOffset()), deep_read_state(collisionPadding()), deep_read_state(avoidCollisions()), deep_read_state(collisionBoundary()), deep_read_state(fitViewport()), deep_read_state(strategy()), deep_read_state(overlap())),
    () => {
      updatePositioning3({
        alignOffset: alignOffset(),
        collisionPadding: collisionPadding(),
        avoidCollisions: avoidCollisions(),
        collisionBoundary: collisionBoundary(),
        fitViewport: fitViewport(),
        strategy: strategy(),
        overlap: overlap()
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => asChild() && $open(),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      if_block(
        node_2,
        () => transition2() && $open(),
        ($$anchor3) => {
          var div = root_310();
          bind_this(div, ($$value) => el($$value), () => el());
          transition(3, div, transition2, transitionConfig);
          let attributes;
          var node_3 = child(div);
          slot(
            node_3,
            default_slot($$props),
            {
              get builder() {
                return get2(builder);
              }
            },
            null
          );
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
          action(div, ($$node) => get2(builder).action($$node));
          event("m-keydown", div, dispatch, false);
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          if_block(
            node_4,
            () => inTransition() && outTransition() && $open(),
            ($$anchor4) => {
              var div_1 = root_56();
              bind_this(div_1, ($$value) => el($$value), () => el());
              transition(1, div_1, inTransition, inTransitionConfig);
              transition(2, div_1, outTransition, outTransitionConfig);
              let attributes_1;
              var node_5 = child(div_1);
              slot(
                node_5,
                default_slot($$props),
                {
                  get builder() {
                    return get2(builder);
                  }
                },
                null
              );
              reset(div_1);
              template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get2(builder), ...$$restProps }, true, ""));
              action(div_1, ($$node) => get2(builder).action($$node));
              event("m-keydown", div_1, dispatch, false);
              append($$anchor4, div_1);
            },
            ($$anchor4) => {
              var fragment_4 = comment();
              var node_6 = first_child(fragment_4);
              if_block(
                node_6,
                () => inTransition() && $open(),
                ($$anchor5) => {
                  var div_2 = root_76();
                  bind_this(div_2, ($$value) => el($$value), () => el());
                  transition(1, div_2, inTransition, inTransitionConfig);
                  let attributes_2;
                  var node_7 = child(div_2);
                  slot(
                    node_7,
                    default_slot($$props),
                    {
                      get builder() {
                        return get2(builder);
                      }
                    },
                    null
                  );
                  reset(div_2);
                  template_effect(() => attributes_2 = set_attributes(div_2, attributes_2, { ...get2(builder), ...$$restProps }, true, ""));
                  action(div_2, ($$node) => get2(builder).action($$node));
                  event("m-keydown", div_2, dispatch, false);
                  append($$anchor5, div_2);
                },
                ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_8 = first_child(fragment_5);
                  if_block(
                    node_8,
                    () => outTransition() && $open(),
                    ($$anchor6) => {
                      var div_3 = root_96();
                      bind_this(div_3, ($$value) => el($$value), () => el());
                      transition(2, div_3, outTransition, outTransitionConfig);
                      let attributes_3;
                      var node_9 = child(div_3);
                      slot(
                        node_9,
                        default_slot($$props),
                        {
                          get builder() {
                            return get2(builder);
                          }
                        },
                        null
                      );
                      reset(div_3);
                      template_effect(() => attributes_3 = set_attributes(div_3, attributes_3, { ...get2(builder), ...$$restProps }, true, ""));
                      action(div_3, ($$node) => get2(builder).action($$node));
                      event("m-keydown", div_3, dispatch, false);
                      append($$anchor6, div_3);
                    },
                    ($$anchor6) => {
                      var fragment_6 = comment();
                      var node_10 = first_child(fragment_6);
                      if_block(
                        node_10,
                        $open,
                        ($$anchor7) => {
                          var div_4 = root_116();
                          bind_this(div_4, ($$value) => el($$value), () => el());
                          let attributes_4;
                          var node_11 = child(div_4);
                          slot(
                            node_11,
                            default_slot($$props),
                            {
                              get builder() {
                                return get2(builder);
                              }
                            },
                            null
                          );
                          reset(div_4);
                          template_effect(() => attributes_4 = set_attributes(div_4, attributes_4, { ...get2(builder), ...$$restProps }, true, ""));
                          action(div_4, ($$node) => get2(builder).action($$node));
                          event("m-keydown", div_4, dispatch, false);
                          append($$anchor7, div_4);
                        },
                        null,
                        true
                      );
                      append($$anchor6, fragment_6);
                    },
                    true
                  );
                  append($$anchor5, fragment_5);
                },
                true
              );
              append($$anchor4, fragment_4);
            },
            true
          );
          append($$anchor3, fragment_3);
        },
        true
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Context_menu_content);
  const filename = Context_menu_content.filename;
  const $$original = Context_menu_content;
  Context_menu_content = hmr(s);
  Context_menu_content.filename = filename;
  Context_menu_content[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var context_menu_content_default = Context_menu_content;
mark_module_end(Context_menu_content);

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu-trigger.svelte
mark_module_start();
Context_menu_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/context-menu/components/context-menu-trigger.svelte";
var root_237 = add_locations(template(`<div><!></div>`), Context_menu_trigger[FILENAME], [[27, 1]]);
function Context_menu_trigger($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Context_menu_trigger);
  const $$stores = setup_stores();
  const $trigger = () => (validate_store(trigger, "trigger"), store_get(trigger, "$trigger", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { trigger }, ids, getAttrs: getAttrs2 } = getCtx8();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("trigger");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.trigger.set(id());
    }
  });
  legacy_pre_effect(() => $trigger(), () => {
    set(builder, $trigger());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_237();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      event("m-contextmenu", div, dispatch, false);
      event("m-pointercancel", div, dispatch, false);
      event("m-pointerdown", div, dispatch, false);
      event("m-pointermove", div, dispatch, false);
      event("m-pointerup", div, dispatch, false);
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Context_menu_trigger);
  const filename = Context_menu_trigger.filename;
  const $$original = Context_menu_trigger;
  Context_menu_trigger = hmr(s);
  Context_menu_trigger.filename = filename;
  Context_menu_trigger[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var context_menu_trigger_default = Context_menu_trigger;
mark_module_end(Context_menu_trigger);

// node_modules/bits-ui/dist/bits/menu/components/menu-radio-item.svelte
mark_module_start();
Menu_radio_item[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-radio-item.svelte";
var root_238 = add_locations(template(`<div><!></div>`), Menu_radio_item[FILENAME], [[23, 1]]);
function Menu_radio_item($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["value", "disabled", "asChild", "el"]);
  push($$props, false, Menu_radio_item);
  const $$stores = setup_stores();
  const $radioItem = () => (validate_store(radioItem, "radioItem"), store_get(radioItem, "$radioItem", $$stores));
  const builder = mutable_source();
  let value = prop($$props, "value");
  let disabled = prop($$props, "disabled", 0, false);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { radioItem }, getAttrs: getAttrs2 } = setRadioItem(value());
  const attrs = getAttrs2("radio-item");
  const dispatch = createDispatcher();
  legacy_pre_effect(
    () => ($radioItem(), deep_read_state(value()), deep_read_state(disabled())),
    () => {
      set(builder, $radioItem()({ value: value(), disabled: disabled() }));
    }
  );
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_238();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      event("m-click", div, dispatch, false);
      event("m-focusin", div, dispatch, false);
      event("m-focusout", div, dispatch, false);
      event("m-keydown", div, dispatch, false);
      event("m-pointerdown", div, dispatch, false);
      event("m-pointerleave", div, dispatch, false);
      event("m-pointermove", div, dispatch, false);
      event("pointerenter", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menu_radio_item);
  const filename = Menu_radio_item.filename;
  const $$original = Menu_radio_item;
  Menu_radio_item = hmr(s);
  Menu_radio_item.filename = filename;
  Menu_radio_item[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menu_radio_item_default = Menu_radio_item;
mark_module_end(Menu_radio_item);

// node_modules/bits-ui/dist/bits/menu/components/menu-separator.svelte
mark_module_start();
Menu_separator[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-separator.svelte";
var root_239 = add_locations(template(`<div></div>`), Menu_separator[FILENAME], [[19, 1]]);
function Menu_separator($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Menu_separator);
  const $$stores = setup_stores();
  const $separator = () => (validate_store(separator, "separator"), store_get(separator, "$separator", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { separator }, getAttrs: getAttrs2 } = getCtx9();
  const attrs = getAttrs2("separator");
  legacy_pre_effect(() => $separator(), () => {
    set(builder, $separator());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_239();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      template_effect(() => attributes = set_attributes(div, attributes, { ...$separator(), ...$$restProps }, true, ""));
      action(div, ($$node) => $separator().action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menu_separator);
  const filename = Menu_separator.filename;
  const $$original = Menu_separator;
  Menu_separator = hmr(s);
  Menu_separator.filename = filename;
  Menu_separator[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menu_separator_default = Menu_separator;
mark_module_end(Menu_separator);

// node_modules/bits-ui/dist/bits/menu/components/menu-radio-group.svelte
mark_module_start();
Menu_radio_group[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-radio-group.svelte";
var root_240 = add_locations(template(`<div><!></div>`), Menu_radio_group[FILENAME], [[33, 1]]);
function Menu_radio_group($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["value", "onValueChange", "asChild", "el"]);
  push($$props, false, Menu_radio_group);
  const $$stores = setup_stores();
  const $radioGroup = () => (validate_store(radioGroup, "radioGroup"), store_get(radioGroup, "$radioGroup", $$stores));
  const builder = mutable_source();
  let value = prop($$props, "value", 12, () => void 0);
  let onValueChange = prop($$props, "onValueChange", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { radioGroup },
    states: { value: localValue },
    getAttrs: getAttrs2
  } = setRadioGroupCtx({
    defaultValue: value(),
    onValueChange: ({ next: next2 }) => {
      var _a;
      if (next2 != null && next2 !== value()) {
        (_a = onValueChange()) == null ? void 0 : _a(next2);
        value(next2);
      }
      return next2;
    }
  });
  const attrs = getAttrs2("radio-group");
  legacy_pre_effect(() => deep_read_state(value()), () => {
    value() !== void 0 && localValue.set(value());
  });
  legacy_pre_effect(() => $radioGroup(), () => {
    set(builder, $radioGroup());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_240();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menu_radio_group);
  const filename = Menu_radio_group.filename;
  const $$original = Menu_radio_group;
  Menu_radio_group = hmr(s);
  Menu_radio_group.filename = filename;
  Menu_radio_group[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menu_radio_group_default = Menu_radio_group;
mark_module_end(Menu_radio_group);

// node_modules/bits-ui/dist/bits/menu/components/menu-sub-content.svelte
mark_module_start();
Menu_sub_content[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-sub-content.svelte";
var root_311 = add_locations(template(`<div><!></div>`), Menu_sub_content[FILENAME], [[59, 1]]);
var root_57 = add_locations(template(`<div><!></div>`), Menu_sub_content[FILENAME], [[71, 1]]);
var root_77 = add_locations(template(`<div><!></div>`), Menu_sub_content[FILENAME], [[84, 1]]);
var root_97 = add_locations(template(`<div><!></div>`), Menu_sub_content[FILENAME], [[96, 1]]);
var root_117 = add_locations(template(`<div><!></div>`), Menu_sub_content[FILENAME], [[108, 1]]);
function Menu_sub_content($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "side",
    "align",
    "sideOffset",
    "alignOffset",
    "collisionPadding",
    "avoidCollisions",
    "collisionBoundary",
    "sameWidth",
    "fitViewport",
    "strategy",
    "overlap",
    "el"
  ]);
  push($$props, false, Menu_sub_content);
  const $$stores = setup_stores();
  const $subMenu = () => (validate_store(subMenu, "subMenu"), store_get(subMenu, "$subMenu", $$stores));
  const $subOpen = () => (validate_store(subOpen, "subOpen"), store_get(subOpen, "$subOpen", $$stores));
  const builder = mutable_source();
  let transition2 = prop($$props, "transition", 8, () => void 0);
  let transitionConfig = prop($$props, "transitionConfig", 8, () => void 0);
  let inTransition = prop($$props, "inTransition", 8, () => void 0);
  let inTransitionConfig = prop($$props, "inTransitionConfig", 8, () => void 0);
  let outTransition = prop($$props, "outTransition", 8, () => void 0);
  let outTransitionConfig = prop($$props, "outTransitionConfig", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let side = prop($$props, "side", 0, "right");
  let align = prop($$props, "align", 0, "start");
  let sideOffset = prop($$props, "sideOffset", 0, 0);
  let alignOffset = prop($$props, "alignOffset", 0, 0);
  let collisionPadding = prop($$props, "collisionPadding", 0, 8);
  let avoidCollisions = prop($$props, "avoidCollisions", 0, true);
  let collisionBoundary = prop($$props, "collisionBoundary", 8, () => void 0);
  let sameWidth = prop($$props, "sameWidth", 0, false);
  let fitViewport = prop($$props, "fitViewport", 0, false);
  let strategy = prop($$props, "strategy", 0, "absolute");
  let overlap = prop($$props, "overlap", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { subMenu },
    states: { subOpen },
    ids,
    getAttrs: getAttrs2
  } = getSubmenuCtx();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("sub-content");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.menu.set(id());
    }
  });
  legacy_pre_effect(() => $subMenu(), () => {
    set(builder, $subMenu());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(
    () => (deep_read_state(side()), deep_read_state(align()), deep_read_state(sideOffset()), deep_read_state(alignOffset()), deep_read_state(collisionPadding()), deep_read_state(avoidCollisions()), deep_read_state(collisionBoundary()), deep_read_state(sameWidth()), deep_read_state(fitViewport()), deep_read_state(strategy()), deep_read_state(overlap())),
    () => {
      updateSubPositioning({
        side: side(),
        align: align(),
        sideOffset: sideOffset(),
        alignOffset: alignOffset(),
        collisionPadding: collisionPadding(),
        avoidCollisions: avoidCollisions(),
        collisionBoundary: collisionBoundary(),
        sameWidth: sameWidth(),
        fitViewport: fitViewport(),
        strategy: strategy(),
        overlap: overlap()
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => asChild() && $subOpen(),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      if_block(
        node_2,
        () => transition2() && $subOpen(),
        ($$anchor3) => {
          var div = root_311();
          bind_this(div, ($$value) => el($$value), () => el());
          transition(3, div, transition2, transitionConfig);
          let attributes;
          var node_3 = child(div);
          slot(
            node_3,
            default_slot($$props),
            {
              get builder() {
                return get2(builder);
              }
            },
            null
          );
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
          action(div, ($$node) => get2(builder).action($$node));
          event("m-focusout", div, dispatch, false);
          event("m-keydown", div, dispatch, false);
          event("m-pointermove", div, dispatch, false);
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          if_block(
            node_4,
            () => inTransition() && outTransition() && $subOpen(),
            ($$anchor4) => {
              var div_1 = root_57();
              bind_this(div_1, ($$value) => el($$value), () => el());
              transition(1, div_1, inTransition, inTransitionConfig);
              transition(2, div_1, outTransition, outTransitionConfig);
              let attributes_1;
              var node_5 = child(div_1);
              slot(
                node_5,
                default_slot($$props),
                {
                  get builder() {
                    return get2(builder);
                  }
                },
                null
              );
              reset(div_1);
              template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get2(builder), ...$$restProps }, true, ""));
              action(div_1, ($$node) => get2(builder).action($$node));
              event("m-focusout", div_1, dispatch, false);
              event("m-keydown", div_1, dispatch, false);
              event("m-pointermove", div_1, dispatch, false);
              append($$anchor4, div_1);
            },
            ($$anchor4) => {
              var fragment_4 = comment();
              var node_6 = first_child(fragment_4);
              if_block(
                node_6,
                () => inTransition() && $subOpen(),
                ($$anchor5) => {
                  var div_2 = root_77();
                  bind_this(div_2, ($$value) => el($$value), () => el());
                  transition(1, div_2, inTransition, inTransitionConfig);
                  let attributes_2;
                  var node_7 = child(div_2);
                  slot(
                    node_7,
                    default_slot($$props),
                    {
                      get builder() {
                        return get2(builder);
                      }
                    },
                    null
                  );
                  reset(div_2);
                  template_effect(() => attributes_2 = set_attributes(div_2, attributes_2, { ...get2(builder), ...$$restProps }, true, ""));
                  action(div_2, ($$node) => get2(builder).action($$node));
                  event("m-focusout", div_2, dispatch, false);
                  event("m-keydown", div_2, dispatch, false);
                  event("m-pointermove", div_2, dispatch, false);
                  append($$anchor5, div_2);
                },
                ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_8 = first_child(fragment_5);
                  if_block(
                    node_8,
                    () => outTransition() && $subOpen(),
                    ($$anchor6) => {
                      var div_3 = root_97();
                      bind_this(div_3, ($$value) => el($$value), () => el());
                      transition(2, div_3, outTransition, outTransitionConfig);
                      let attributes_3;
                      var node_9 = child(div_3);
                      slot(
                        node_9,
                        default_slot($$props),
                        {
                          get builder() {
                            return get2(builder);
                          }
                        },
                        null
                      );
                      reset(div_3);
                      template_effect(() => attributes_3 = set_attributes(div_3, attributes_3, { ...get2(builder), ...$$restProps }, true, ""));
                      action(div_3, ($$node) => get2(builder).action($$node));
                      event("m-focusout", div_3, dispatch, false);
                      event("m-keydown", div_3, dispatch, false);
                      event("m-pointermove", div_3, dispatch, false);
                      append($$anchor6, div_3);
                    },
                    ($$anchor6) => {
                      var fragment_6 = comment();
                      var node_10 = first_child(fragment_6);
                      if_block(
                        node_10,
                        $subOpen,
                        ($$anchor7) => {
                          var div_4 = root_117();
                          bind_this(div_4, ($$value) => el($$value), () => el());
                          let attributes_4;
                          var node_11 = child(div_4);
                          slot(
                            node_11,
                            default_slot($$props),
                            {
                              get builder() {
                                return get2(builder);
                              }
                            },
                            null
                          );
                          reset(div_4);
                          template_effect(() => attributes_4 = set_attributes(div_4, attributes_4, { ...get2(builder), ...$$restProps }, true, ""));
                          action(div_4, ($$node) => get2(builder).action($$node));
                          event("m-focusout", div_4, dispatch, false);
                          event("m-keydown", div_4, dispatch, false);
                          event("m-pointermove", div_4, dispatch, false);
                          append($$anchor7, div_4);
                        },
                        null,
                        true
                      );
                      append($$anchor6, fragment_6);
                    },
                    true
                  );
                  append($$anchor5, fragment_5);
                },
                true
              );
              append($$anchor4, fragment_4);
            },
            true
          );
          append($$anchor3, fragment_3);
        },
        true
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menu_sub_content);
  const filename = Menu_sub_content.filename;
  const $$original = Menu_sub_content;
  Menu_sub_content = hmr(s);
  Menu_sub_content.filename = filename;
  Menu_sub_content[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menu_sub_content_default = Menu_sub_content;
mark_module_end(Menu_sub_content);

// node_modules/bits-ui/dist/bits/menu/components/menu-sub-trigger.svelte
mark_module_start();
Menu_sub_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-sub-trigger.svelte";
var root_241 = add_locations(template(`<div><!></div>`), Menu_sub_trigger[FILENAME], [[35, 1]]);
function Menu_sub_trigger($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["disabled", "asChild", "id", "el"]);
  push($$props, false, Menu_sub_trigger);
  const $$stores = setup_stores();
  const $subTrigger = () => (validate_store(subTrigger, "subTrigger"), store_get(subTrigger, "$subTrigger", $$stores));
  const $disabledStore = () => (validate_store(disabledStore, "disabledStore"), store_get(disabledStore, "$disabledStore", $$stores));
  const builder = mutable_source();
  const attrs = mutable_source();
  let disabled = prop($$props, "disabled", 0, false);
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { subTrigger },
    ids,
    getAttrs: getAttrs2,
    options
  } = getSubTrigger();
  const { disabled: disabledStore } = options;
  const dispatch = createDispatcher();
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.trigger.set(id());
    }
  });
  legacy_pre_effect(() => $subTrigger(), () => {
    set(builder, $subTrigger());
  });
  legacy_pre_effect(
    () => (deep_read_state(disabled()), $disabledStore()),
    () => {
      set(attrs, {
        ...getAttrs2("sub-trigger"),
        ...disabledAttrs(disabled() || $disabledStore())
      });
    }
  );
  legacy_pre_effect(() => (get2(builder), get2(attrs)), () => {
    Object.assign(get2(builder), get2(attrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_241();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      event("m-click", div, dispatch, false);
      event("m-focusin", div, dispatch, false);
      event("m-focusout", div, dispatch, false);
      event("m-keydown", div, dispatch, false);
      event("m-pointerleave", div, dispatch, false);
      event("m-pointermove", div, dispatch, false);
      event("pointerenter", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menu_sub_trigger);
  const filename = Menu_sub_trigger.filename;
  const $$original = Menu_sub_trigger;
  Menu_sub_trigger = hmr(s);
  Menu_sub_trigger.filename = filename;
  Menu_sub_trigger[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menu_sub_trigger_default = Menu_sub_trigger;
mark_module_end(Menu_sub_trigger);

// node_modules/bits-ui/dist/bits/menu/components/menu-checkbox-item.svelte
mark_module_start();
Menu_checkbox_item[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-checkbox-item.svelte";
var root_242 = add_locations(template(`<div><!></div>`), Menu_checkbox_item[FILENAME], [[40, 1]]);
function Menu_checkbox_item($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "checked",
    "onCheckedChange",
    "disabled",
    "asChild",
    "el"
  ]);
  push($$props, false, Menu_checkbox_item);
  const $$stores = setup_stores();
  const $checkboxItem = () => (validate_store(checkboxItem, "checkboxItem"), store_get(checkboxItem, "$checkboxItem", $$stores));
  const builder = mutable_source();
  let checked = prop($$props, "checked", 12, () => void 0);
  let onCheckedChange = prop($$props, "onCheckedChange", 8, () => void 0);
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { checkboxItem },
    states: { checked: localChecked },
    updateOption,
    getAttrs: getAttrs2
  } = setCheckboxItem({
    disabled: disabled(),
    defaultChecked: checked(),
    onCheckedChange: ({ next: next2 }) => {
      var _a;
      if (checked() !== next2) {
        (_a = onCheckedChange()) == null ? void 0 : _a(next2);
        checked(next2);
      }
      return next2;
    }
  });
  const dispatch = createDispatcher();
  const attrs = getAttrs2("checkbox-item");
  legacy_pre_effect(() => deep_read_state(checked()), () => {
    checked() !== void 0 && localChecked.set(checked());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => $checkboxItem(), () => {
    set(builder, $checkboxItem());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_242();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      event("m-click", div, dispatch, false);
      event("m-focusin", div, dispatch, false);
      event("m-focusout", div, dispatch, false);
      event("m-keydown", div, dispatch, false);
      event("m-pointerdown", div, dispatch, false);
      event("m-pointerleave", div, dispatch, false);
      event("m-pointermove", div, dispatch, false);
      event("pointerenter", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menu_checkbox_item);
  const filename = Menu_checkbox_item.filename;
  const $$original = Menu_checkbox_item;
  Menu_checkbox_item = hmr(s);
  Menu_checkbox_item.filename = filename;
  Menu_checkbox_item[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menu_checkbox_item_default = Menu_checkbox_item;
mark_module_end(Menu_checkbox_item);

// node_modules/bits-ui/dist/bits/menu/components/menu-radio-indicator.svelte
mark_module_start();
Menu_radio_indicator[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-radio-indicator.svelte";
var root_243 = add_locations(template(`<div><!></div>`), Menu_radio_indicator[FILENAME], [[17, 1]]);
function Menu_radio_indicator($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Menu_radio_indicator);
  const $$stores = setup_stores();
  const $isChecked = () => (validate_store(isChecked, "isChecked"), store_get(isChecked, "$isChecked", $$stores));
  const checked = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { helpers: { isChecked }, value, getAttrs: getAttrs2 } = getRadioIndicator();
  const attrs = getAttrs2("radio-indicator");
  legacy_pre_effect(() => $isChecked(), () => {
    set(checked, $isChecked()(value));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          attrs,
          get checked() {
            return get2(checked);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_243();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      if_block(node_2, () => get2(checked), ($$anchor3) => {
        var fragment_2 = comment();
        var node_3 = first_child(fragment_2);
        slot(
          node_3,
          default_slot($$props),
          {
            attrs,
            get checked() {
              return get2(checked);
            }
          },
          null
        );
        append($$anchor3, fragment_2);
      });
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menu_radio_indicator);
  const filename = Menu_radio_indicator.filename;
  const $$original = Menu_radio_indicator;
  Menu_radio_indicator = hmr(s);
  Menu_radio_indicator.filename = filename;
  Menu_radio_indicator[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menu_radio_indicator_default = Menu_radio_indicator;
mark_module_end(Menu_radio_indicator);

// node_modules/bits-ui/dist/bits/menu/components/menu-checkbox-indicator.svelte
mark_module_start();
Menu_checkbox_indicator[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-checkbox-indicator.svelte";
var root_244 = add_locations(template(`<div><!></div>`), Menu_checkbox_indicator[FILENAME], [[12, 1]]);
function Menu_checkbox_indicator($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Menu_checkbox_indicator);
  const $$stores = setup_stores();
  const $checked = () => (validate_store(checked, "checked"), store_get(checked, "$checked", $$stores));
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const checked = getCheckboxIndicator();
  const { getAttrs: getAttrs2 } = getCtx9();
  const attrs = getAttrs2("checkbox-indicator");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          attrs,
          get checked() {
            return $checked();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_244();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      if_block(node_2, $checked, ($$anchor3) => {
        var fragment_2 = comment();
        var node_3 = first_child(fragment_2);
        slot(
          node_3,
          default_slot($$props),
          {
            attrs,
            get checked() {
              return $checked();
            }
          },
          null
        );
        append($$anchor3, fragment_2);
      });
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menu_checkbox_indicator);
  const filename = Menu_checkbox_indicator.filename;
  const $$original = Menu_checkbox_indicator;
  Menu_checkbox_indicator = hmr(s);
  Menu_checkbox_indicator.filename = filename;
  Menu_checkbox_indicator[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menu_checkbox_indicator_default = Menu_checkbox_indicator;
mark_module_end(Menu_checkbox_indicator);

// node_modules/bits-ui/dist/bits/date-field/index.js
var date_field_exports = {};
__export(date_field_exports, {
  Input: () => date_field_input_default,
  Label: () => date_field_label_default,
  Root: () => date_field_default,
  Segment: () => date_field_segment_default
});

// node_modules/bits-ui/dist/bits/date-field/ctx.js
function getDateFieldData() {
  const NAME = "date-field";
  const PARTS = ["label", "input", "segment"];
  return {
    NAME,
    PARTS
  };
}
function setCtx11(props) {
  const { NAME, PARTS } = getDateFieldData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const dateField = { ...createDateField(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(NAME, dateField);
  return {
    ...dateField,
    updateOption: getOptionUpdater(dateField.options)
  };
}
function getCtx10() {
  const { NAME } = getDateFieldData();
  return getContext(NAME);
}

// node_modules/bits-ui/dist/bits/date-field/components/date-field.svelte
mark_module_start();
Date_field[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field.svelte";
function Date_field($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Date_field);
  const $$stores = setup_stores();
  const $localIsInvalid = () => (validate_store(localIsInvalid, "localIsInvalid"), store_get(localIsInvalid, "$localIsInvalid", $$stores));
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  let value = prop($$props, "value", 12, () => void 0);
  let onValueChange = prop($$props, "onValueChange", 8, () => void 0);
  let placeholder = prop($$props, "placeholder", 12, () => void 0);
  let onPlaceholderChange = prop($$props, "onPlaceholderChange", 8, () => void 0);
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let isDateUnavailable = prop($$props, "isDateUnavailable", 8, () => void 0);
  let granularity = prop($$props, "granularity", 8, () => void 0);
  let hideTimeZone = prop($$props, "hideTimeZone", 8, () => void 0);
  let hourCycle = prop($$props, "hourCycle", 8, () => void 0);
  let locale = prop($$props, "locale", 8, () => void 0);
  let maxValue = prop($$props, "maxValue", 8, () => void 0);
  let minValue = prop($$props, "minValue", 8, () => void 0);
  let readonly2 = prop($$props, "readonly", 8, () => void 0);
  let validationId = prop($$props, "validationId", 8, () => void 0);
  let descriptionId = prop($$props, "descriptionId", 8, () => void 0);
  let readonlySegments = prop($$props, "readonlySegments", 8, () => void 0);
  const {
    states: {
      value: localValue,
      placeholder: localPlaceholder,
      isInvalid: localIsInvalid
    },
    updateOption,
    ids
  } = setCtx11({
    defaultValue: value(),
    defaultPlaceholder: placeholder(),
    disabled: disabled(),
    granularity: granularity(),
    hideTimeZone: hideTimeZone(),
    hourCycle: hourCycle(),
    locale: locale(),
    maxValue: maxValue(),
    minValue: minValue(),
    readonly: readonly2(),
    readonlySegments: readonlySegments(),
    isDateUnavailable: isDateUnavailable(),
    onValueChange: ({ next: next2 }) => {
      var _a;
      if (value() !== next2) {
        (_a = onValueChange()) == null ? void 0 : _a(next2);
        value(next2);
      }
      return next2;
    },
    onPlaceholderChange: ({ next: next2 }) => {
      var _a;
      if (placeholder() !== next2) {
        (_a = onPlaceholderChange()) == null ? void 0 : _a(next2);
        placeholder(next2);
      }
      return next2;
    }
  });
  const idValues = derived(
    [
      ids.day,
      ids.description,
      ids.dayPeriod,
      ids.field,
      ids.hour,
      ids.minute,
      ids.month,
      ids.second,
      ids.year,
      ids.validation,
      ids.label,
      ids.timeZoneName
    ],
    ([
      $dayId,
      $descriptionId,
      $dayPeriodId,
      $fieldId,
      $hourId,
      $minuteId,
      $monthId,
      $secondId,
      $yearId,
      $validationId,
      $labelId,
      $timeZoneNameId
    ]) => ({
      day: $dayId,
      description: $descriptionId,
      dayPeriod: $dayPeriodId,
      field: $fieldId,
      hour: $hourId,
      minute: $minuteId,
      month: $monthId,
      second: $secondId,
      year: $yearId,
      validation: $validationId,
      label: $labelId,
      timeZoneName: $timeZoneNameId
    })
  );
  legacy_pre_effect(() => deep_read_state(validationId()), () => {
    if (validationId()) {
      ids.validation.set(validationId());
    }
  });
  legacy_pre_effect(() => deep_read_state(descriptionId()), () => {
    if (descriptionId()) {
      ids.description.set(descriptionId());
    }
  });
  legacy_pre_effect(() => deep_read_state(value()), () => {
    value() !== void 0 && localValue.set(value());
  });
  legacy_pre_effect(() => deep_read_state(placeholder()), () => {
    placeholder() !== void 0 && localPlaceholder.set(placeholder());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => deep_read_state(isDateUnavailable()), () => {
    updateOption("isDateUnavailable", isDateUnavailable());
  });
  legacy_pre_effect(() => deep_read_state(granularity()), () => {
    updateOption("granularity", granularity());
  });
  legacy_pre_effect(() => deep_read_state(hideTimeZone()), () => {
    updateOption("hideTimeZone", hideTimeZone());
  });
  legacy_pre_effect(() => deep_read_state(hourCycle()), () => {
    updateOption("hourCycle", hourCycle());
  });
  legacy_pre_effect(() => deep_read_state(locale()), () => {
    updateOption("locale", locale());
  });
  legacy_pre_effect(() => deep_read_state(maxValue()), () => {
    updateOption("maxValue", maxValue());
  });
  legacy_pre_effect(() => deep_read_state(minValue()), () => {
    updateOption("minValue", minValue());
  });
  legacy_pre_effect(() => deep_read_state(readonly2()), () => {
    updateOption("readonly", readonly2());
  });
  legacy_pre_effect(() => deep_read_state(readonlySegments()), () => {
    updateOption("readonlySegments", readonlySegments());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get isInvalid() {
        return $localIsInvalid();
      },
      get ids() {
        return $idValues();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_field);
  const filename = Date_field.filename;
  const $$original = Date_field;
  Date_field = hmr(s);
  Date_field.filename = filename;
  Date_field[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_field_default = Date_field;
mark_module_end(Date_field);

// node_modules/bits-ui/dist/bits/date-field/components/date-field-input.svelte
mark_module_start();
Date_field_input[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field-input.svelte";
var root_245 = add_locations(template(`<div><!></div>`), Date_field_input[FILENAME], [[26, 1]]);
function Date_field_input($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Date_field_input);
  const $$stores = setup_stores();
  const $field = () => (validate_store(field, "field"), store_get(field, "$field", $$stores));
  const $segmentContents = () => (validate_store(segmentContents, "segmentContents"), store_get(segmentContents, "$segmentContents", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { field },
    states: { segmentContents },
    ids,
    getAttrs: getAttrs2
  } = getCtx10();
  const attrs = getAttrs2("input");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.field.set(id());
    }
  });
  legacy_pre_effect(() => $field(), () => {
    set(builder, $field());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get segments() {
            return $segmentContents();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_245();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get segments() {
            return $segmentContents();
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_field_input);
  const filename = Date_field_input.filename;
  const $$original = Date_field_input;
  Date_field_input = hmr(s);
  Date_field_input.filename = filename;
  Date_field_input[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_field_input_default = Date_field_input;
mark_module_end(Date_field_input);

// node_modules/bits-ui/dist/bits/date-field/components/date-field-label.svelte
mark_module_start();
Date_field_label[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field-label.svelte";
var root_246 = add_locations(template(`<span><!></span>`), Date_field_label[FILENAME], [[24, 1]]);
function Date_field_label($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Date_field_label);
  const $$stores = setup_stores();
  const $label = () => (validate_store(label, "label"), store_get(label, "$label", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { label }, ids, getAttrs: getAttrs2 } = getCtx10();
  if (id()) {
    ids.label.set(id());
  }
  const attrs = getAttrs2("label");
  legacy_pre_effect(() => $label(), () => {
    set(builder, $label());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_246();
      bind_this(span, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(span);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(span);
      template_effect(() => attributes = set_attributes(span, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(span, ($$node) => get2(builder).action($$node));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_field_label);
  const filename = Date_field_label.filename;
  const $$original = Date_field_label;
  Date_field_label = hmr(s);
  Date_field_label.filename = filename;
  Date_field_label[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_field_label_default = Date_field_label;
mark_module_end(Date_field_label);

// node_modules/bits-ui/dist/bits/date-field/components/date-field-segment.svelte
mark_module_start();
Date_field_segment[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field-segment.svelte";
var root_247 = add_locations(template(`<div><!></div>`), Date_field_segment[FILENAME], [[28, 1]]);
function Date_field_segment($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "part", "el"]);
  push($$props, false, Date_field_segment);
  const $$stores = setup_stores();
  const $segment = () => (validate_store(segment, "segment"), store_get(segment, "$segment", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let part = prop($$props, "part");
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { segment }, ids, getAttrs: getAttrs2 } = getCtx10();
  const attrs = getAttrs2("segment");
  const dispatch = createDispatcher();
  legacy_pre_effect(
    () => (deep_read_state(id()), deep_read_state(part())),
    () => {
      if (id() && part() !== "literal") {
        ids[part()].set(id());
      }
    }
  );
  legacy_pre_effect(
    () => ($segment(), deep_read_state(part())),
    () => {
      set(builder, $segment()(part()));
    }
  );
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_247();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      event("m-click", div, dispatch, false);
      event("m-focusout", div, dispatch, false);
      event("m-keydown", div, dispatch, false);
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_field_segment);
  const filename = Date_field_segment.filename;
  const $$original = Date_field_segment;
  Date_field_segment = hmr(s);
  Date_field_segment.filename = filename;
  Date_field_segment[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_field_segment_default = Date_field_segment;
mark_module_end(Date_field_segment);

// node_modules/bits-ui/dist/bits/date-picker/index.js
var date_picker_exports = {};
__export(date_picker_exports, {
  Arrow: () => date_picker_arrow_default,
  Calendar: () => date_picker_calendar_default,
  Cell: () => date_picker_cell_default,
  Close: () => date_picker_close_default,
  Content: () => date_picker_content_default,
  Day: () => date_picker_day_default,
  Field: () => date_picker_field_default,
  Grid: () => date_picker_grid_default,
  GridBody: () => date_picker_grid_body_default,
  GridHead: () => date_picker_grid_head_default,
  GridRow: () => date_picker_grid_row_default,
  HeadCell: () => date_picker_head_cell_default,
  Header: () => date_picker_header_default,
  Heading: () => date_picker_heading_default,
  Input: () => date_picker_input_default,
  Label: () => date_picker_label_default,
  NextButton: () => date_picker_next_button_default,
  PrevButton: () => date_picker_prev_button_default,
  Root: () => date_picker_default,
  Segment: () => date_picker_segment_default,
  Trigger: () => date_picker_trigger_default
});

// node_modules/bits-ui/dist/bits/popover/ctx.js
function getPopoverData() {
  const NAME = "popover";
  const PARTS = ["arrow", "close", "content", "trigger"];
  return {
    NAME,
    PARTS
  };
}
function setCtx12(props) {
  const { NAME, PARTS } = getPopoverData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const popover = {
    ...createPopover({
      positioning: {
        placement: "bottom",
        gutter: 0
      },
      ...removeUndefined2(props),
      forceVisible: true
    }),
    getAttrs: getAttrs2
  };
  setContext(NAME, popover);
  return {
    ...popover,
    updateOption: getOptionUpdater(popover.options)
  };
}
function getCtx11() {
  const { NAME } = getPopoverData();
  return getContext(NAME);
}
function setArrow3(size2 = 8) {
  const popover = getCtx11();
  popover.options.arrowSize.set(size2);
  return popover;
}
function updatePositioning5(props) {
  const defaultPlacement = {
    side: "bottom",
    align: "center"
  };
  const withDefaults = { ...defaultPlacement, ...props };
  const { options: { positioning } } = getCtx11();
  const updater = getPositioningUpdater(positioning);
  updater(withDefaults);
}

// node_modules/bits-ui/dist/bits/date-picker/ctx.js
function getDatePickerData() {
  const NAME = "date-picker";
  return {
    NAME
  };
}
function setCtx13(props) {
  const { NAME } = getDatePickerData();
  const { NAME: CALENDAR_NAME, PARTS: CALENDAR_PARTS } = getCalendarData();
  const getCalendarAttrs = createBitAttrs(CALENDAR_NAME, CALENDAR_PARTS);
  const { NAME: FIELD_NAME, PARTS: FIELD_PARTS } = getDateFieldData();
  const getFieldAttrs = createBitAttrs(FIELD_NAME, FIELD_PARTS);
  const { NAME: POPOVER_NAME, PARTS: POPOVER_PARTS } = getPopoverData();
  const getPopoverAttrs = createBitAttrs(POPOVER_NAME, POPOVER_PARTS);
  const datePicker = {
    ...createDatePicker({ ...removeUndefined2(props), forceVisible: true }),
    getCalendarAttrs,
    getFieldAttrs,
    getPopoverAttrs
  };
  const updateOption = getOptionUpdater(datePicker.options);
  setContext(NAME, { ...datePicker, updateOption });
  return {
    ...datePicker,
    updateOption
  };
}
function getCtx12() {
  const { NAME } = getDatePickerData();
  return getContext(NAME);
}
function updatePositioning6(props) {
  const defaultPlacement = {
    side: "bottom",
    align: "center"
  };
  const withDefaults = { ...defaultPlacement, ...props };
  const { options: { positioning } } = getCtx12();
  const updater = getPositioningUpdater(positioning);
  updater(withDefaults);
}

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-arrow.svelte
mark_module_start();
Date_picker_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-arrow.svelte";
var root_248 = add_locations(template(`<div></div>`), Date_picker_arrow[FILENAME], [[23, 1]]);
function Date_picker_arrow($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el", "size"]);
  push($$props, false, Date_picker_arrow);
  const $$stores = setup_stores();
  const $arrow = () => (validate_store(arrow2, "arrow"), store_get(arrow2, "$arrow", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  let size2 = prop($$props, "size", 0, 8);
  const {
    elements: { arrow: arrow2 },
    updateOption,
    getPopoverAttrs
  } = getCtx12();
  const attrs = getPopoverAttrs("arrow");
  legacy_pre_effect(() => deep_read_state(size2()), () => {
    updateOption("arrowSize", size2());
  });
  legacy_pre_effect(() => $arrow(), () => {
    set(builder, $arrow());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_248();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_arrow);
  const filename = Date_picker_arrow.filename;
  const $$original = Date_picker_arrow;
  Date_picker_arrow = hmr(s);
  Date_picker_arrow.filename = filename;
  Date_picker_arrow[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_arrow_default = Date_picker_arrow;
mark_module_end(Date_picker_arrow);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-calendar.svelte
mark_module_start();
Date_picker_calendar[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-calendar.svelte";
var root_249 = add_locations(template(`<div><!></div>`), Date_picker_calendar[FILENAME], [[31, 1]]);
function Date_picker_calendar($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Date_picker_calendar);
  const $$stores = setup_stores();
  const $calendar = () => (validate_store(calendar, "calendar"), store_get(calendar, "$calendar", $$stores));
  const $localMonths = () => (validate_store(localMonths, "localMonths"), store_get(localMonths, "$localMonths", $$stores));
  const $weekdays = () => (validate_store(weekdays, "weekdays"), store_get(weekdays, "$weekdays", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { calendar },
    states: { months: localMonths, weekdays },
    ids,
    getCalendarAttrs
  } = getCtx12();
  const attrs = getCalendarAttrs("root");
  const dispatch = createDispatcher();
  let months = mutable_source($localMonths());
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.calendar.calendar.set(id());
    }
  });
  legacy_pre_effect(() => $calendar(), () => {
    set(builder, $calendar());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(() => $localMonths(), () => {
    set(months, $localMonths());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get months() {
            return get2(months);
          },
          get weekdays() {
            return $weekdays();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_249();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get months() {
            return get2(months);
          },
          get weekdays() {
            return $weekdays();
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      event("m-keydown", div, dispatch, false);
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_calendar);
  const filename = Date_picker_calendar.filename;
  const $$original = Date_picker_calendar;
  Date_picker_calendar = hmr(s);
  Date_picker_calendar.filename = filename;
  Date_picker_calendar[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_calendar_default = Date_picker_calendar;
mark_module_end(Date_picker_calendar);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-close.svelte
mark_module_start();
Date_picker_close[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-close.svelte";
var root_250 = add_locations(template(`<button><!></button>`), Date_picker_close[FILENAME], [[21, 1]]);
function Date_picker_close($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_picker_close);
  const $$stores = setup_stores();
  const $close = () => (validate_store(close, "close"), store_get(close, "$close", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { close }, getPopoverAttrs } = getCtx12();
  const dispatch = createDispatcher();
  const attrs = getPopoverAttrs("close");
  legacy_pre_effect(() => $close(), () => {
    set(builder, $close());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_250();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_close);
  const filename = Date_picker_close.filename;
  const $$original = Date_picker_close;
  Date_picker_close = hmr(s);
  Date_picker_close.filename = filename;
  Date_picker_close[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_close_default = Date_picker_close;
mark_module_end(Date_picker_close);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-content.svelte
mark_module_start();
Date_picker_content[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-content.svelte";
var root_312 = add_locations(template(`<div><!></div>`), Date_picker_content[FILENAME], [[57, 1]]);
var root_58 = add_locations(template(`<div><!></div>`), Date_picker_content[FILENAME], [[66, 1]]);
var root_78 = add_locations(template(`<div><!></div>`), Date_picker_content[FILENAME], [[76, 1]]);
var root_98 = add_locations(template(`<div><!></div>`), Date_picker_content[FILENAME], [[80, 1]]);
var root_118 = add_locations(template(`<div><!></div>`), Date_picker_content[FILENAME], [[84, 1]]);
function Date_picker_content($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "side",
    "align",
    "sideOffset",
    "alignOffset",
    "collisionPadding",
    "avoidCollisions",
    "collisionBoundary",
    "sameWidth",
    "fitViewport",
    "strategy",
    "overlap",
    "el"
  ]);
  push($$props, false, Date_picker_content);
  const $$stores = setup_stores();
  const $content = () => (validate_store(content, "content"), store_get(content, "$content", $$stores));
  const $open = () => (validate_store(open, "open"), store_get(open, "$open", $$stores));
  const builder = mutable_source();
  let transition2 = prop($$props, "transition", 8, () => void 0);
  let transitionConfig = prop($$props, "transitionConfig", 8, () => void 0);
  let inTransition = prop($$props, "inTransition", 8, () => void 0);
  let inTransitionConfig = prop($$props, "inTransitionConfig", 8, () => void 0);
  let outTransition = prop($$props, "outTransition", 8, () => void 0);
  let outTransitionConfig = prop($$props, "outTransitionConfig", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let side = prop($$props, "side", 0, "bottom");
  let align = prop($$props, "align", 0, "center");
  let sideOffset = prop($$props, "sideOffset", 0, 0);
  let alignOffset = prop($$props, "alignOffset", 0, 0);
  let collisionPadding = prop($$props, "collisionPadding", 0, 8);
  let avoidCollisions = prop($$props, "avoidCollisions", 0, true);
  let collisionBoundary = prop($$props, "collisionBoundary", 8, () => void 0);
  let sameWidth = prop($$props, "sameWidth", 0, false);
  let fitViewport = prop($$props, "fitViewport", 0, false);
  let strategy = prop($$props, "strategy", 0, "absolute");
  let overlap = prop($$props, "overlap", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { content },
    states: { open },
    ids,
    getPopoverAttrs
  } = getCtx12();
  const attrs = getPopoverAttrs("content");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.popover.content.set(id());
    }
  });
  legacy_pre_effect(() => $content(), () => {
    set(builder, $content());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(
    () => (deep_read_state(side()), deep_read_state(align()), deep_read_state(sideOffset()), deep_read_state(alignOffset()), deep_read_state(collisionPadding()), deep_read_state(avoidCollisions()), deep_read_state(collisionBoundary()), deep_read_state(sameWidth()), deep_read_state(fitViewport()), deep_read_state(strategy()), deep_read_state(overlap())),
    () => {
      updatePositioning6({
        side: side(),
        align: align(),
        sideOffset: sideOffset(),
        alignOffset: alignOffset(),
        collisionPadding: collisionPadding(),
        avoidCollisions: avoidCollisions(),
        collisionBoundary: collisionBoundary(),
        sameWidth: sameWidth(),
        fitViewport: fitViewport(),
        strategy: strategy(),
        overlap: overlap()
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => asChild() && $open(),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      if_block(
        node_2,
        () => transition2() && $open(),
        ($$anchor3) => {
          var div = root_312();
          bind_this(div, ($$value) => el($$value), () => el());
          transition(3, div, transition2, transitionConfig);
          let attributes;
          var node_3 = child(div);
          slot(
            node_3,
            default_slot($$props),
            {
              get builder() {
                return get2(builder);
              }
            },
            null
          );
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
          action(div, ($$node) => get2(builder).action($$node));
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          if_block(
            node_4,
            () => inTransition() && outTransition() && $open(),
            ($$anchor4) => {
              var div_1 = root_58();
              bind_this(div_1, ($$value) => el($$value), () => el());
              transition(1, div_1, inTransition, inTransitionConfig);
              transition(2, div_1, outTransition, outTransitionConfig);
              let attributes_1;
              var node_5 = child(div_1);
              slot(
                node_5,
                default_slot($$props),
                {
                  get builder() {
                    return get2(builder);
                  }
                },
                null
              );
              reset(div_1);
              template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get2(builder), ...$$restProps }, true, ""));
              action(div_1, ($$node) => get2(builder).action($$node));
              append($$anchor4, div_1);
            },
            ($$anchor4) => {
              var fragment_4 = comment();
              var node_6 = first_child(fragment_4);
              if_block(
                node_6,
                () => inTransition() && $open(),
                ($$anchor5) => {
                  var div_2 = root_78();
                  bind_this(div_2, ($$value) => el($$value), () => el());
                  transition(1, div_2, inTransition, inTransitionConfig);
                  let attributes_2;
                  var node_7 = child(div_2);
                  slot(
                    node_7,
                    default_slot($$props),
                    {
                      get builder() {
                        return get2(builder);
                      }
                    },
                    null
                  );
                  reset(div_2);
                  template_effect(() => attributes_2 = set_attributes(div_2, attributes_2, { ...get2(builder), ...$$restProps }, true, ""));
                  action(div_2, ($$node) => get2(builder).action($$node));
                  append($$anchor5, div_2);
                },
                ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_8 = first_child(fragment_5);
                  if_block(
                    node_8,
                    () => outTransition() && $open(),
                    ($$anchor6) => {
                      var div_3 = root_98();
                      bind_this(div_3, ($$value) => el($$value), () => el());
                      transition(2, div_3, outTransition, outTransitionConfig);
                      let attributes_3;
                      var node_9 = child(div_3);
                      slot(
                        node_9,
                        default_slot($$props),
                        {
                          get builder() {
                            return get2(builder);
                          }
                        },
                        null
                      );
                      reset(div_3);
                      template_effect(() => attributes_3 = set_attributes(div_3, attributes_3, { ...get2(builder), ...$$restProps }, true, ""));
                      action(div_3, ($$node) => get2(builder).action($$node));
                      append($$anchor6, div_3);
                    },
                    ($$anchor6) => {
                      var fragment_6 = comment();
                      var node_10 = first_child(fragment_6);
                      if_block(
                        node_10,
                        $open,
                        ($$anchor7) => {
                          var div_4 = root_118();
                          bind_this(div_4, ($$value) => el($$value), () => el());
                          let attributes_4;
                          var node_11 = child(div_4);
                          slot(
                            node_11,
                            default_slot($$props),
                            {
                              get builder() {
                                return get2(builder);
                              }
                            },
                            null
                          );
                          reset(div_4);
                          template_effect(() => attributes_4 = set_attributes(div_4, attributes_4, { ...get2(builder), ...$$restProps }, true, ""));
                          action(div_4, ($$node) => get2(builder).action($$node));
                          append($$anchor7, div_4);
                        },
                        null,
                        true
                      );
                      append($$anchor6, fragment_6);
                    },
                    true
                  );
                  append($$anchor5, fragment_5);
                },
                true
              );
              append($$anchor4, fragment_4);
            },
            true
          );
          append($$anchor3, fragment_3);
        },
        true
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_content);
  const filename = Date_picker_content.filename;
  const $$original = Date_picker_content;
  Date_picker_content = hmr(s);
  Date_picker_content.filename = filename;
  Date_picker_content[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_content_default = Date_picker_content;
mark_module_end(Date_picker_content);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-field.svelte
mark_module_start();
Date_picker_field[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-field.svelte";
function Date_picker_field($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Date_picker_field);
  const $$stores = setup_stores();
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  const $localIsInvalid = () => (validate_store(localIsInvalid, "localIsInvalid"), store_get(localIsInvalid, "$localIsInvalid", $$stores));
  let value = prop($$props, "value", 12, () => void 0);
  let onValueChange = prop($$props, "onValueChange", 8, () => void 0);
  let placeholder = prop($$props, "placeholder", 12, () => void 0);
  let onPlaceholderChange = prop($$props, "onPlaceholderChange", 8, () => void 0);
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let isDateUnavailable = prop($$props, "isDateUnavailable", 8, () => void 0);
  let granularity = prop($$props, "granularity", 8, () => void 0);
  let hideTimeZone = prop($$props, "hideTimeZone", 8, () => void 0);
  let hourCycle = prop($$props, "hourCycle", 8, () => void 0);
  let locale = prop($$props, "locale", 8, () => void 0);
  let maxValue = prop($$props, "maxValue", 8, () => void 0);
  let minValue = prop($$props, "minValue", 8, () => void 0);
  let readonly2 = prop($$props, "readonly", 8, () => void 0);
  let validationId = prop($$props, "validationId", 8, () => void 0);
  let descriptionId = prop($$props, "descriptionId", 8, () => void 0);
  const {
    states: {
      value: localValue,
      placeholder: localPlaceholder,
      isInvalid: localIsInvalid
    },
    updateOption,
    ids
  } = setCtx13({
    defaultValue: value(),
    defaultPlaceholder: placeholder(),
    disabled: disabled(),
    granularity: granularity(),
    hideTimeZone: hideTimeZone(),
    hourCycle: hourCycle(),
    locale: locale(),
    maxValue: maxValue(),
    minValue: minValue(),
    readonly: readonly2(),
    isDateUnavailable: isDateUnavailable(),
    onValueChange: ({ next: next2 }) => {
      var _a;
      if (value() !== next2) {
        (_a = onValueChange()) == null ? void 0 : _a(next2);
        value(next2);
      }
      return next2;
    },
    onPlaceholderChange: ({ next: next2 }) => {
      var _a;
      if (placeholder() !== next2) {
        (_a = onPlaceholderChange()) == null ? void 0 : _a(next2);
        placeholder(next2);
      }
      return next2;
    }
  });
  const idValues = derived(
    [
      ids.dateField.day,
      ids.dateField.description,
      ids.dateField.dayPeriod,
      ids.dateField.field,
      ids.dateField.hour,
      ids.dateField.minute,
      ids.dateField.month,
      ids.dateField.second,
      ids.dateField.year,
      ids.dateField.validation,
      ids.dateField.label,
      ids.dateField.timeZoneName
    ],
    ([
      $dayId,
      $descriptionId,
      $dayPeriodId,
      $fieldId,
      $hourId,
      $minuteId,
      $monthId,
      $secondId,
      $yearId,
      $validationId,
      $labelId,
      $timeZoneNameId
    ]) => ({
      day: $dayId,
      description: $descriptionId,
      dayPeriod: $dayPeriodId,
      field: $fieldId,
      hour: $hourId,
      minute: $minuteId,
      month: $monthId,
      second: $secondId,
      year: $yearId,
      validation: $validationId,
      label: $labelId,
      timeZoneName: $timeZoneNameId
    })
  );
  legacy_pre_effect(() => deep_read_state(validationId()), () => {
    if (validationId()) {
      ids.dateField.validation.set(validationId());
    }
  });
  legacy_pre_effect(() => deep_read_state(descriptionId()), () => {
    if (descriptionId()) {
      ids.dateField.description.set(descriptionId());
    }
  });
  legacy_pre_effect(() => deep_read_state(value()), () => {
    value() !== void 0 && localValue.set(value());
  });
  legacy_pre_effect(() => deep_read_state(placeholder()), () => {
    placeholder() !== void 0 && localPlaceholder.set(placeholder());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => deep_read_state(isDateUnavailable()), () => {
    updateOption("isDateUnavailable", isDateUnavailable());
  });
  legacy_pre_effect(() => deep_read_state(granularity()), () => {
    updateOption("granularity", granularity());
  });
  legacy_pre_effect(() => deep_read_state(hideTimeZone()), () => {
    updateOption("hideTimeZone", hideTimeZone());
  });
  legacy_pre_effect(() => deep_read_state(hourCycle()), () => {
    updateOption("hourCycle", hourCycle());
  });
  legacy_pre_effect(() => deep_read_state(locale()), () => {
    updateOption("locale", locale());
  });
  legacy_pre_effect(() => deep_read_state(maxValue()), () => {
    updateOption("maxValue", maxValue());
  });
  legacy_pre_effect(() => deep_read_state(minValue()), () => {
    updateOption("minValue", minValue());
  });
  legacy_pre_effect(() => deep_read_state(readonly2()), () => {
    updateOption("readonly", readonly2());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get ids() {
        return $idValues();
      },
      get isInvalid() {
        return $localIsInvalid();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_field);
  const filename = Date_picker_field.filename;
  const $$original = Date_picker_field;
  Date_picker_field = hmr(s);
  Date_picker_field.filename = filename;
  Date_picker_field[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_field_default = Date_picker_field;
mark_module_end(Date_picker_field);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-input.svelte
mark_module_start();
Date_picker_input[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-input.svelte";
var root_251 = add_locations(template(`<div><!></div>`), Date_picker_input[FILENAME], [[26, 1]]);
function Date_picker_input($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Date_picker_input);
  const $$stores = setup_stores();
  const $field = () => (validate_store(field, "field"), store_get(field, "$field", $$stores));
  const $segmentContents = () => (validate_store(segmentContents, "segmentContents"), store_get(segmentContents, "$segmentContents", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { field },
    states: { segmentContents },
    ids,
    getFieldAttrs
  } = getCtx12();
  const attrs = getFieldAttrs("input");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.dateField.field.set(id());
    }
  });
  legacy_pre_effect(() => $field(), () => {
    set(builder, $field());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          builder: true,
          get segments() {
            return $segmentContents();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_251();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          builder: true,
          get segments() {
            return $segmentContents();
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_input);
  const filename = Date_picker_input.filename;
  const $$original = Date_picker_input;
  Date_picker_input = hmr(s);
  Date_picker_input.filename = filename;
  Date_picker_input[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_input_default = Date_picker_input;
mark_module_end(Date_picker_input);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-label.svelte
mark_module_start();
Date_picker_label[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-label.svelte";
var root_252 = add_locations(template(`<span><!></span>`), Date_picker_label[FILENAME], [[24, 1]]);
function Date_picker_label($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Date_picker_label);
  const $$stores = setup_stores();
  const $label = () => (validate_store(label, "label"), store_get(label, "$label", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { label }, ids, getFieldAttrs } = getCtx12();
  if (id()) {
    ids.dateField.label.set(id());
  }
  const attrs = getFieldAttrs("label");
  legacy_pre_effect(() => $label(), () => {
    set(builder, $label());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_252();
      bind_this(span, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(span);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(span);
      template_effect(() => attributes = set_attributes(span, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(span, ($$node) => get2(builder).action($$node));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_label);
  const filename = Date_picker_label.filename;
  const $$original = Date_picker_label;
  Date_picker_label = hmr(s);
  Date_picker_label.filename = filename;
  Date_picker_label[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_label_default = Date_picker_label;
mark_module_end(Date_picker_label);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-segment.svelte
mark_module_start();
Date_picker_segment[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-segment.svelte";
var root_253 = add_locations(template(`<div><!></div>`), Date_picker_segment[FILENAME], [[28, 1]]);
function Date_picker_segment($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "part", "el"]);
  push($$props, false, Date_picker_segment);
  const $$stores = setup_stores();
  const $segment = () => (validate_store(segment, "segment"), store_get(segment, "$segment", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let part = prop($$props, "part");
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { segment }, ids, getFieldAttrs } = getCtx12();
  const attrs = getFieldAttrs("segment");
  const dispatch = createDispatcher();
  legacy_pre_effect(
    () => (deep_read_state(id()), deep_read_state(part())),
    () => {
      if (id() && part() !== "literal") {
        ids.dateField[part()].set(id());
      }
    }
  );
  legacy_pre_effect(
    () => ($segment(), deep_read_state(part())),
    () => {
      set(builder, $segment()(part()));
    }
  );
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_253();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      event("m-click", div, dispatch, false);
      event("m-focusout", div, dispatch, false);
      event("m-focusout", div, dispatch, false);
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_segment);
  const filename = Date_picker_segment.filename;
  const $$original = Date_picker_segment;
  Date_picker_segment = hmr(s);
  Date_picker_segment.filename = filename;
  Date_picker_segment[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_segment_default = Date_picker_segment;
mark_module_end(Date_picker_segment);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-trigger.svelte
mark_module_start();
Date_picker_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-trigger.svelte";
var root_254 = add_locations(template(`<button><!></button>`), Date_picker_trigger[FILENAME], [[27, 1]]);
function Date_picker_trigger($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Date_picker_trigger);
  const $$stores = setup_stores();
  const $trigger = () => (validate_store(trigger, "trigger"), store_get(trigger, "$trigger", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { trigger },
    ids,
    getPopoverAttrs
  } = getCtx12();
  const dispatch = createDispatcher();
  const attrs = getPopoverAttrs("trigger");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.popover.trigger.set(id());
    }
  });
  legacy_pre_effect(() => $trigger(), () => {
    set(builder, $trigger());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_254();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_trigger);
  const filename = Date_picker_trigger.filename;
  const $$original = Date_picker_trigger;
  Date_picker_trigger = hmr(s);
  Date_picker_trigger.filename = filename;
  Date_picker_trigger[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_trigger_default = Date_picker_trigger;
mark_module_end(Date_picker_trigger);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker.svelte
mark_module_start();
Date_picker[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker.svelte";
function Date_picker($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Date_picker);
  const $$stores = setup_stores();
  const $localValue = () => (validate_store(localValue, "localValue"), store_get(localValue, "$localValue", $$stores));
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  const $localIsInvalid = () => (validate_store(localIsInvalid, "localIsInvalid"), store_get(localIsInvalid, "$localIsInvalid", $$stores));
  let open = prop($$props, "open", 12, () => void 0);
  let onOpenChange = prop($$props, "onOpenChange", 8, () => void 0);
  let value = prop($$props, "value", 12, () => void 0);
  let onValueChange = prop($$props, "onValueChange", 8, () => void 0);
  let placeholder = prop($$props, "placeholder", 12, () => void 0);
  let onPlaceholderChange = prop($$props, "onPlaceholderChange", 8, () => void 0);
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let isDateUnavailable = prop($$props, "isDateUnavailable", 8, () => void 0);
  let granularity = prop($$props, "granularity", 8, () => void 0);
  let hideTimeZone = prop($$props, "hideTimeZone", 8, () => void 0);
  let hourCycle = prop($$props, "hourCycle", 8, () => void 0);
  let locale = prop($$props, "locale", 8, () => void 0);
  let maxValue = prop($$props, "maxValue", 8, () => void 0);
  let minValue = prop($$props, "minValue", 8, () => void 0);
  let readonly2 = prop($$props, "readonly", 8, () => void 0);
  let validationId = prop($$props, "validationId", 8, () => void 0);
  let descriptionId = prop($$props, "descriptionId", 8, () => void 0);
  let preventDeselect = prop($$props, "preventDeselect", 8, () => void 0);
  let pagedNavigation = prop($$props, "pagedNavigation", 8, () => void 0);
  let weekStartsOn = prop($$props, "weekStartsOn", 8, () => void 0);
  let isDateDisabled = prop($$props, "isDateDisabled", 8, () => void 0);
  let fixedWeeks = prop($$props, "fixedWeeks", 8, () => void 0);
  let calendarLabel = prop($$props, "calendarLabel", 8, () => void 0);
  let weekdayFormat = prop($$props, "weekdayFormat", 8, () => void 0);
  let numberOfMonths = prop($$props, "numberOfMonths", 8, () => void 0);
  let onOutsideClick = prop($$props, "onOutsideClick", 8, () => void 0);
  const {
    states: {
      open: localOpen,
      value: localValue,
      placeholder: localPlaceholder,
      isInvalid: localIsInvalid
    },
    updateOption,
    ids
  } = setCtx13({
    defaultOpen: open(),
    defaultValue: value(),
    defaultPlaceholder: placeholder(),
    preventDeselect: preventDeselect(),
    pagedNavigation: pagedNavigation(),
    weekStartsOn: weekStartsOn(),
    isDateDisabled: isDateDisabled(),
    fixedWeeks: fixedWeeks(),
    calendarLabel: calendarLabel(),
    disabled: disabled(),
    granularity: granularity(),
    hideTimeZone: hideTimeZone(),
    hourCycle: hourCycle(),
    locale: locale(),
    maxValue: maxValue(),
    minValue: minValue(),
    readonly: readonly2(),
    weekdayFormat: weekdayFormat(),
    numberOfMonths: numberOfMonths(),
    isDateUnavailable: isDateUnavailable(),
    onOutsideClick: onOutsideClick(),
    onValueChange: ({ next: next2 }) => {
      var _a;
      if (value() !== next2) {
        (_a = onValueChange()) == null ? void 0 : _a(next2);
        value(next2);
      }
      return next2;
    },
    onPlaceholderChange: ({ next: next2 }) => {
      var _a;
      if (placeholder() !== next2) {
        (_a = onPlaceholderChange()) == null ? void 0 : _a(next2);
        placeholder(next2);
      }
      return next2;
    },
    onOpenChange: ({ next: next2 }) => {
      var _a;
      if (open() !== next2) {
        (_a = onOpenChange()) == null ? void 0 : _a(next2);
        open(next2);
      }
      return next2;
    }
  });
  const idValues = derived(
    [
      ids.dateField.day,
      ids.dateField.description,
      ids.dateField.dayPeriod,
      ids.dateField.field,
      ids.dateField.hour,
      ids.dateField.minute,
      ids.dateField.month,
      ids.dateField.second,
      ids.dateField.year,
      ids.dateField.validation,
      ids.dateField.label,
      ids.dateField.timeZoneName,
      ids.calendar.calendar,
      ids.popover.content,
      ids.popover.trigger
    ],
    ([
      $dayId,
      $descriptionId,
      $dayPeriodId,
      $fieldId,
      $hourId,
      $minuteId,
      $monthId,
      $secondId,
      $yearId,
      $validationId,
      $labelId,
      $timeZoneNameId,
      $calendarId,
      $contentId
    ]) => ({
      day: $dayId,
      description: $descriptionId,
      dayPeriod: $dayPeriodId,
      field: $fieldId,
      hour: $hourId,
      minute: $minuteId,
      month: $monthId,
      second: $secondId,
      year: $yearId,
      validation: $validationId,
      label: $labelId,
      timeZoneName: $timeZoneNameId,
      calendar: $calendarId,
      content: $contentId
    })
  );
  legacy_pre_effect(() => deep_read_state(validationId()), () => {
    if (validationId()) {
      ids.dateField.validation.set(validationId());
    }
  });
  legacy_pre_effect(() => deep_read_state(descriptionId()), () => {
    if (descriptionId()) {
      ids.dateField.description.set(descriptionId());
    }
  });
  legacy_pre_effect(
    () => (deep_read_state(value()), $localValue()),
    () => {
      value() !== $localValue() && localValue.set(value());
    }
  );
  legacy_pre_effect(() => deep_read_state(placeholder()), () => {
    placeholder() !== void 0 && localPlaceholder.set(placeholder());
  });
  legacy_pre_effect(() => deep_read_state(open()), () => {
    open() !== void 0 && localOpen.set(open());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => deep_read_state(isDateUnavailable()), () => {
    updateOption("isDateUnavailable", isDateUnavailable());
  });
  legacy_pre_effect(() => deep_read_state(granularity()), () => {
    updateOption("granularity", granularity());
  });
  legacy_pre_effect(() => deep_read_state(hideTimeZone()), () => {
    updateOption("hideTimeZone", hideTimeZone());
  });
  legacy_pre_effect(() => deep_read_state(hourCycle()), () => {
    updateOption("hourCycle", hourCycle());
  });
  legacy_pre_effect(() => deep_read_state(locale()), () => {
    updateOption("locale", locale());
  });
  legacy_pre_effect(() => deep_read_state(maxValue()), () => {
    updateOption("maxValue", maxValue());
  });
  legacy_pre_effect(() => deep_read_state(minValue()), () => {
    updateOption("minValue", minValue());
  });
  legacy_pre_effect(() => deep_read_state(readonly2()), () => {
    updateOption("readonly", readonly2());
  });
  legacy_pre_effect(() => deep_read_state(fixedWeeks()), () => {
    updateOption("fixedWeeks", fixedWeeks());
  });
  legacy_pre_effect(() => deep_read_state(preventDeselect()), () => {
    updateOption("preventDeselect", preventDeselect());
  });
  legacy_pre_effect(() => deep_read_state(pagedNavigation()), () => {
    updateOption("pagedNavigation", pagedNavigation());
  });
  legacy_pre_effect(() => deep_read_state(weekStartsOn()), () => {
    updateOption("weekStartsOn", weekStartsOn());
  });
  legacy_pre_effect(() => deep_read_state(isDateDisabled()), () => {
    updateOption("isDateDisabled", isDateDisabled());
  });
  legacy_pre_effect(() => deep_read_state(calendarLabel()), () => {
    updateOption("calendarLabel", calendarLabel());
  });
  legacy_pre_effect(() => deep_read_state(weekdayFormat()), () => {
    updateOption("weekdayFormat", weekdayFormat());
  });
  legacy_pre_effect(() => deep_read_state(numberOfMonths()), () => {
    updateOption("numberOfMonths", numberOfMonths());
  });
  legacy_pre_effect(() => deep_read_state(onOutsideClick()), () => {
    updateOption("onOutsideClick", onOutsideClick());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get ids() {
        return $idValues();
      },
      get isInvalid() {
        return $localIsInvalid();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker);
  const filename = Date_picker.filename;
  const $$original = Date_picker;
  Date_picker = hmr(s);
  Date_picker.filename = filename;
  Date_picker[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_default = Date_picker;
mark_module_end(Date_picker);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-grid-body.svelte
mark_module_start();
Date_picker_grid_body[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-grid-body.svelte";
var root_255 = add_locations(template(`<tbody><!></tbody>`), Date_picker_grid_body[FILENAME], [[11, 1]]);
function Date_picker_grid_body($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_picker_grid_body);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getCalendarAttrs } = getCtx12();
  const attrs = getCalendarAttrs("grid-body");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var tbody = root_255();
      bind_this(tbody, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(tbody);
      slot(node_2, default_slot($$props), { attrs }, null);
      reset(tbody);
      template_effect(() => attributes = set_attributes(tbody, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, tbody);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_grid_body);
  const filename = Date_picker_grid_body.filename;
  const $$original = Date_picker_grid_body;
  Date_picker_grid_body = hmr(s);
  Date_picker_grid_body.filename = filename;
  Date_picker_grid_body[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_grid_body_default = Date_picker_grid_body;
mark_module_end(Date_picker_grid_body);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-grid-head.svelte
mark_module_start();
Date_picker_grid_head[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-grid-head.svelte";
var root_256 = add_locations(template(`<thead><!></thead>`), Date_picker_grid_head[FILENAME], [[14, 1]]);
function Date_picker_grid_head($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_picker_grid_head);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getCalendarAttrs } = getCtx12();
  const attrs = {
    ...getCalendarAttrs("grid-head"),
    "aria-hidden": true
  };
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var thead = root_256();
      bind_this(thead, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(thead);
      slot(node_2, default_slot($$props), { attrs }, null);
      reset(thead);
      template_effect(() => attributes = set_attributes(thead, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, thead);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_grid_head);
  const filename = Date_picker_grid_head.filename;
  const $$original = Date_picker_grid_head;
  Date_picker_grid_head = hmr(s);
  Date_picker_grid_head.filename = filename;
  Date_picker_grid_head[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_grid_head_default = Date_picker_grid_head;
mark_module_end(Date_picker_grid_head);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-grid-row.svelte
mark_module_start();
Date_picker_grid_row[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-grid-row.svelte";
var root_257 = add_locations(template(`<tr><!></tr>`), Date_picker_grid_row[FILENAME], [[11, 1]]);
function Date_picker_grid_row($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_picker_grid_row);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getCalendarAttrs } = getCtx12();
  const attrs = getCalendarAttrs("grid-row");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var tr = root_257();
      bind_this(tr, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(tr);
      slot(node_2, default_slot($$props), { attrs }, null);
      reset(tr);
      template_effect(() => attributes = set_attributes(tr, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, tr);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_grid_row);
  const filename = Date_picker_grid_row.filename;
  const $$original = Date_picker_grid_row;
  Date_picker_grid_row = hmr(s);
  Date_picker_grid_row.filename = filename;
  Date_picker_grid_row[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_grid_row_default = Date_picker_grid_row;
mark_module_end(Date_picker_grid_row);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-head-cell.svelte
mark_module_start();
Date_picker_head_cell[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-head-cell.svelte";
var root_258 = add_locations(template(`<th><!></th>`), Date_picker_head_cell[FILENAME], [[11, 1]]);
function Date_picker_head_cell($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_picker_head_cell);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getCalendarAttrs } = getCtx12();
  const attrs = getCalendarAttrs("head-cell");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var th = root_258();
      bind_this(th, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(th);
      slot(node_2, default_slot($$props), { attrs }, null);
      reset(th);
      template_effect(() => attributes = set_attributes(th, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, th);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_head_cell);
  const filename = Date_picker_head_cell.filename;
  const $$original = Date_picker_head_cell;
  Date_picker_head_cell = hmr(s);
  Date_picker_head_cell.filename = filename;
  Date_picker_head_cell[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_head_cell_default = Date_picker_head_cell;
mark_module_end(Date_picker_head_cell);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-header.svelte
mark_module_start();
Date_picker_header[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-header.svelte";
var root_259 = add_locations(template(`<header><!></header>`), Date_picker_header[FILENAME], [[11, 1]]);
function Date_picker_header($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_picker_header);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getCalendarAttrs } = getCtx12();
  const attrs = getCalendarAttrs("header");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var header = root_259();
      bind_this(header, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(header);
      slot(node_2, default_slot($$props), { attrs }, null);
      reset(header);
      template_effect(() => attributes = set_attributes(header, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, header);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_header);
  const filename = Date_picker_header.filename;
  const $$original = Date_picker_header;
  Date_picker_header = hmr(s);
  Date_picker_header.filename = filename;
  Date_picker_header[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_header_default = Date_picker_header;
mark_module_end(Date_picker_header);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-cell.svelte
mark_module_start();
Date_picker_cell[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-cell.svelte";
var root_260 = add_locations(template(`<td><!></td>`), Date_picker_cell[FILENAME], [[21, 1]]);
function Date_picker_cell($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["date", "asChild", "el"]);
  push($$props, false, Date_picker_cell);
  const $$stores = setup_stores();
  const $isDateDisabled = () => (validate_store(isDateDisabled, "isDateDisabled"), store_get(isDateDisabled, "$isDateDisabled", $$stores));
  const $isDateUnavailable = () => (validate_store(isDateUnavailable, "isDateUnavailable"), store_get(isDateUnavailable, "$isDateUnavailable", $$stores));
  const attrs = mutable_source();
  let date = prop($$props, "date");
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    helpers: { isDateDisabled, isDateUnavailable },
    getCalendarAttrs
  } = getCtx12();
  legacy_pre_effect(
    () => ($isDateDisabled(), deep_read_state(date()), $isDateUnavailable()),
    () => {
      set(attrs, {
        ...getCalendarAttrs("cell"),
        "aria-disabled": $isDateDisabled()(date()) || $isDateUnavailable()(date()),
        "data-disabled": $isDateDisabled()(date()) ? "" : void 0,
        role: "gridcell"
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get attrs() {
            return get2(attrs);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var td = root_260();
      bind_this(td, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(td);
      slot(
        node_2,
        default_slot($$props),
        {
          get attrs() {
            return get2(attrs);
          }
        },
        null
      );
      reset(td);
      template_effect(() => attributes = set_attributes(td, attributes, { ...$$restProps, ...get2(attrs) }, true, ""));
      append($$anchor2, td);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_cell);
  const filename = Date_picker_cell.filename;
  const $$original = Date_picker_cell;
  Date_picker_cell = hmr(s);
  Date_picker_cell.filename = filename;
  Date_picker_cell[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_cell_default = Date_picker_cell;
mark_module_end(Date_picker_cell);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-day.svelte
mark_module_start();
Date_picker_day[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-day.svelte";
var root_261 = add_locations(template(`<div><!></div>`), Date_picker_day[FILENAME], [[30, 1]]);
function Date_picker_day($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["date", "month", "asChild", "el"]);
  push($$props, false, Date_picker_day);
  const $$stores = setup_stores();
  const $cell = () => (validate_store(cell, "cell"), store_get(cell, "$cell", $$stores));
  const $isDateDisabled = () => (validate_store(isDateDisabled, "isDateDisabled"), store_get(isDateDisabled, "$isDateDisabled", $$stores));
  const $isDateUnavailable = () => (validate_store(isDateUnavailable, "isDateUnavailable"), store_get(isDateUnavailable, "$isDateUnavailable", $$stores));
  const $isDateSelected = () => (validate_store(isDateSelected, "isDateSelected"), store_get(isDateSelected, "$isDateSelected", $$stores));
  const builder = mutable_source();
  const disabled = mutable_source();
  const unavailable = mutable_source();
  const selected = mutable_source();
  let date = prop($$props, "date");
  let month = prop($$props, "month");
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { cell },
    helpers: {
      isDateDisabled,
      isDateUnavailable,
      isDateSelected
    },
    getCalendarAttrs
  } = getCtx12();
  const attrs = getCalendarAttrs("day");
  const dispatch = createDispatcher();
  legacy_pre_effect(
    () => ($cell(), deep_read_state(date()), deep_read_state(month())),
    () => {
      set(builder, $cell()(date(), month()));
    }
  );
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(
    () => ($isDateDisabled(), deep_read_state(date())),
    () => {
      set(disabled, $isDateDisabled()(date()));
    }
  );
  legacy_pre_effect(
    () => ($isDateUnavailable(), deep_read_state(date())),
    () => {
      set(unavailable, $isDateUnavailable()(date()));
    }
  );
  legacy_pre_effect(
    () => ($isDateSelected(), deep_read_state(date())),
    () => {
      set(selected, $isDateSelected()(date()));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get disabled() {
            return get2(disabled);
          },
          get unavailable() {
            return get2(unavailable);
          },
          get selected() {
            return get2(selected);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_261();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get disabled() {
            return get2(disabled);
          },
          get unavailable() {
            return get2(unavailable);
          },
          get selected() {
            return get2(selected);
          }
        },
        ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, date().day));
          append($$anchor3, text2);
        }
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      event("m-click", div, dispatch, false);
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_day);
  const filename = Date_picker_day.filename;
  const $$original = Date_picker_day;
  Date_picker_day = hmr(s);
  Date_picker_day.filename = filename;
  Date_picker_day[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_day_default = Date_picker_day;
mark_module_end(Date_picker_day);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-grid.svelte
mark_module_start();
Date_picker_grid[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-grid.svelte";
var root_262 = add_locations(template(`<table><!></table>`), Date_picker_grid[FILENAME], [[19, 1]]);
function Date_picker_grid($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_picker_grid);
  const $$stores = setup_stores();
  const $grid = () => (validate_store(grid, "grid"), store_get(grid, "$grid", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { grid }, getCalendarAttrs } = getCtx12();
  const attrs = getCalendarAttrs("grid");
  legacy_pre_effect(() => $grid(), () => {
    set(builder, $grid());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var table = root_262();
      bind_this(table, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(table);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(table);
      template_effect(() => attributes = set_attributes(table, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(table, ($$node) => get2(builder).action($$node));
      append($$anchor2, table);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_grid);
  const filename = Date_picker_grid.filename;
  const $$original = Date_picker_grid;
  Date_picker_grid = hmr(s);
  Date_picker_grid.filename = filename;
  Date_picker_grid[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_grid_default = Date_picker_grid;
mark_module_end(Date_picker_grid);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-heading.svelte
mark_module_start();
Date_picker_heading[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-heading.svelte";
var root_263 = add_locations(template(`<div><!></div>`), Date_picker_heading[FILENAME], [[20, 1]]);
function Date_picker_heading($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_picker_heading);
  const $$stores = setup_stores();
  const $heading = () => (validate_store(heading, "heading"), store_get(heading, "$heading", $$stores));
  const $headingValue = () => (validate_store(headingValue, "headingValue"), store_get(headingValue, "$headingValue", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { heading },
    states: { headingValue },
    getCalendarAttrs
  } = getCtx12();
  const attrs = getCalendarAttrs("heading");
  legacy_pre_effect(() => $heading(), () => {
    set(builder, $heading());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get headingValue() {
            return $headingValue();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_263();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get headingValue() {
            return $headingValue();
          }
        },
        ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, $headingValue()));
          append($$anchor3, text2);
        }
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_heading);
  const filename = Date_picker_heading.filename;
  const $$original = Date_picker_heading;
  Date_picker_heading = hmr(s);
  Date_picker_heading.filename = filename;
  Date_picker_heading[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_heading_default = Date_picker_heading;
mark_module_end(Date_picker_heading);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-next-button.svelte
mark_module_start();
Date_picker_next_button[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-next-button.svelte";
var root_264 = add_locations(template(`<button><!></button>`), Date_picker_next_button[FILENAME], [[21, 1]]);
function Date_picker_next_button($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_picker_next_button);
  const $$stores = setup_stores();
  const $nextButton = () => (validate_store(nextButton, "nextButton"), store_get(nextButton, "$nextButton", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { nextButton }, getCalendarAttrs } = getCtx12();
  const attrs = getCalendarAttrs("next-button");
  const dispatch = createDispatcher();
  legacy_pre_effect(() => $nextButton(), () => {
    set(builder, $nextButton());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_264();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_next_button);
  const filename = Date_picker_next_button.filename;
  const $$original = Date_picker_next_button;
  Date_picker_next_button = hmr(s);
  Date_picker_next_button.filename = filename;
  Date_picker_next_button[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_next_button_default = Date_picker_next_button;
mark_module_end(Date_picker_next_button);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-prev-button.svelte
mark_module_start();
Date_picker_prev_button[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-prev-button.svelte";
var root_265 = add_locations(template(`<button><!></button>`), Date_picker_prev_button[FILENAME], [[21, 1]]);
function Date_picker_prev_button($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_picker_prev_button);
  const $$stores = setup_stores();
  const $prevButton = () => (validate_store(prevButton, "prevButton"), store_get(prevButton, "$prevButton", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { prevButton }, getCalendarAttrs } = getCtx12();
  const attrs = getCalendarAttrs("prev-button");
  const dispatch = createDispatcher();
  legacy_pre_effect(() => $prevButton(), () => {
    set(builder, $prevButton());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_265();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_picker_prev_button);
  const filename = Date_picker_prev_button.filename;
  const $$original = Date_picker_prev_button;
  Date_picker_prev_button = hmr(s);
  Date_picker_prev_button.filename = filename;
  Date_picker_prev_button[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_picker_prev_button_default = Date_picker_prev_button;
mark_module_end(Date_picker_prev_button);

// node_modules/bits-ui/dist/bits/date-range-field/index.js
var date_range_field_exports = {};
__export(date_range_field_exports, {
  Input: () => date_range_field_input_default,
  Label: () => date_range_field_label_default,
  Root: () => date_range_field_default,
  Segment: () => date_range_field_segment_default
});

// node_modules/bits-ui/dist/bits/date-range-field/ctx.js
function setCtx14(props) {
  const { NAME, PARTS } = getDateFieldData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const dateRangeField = { ...createDateRangeField(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(NAME, dateRangeField);
  return {
    ...dateRangeField,
    updateOption: getOptionUpdater(dateRangeField.options)
  };
}
function getCtx13() {
  const { NAME } = getDateFieldData();
  return getContext(NAME);
}

// node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field.svelte
mark_module_start();
Date_range_field[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field.svelte";
function Date_range_field($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Date_range_field);
  const $$stores = setup_stores();
  const $startIdValues = () => (validate_store(startIdValues, "startIdValues"), store_get(startIdValues, "$startIdValues", $$stores));
  const $endIdValues = () => (validate_store(endIdValues, "endIdValues"), store_get(endIdValues, "$endIdValues", $$stores));
  const $fieldIdValues = () => (validate_store(fieldIdValues, "fieldIdValues"), store_get(fieldIdValues, "$fieldIdValues", $$stores));
  const $localIsInvalid = () => (validate_store(localIsInvalid, "localIsInvalid"), store_get(localIsInvalid, "$localIsInvalid", $$stores));
  const idSlotProp = mutable_source();
  let value = prop($$props, "value", 12, () => void 0);
  let onValueChange = prop($$props, "onValueChange", 8, () => void 0);
  let placeholder = prop($$props, "placeholder", 12, () => void 0);
  let onPlaceholderChange = prop($$props, "onPlaceholderChange", 8, () => void 0);
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let isDateUnavailable = prop($$props, "isDateUnavailable", 8, () => void 0);
  let granularity = prop($$props, "granularity", 8, () => void 0);
  let hideTimeZone = prop($$props, "hideTimeZone", 8, () => void 0);
  let hourCycle = prop($$props, "hourCycle", 8, () => void 0);
  let locale = prop($$props, "locale", 8, () => void 0);
  let maxValue = prop($$props, "maxValue", 8, () => void 0);
  let minValue = prop($$props, "minValue", 8, () => void 0);
  let readonly2 = prop($$props, "readonly", 8, () => void 0);
  let validationId = prop($$props, "validationId", 8, () => void 0);
  let descriptionId = prop($$props, "descriptionId", 8, () => void 0);
  let readonlySegments = prop($$props, "readonlySegments", 8, () => void 0);
  const {
    states: {
      value: localValue,
      placeholder: localPlaceholder,
      isInvalid: localIsInvalid
    },
    updateOption,
    ids
  } = setCtx14({
    defaultValue: value(),
    defaultPlaceholder: placeholder(),
    disabled: disabled(),
    granularity: granularity(),
    hideTimeZone: hideTimeZone(),
    hourCycle: hourCycle(),
    locale: locale(),
    maxValue: maxValue(),
    minValue: minValue(),
    readonly: readonly2(),
    isDateUnavailable: isDateUnavailable(),
    readonlySegments: readonlySegments(),
    onValueChange: ({ next: next2 }) => {
      var _a;
      if (value() !== next2) {
        (_a = onValueChange()) == null ? void 0 : _a(next2);
        value(next2);
      }
      return next2;
    },
    onPlaceholderChange: ({ next: next2 }) => {
      var _a;
      if (placeholder() !== next2) {
        (_a = onPlaceholderChange()) == null ? void 0 : _a(next2);
        placeholder(next2);
      }
      return next2;
    }
  });
  const startIdValues = derived(
    [
      ids.start.day,
      ids.start.description,
      ids.start.dayPeriod,
      ids.start.hour,
      ids.start.minute,
      ids.start.month,
      ids.start.second,
      ids.start.year,
      ids.start.validation,
      ids.start.label,
      ids.start.timeZoneName
    ],
    ([
      $dayId,
      $descriptionId,
      $dayPeriodId,
      $hourId,
      $minuteId,
      $monthId,
      $secondId,
      $yearId,
      $validationId,
      $labelId,
      $timeZoneNameId
    ]) => ({
      day: $dayId,
      description: $descriptionId,
      dayPeriod: $dayPeriodId,
      hour: $hourId,
      minute: $minuteId,
      month: $monthId,
      second: $secondId,
      year: $yearId,
      validation: $validationId,
      label: $labelId,
      timeZoneName: $timeZoneNameId
    })
  );
  const endIdValues = derived(
    [
      ids.end.day,
      ids.end.description,
      ids.end.dayPeriod,
      ids.end.hour,
      ids.end.minute,
      ids.end.month,
      ids.end.second,
      ids.end.year,
      ids.end.validation,
      ids.end.label,
      ids.end.timeZoneName
    ],
    ([
      $dayId,
      $descriptionId,
      $dayPeriodId,
      $hourId,
      $minuteId,
      $monthId,
      $secondId,
      $yearId,
      $validationId,
      $labelId,
      $timeZoneNameId
    ]) => ({
      day: $dayId,
      description: $descriptionId,
      dayPeriod: $dayPeriodId,
      hour: $hourId,
      minute: $minuteId,
      month: $monthId,
      second: $secondId,
      year: $yearId,
      validation: $validationId,
      label: $labelId,
      timeZoneName: $timeZoneNameId
    })
  );
  const fieldIdValues = derived(
    [
      ids.field.description,
      ids.field.field,
      ids.field.label,
      ids.field.validation
    ],
    ([
      $descriptionId,
      $fieldId,
      $labelId,
      $validationId
    ]) => ({
      description: $descriptionId,
      field: $fieldId,
      label: $labelId,
      validation: $validationId
    })
  );
  legacy_pre_effect(() => deep_read_state(descriptionId()), () => {
    if (descriptionId()) {
      ids.field.description.set(descriptionId());
    }
  });
  legacy_pre_effect(() => deep_read_state(validationId()), () => {
    if (validationId()) {
      ids.field.validation.set(validationId());
    }
  });
  legacy_pre_effect(() => deep_read_state(value()), () => {
    value() !== void 0 && localValue.set(value());
  });
  legacy_pre_effect(() => deep_read_state(placeholder()), () => {
    placeholder() !== void 0 && localPlaceholder.set(placeholder());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => deep_read_state(isDateUnavailable()), () => {
    updateOption("isDateUnavailable", isDateUnavailable());
  });
  legacy_pre_effect(() => deep_read_state(granularity()), () => {
    updateOption("granularity", granularity());
  });
  legacy_pre_effect(() => deep_read_state(hideTimeZone()), () => {
    updateOption("hideTimeZone", hideTimeZone());
  });
  legacy_pre_effect(() => deep_read_state(hourCycle()), () => {
    updateOption("hourCycle", hourCycle());
  });
  legacy_pre_effect(() => deep_read_state(locale()), () => {
    updateOption("locale", locale());
  });
  legacy_pre_effect(() => deep_read_state(maxValue()), () => {
    updateOption("maxValue", maxValue());
  });
  legacy_pre_effect(() => deep_read_state(minValue()), () => {
    updateOption("minValue", minValue());
  });
  legacy_pre_effect(() => deep_read_state(readonly2()), () => {
    updateOption("readonly", readonly2());
  });
  legacy_pre_effect(() => deep_read_state(readonlySegments()), () => {
    updateOption("readonlySegments", readonlySegments());
  });
  legacy_pre_effect(
    () => ($startIdValues(), $endIdValues(), $fieldIdValues()),
    () => {
      set(idSlotProp, {
        start: $startIdValues(),
        end: $endIdValues(),
        field: $fieldIdValues()
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get isInvalid() {
        return $localIsInvalid();
      },
      get ids() {
        return get2(idSlotProp);
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_field);
  const filename = Date_range_field.filename;
  const $$original = Date_range_field;
  Date_range_field = hmr(s);
  Date_range_field.filename = filename;
  Date_range_field[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_field_default = Date_range_field;
mark_module_end(Date_range_field);

// node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-input.svelte
mark_module_start();
Date_range_field_input[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-input.svelte";
var root_266 = add_locations(template(`<div><!></div>`), Date_range_field_input[FILENAME], [[31, 1]]);
function Date_range_field_input($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Date_range_field_input);
  const $$stores = setup_stores();
  const $field = () => (validate_store(field, "field"), store_get(field, "$field", $$stores));
  const $segmentContents = () => (validate_store(segmentContents, "segmentContents"), store_get(segmentContents, "$segmentContents", $$stores));
  const builder = mutable_source();
  const segments = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { field },
    states: { segmentContents },
    ids,
    getAttrs: getAttrs2
  } = getCtx13();
  const attrs = getAttrs2("input");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.field.field.set(id());
    }
  });
  legacy_pre_effect(() => $field(), () => {
    set(builder, $field());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(() => $segmentContents(), () => {
    set(segments, {
      start: $segmentContents().start,
      end: $segmentContents().end
    });
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get segments() {
            return get2(segments);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_266();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get segments() {
            return get2(segments);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_field_input);
  const filename = Date_range_field_input.filename;
  const $$original = Date_range_field_input;
  Date_range_field_input = hmr(s);
  Date_range_field_input.filename = filename;
  Date_range_field_input[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_field_input_default = Date_range_field_input;
mark_module_end(Date_range_field_input);

// node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-label.svelte
mark_module_start();
Date_range_field_label[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-label.svelte";
var root_267 = add_locations(template(`<span><!></span>`), Date_range_field_label[FILENAME], [[24, 1]]);
function Date_range_field_label($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Date_range_field_label);
  const $$stores = setup_stores();
  const $label = () => (validate_store(label, "label"), store_get(label, "$label", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { label }, ids, getAttrs: getAttrs2 } = getCtx13();
  if (id()) {
    ids.field.label.set(id());
  }
  const attrs = getAttrs2("label");
  legacy_pre_effect(() => $label(), () => {
    set(builder, $label());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_267();
      bind_this(span, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(span);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(span);
      template_effect(() => attributes = set_attributes(span, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(span, ($$node) => get2(builder).action($$node));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_field_label);
  const filename = Date_range_field_label.filename;
  const $$original = Date_range_field_label;
  Date_range_field_label = hmr(s);
  Date_range_field_label.filename = filename;
  Date_range_field_label[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_field_label_default = Date_range_field_label;
mark_module_end(Date_range_field_label);

// node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-segment.svelte
mark_module_start();
Date_range_field_segment[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-segment.svelte";
var root_268 = add_locations(template(`<div><!></div>`), Date_range_field_segment[FILENAME], [[33, 1]]);
function Date_range_field_segment($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "part", "type", "el"]);
  push($$props, false, Date_range_field_segment);
  const $$stores = setup_stores();
  const $startSegment = () => (validate_store(startSegment, "startSegment"), store_get(startSegment, "$startSegment", $$stores));
  const $endSegment = () => (validate_store(endSegment, "endSegment"), store_get(endSegment, "$endSegment", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let part = prop($$props, "part");
  let type = prop($$props, "type");
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { startSegment, endSegment },
    ids,
    getAttrs: getAttrs2
  } = getCtx13();
  const attrs = getAttrs2("segment");
  const dispatch = createDispatcher();
  legacy_pre_effect(
    () => (deep_read_state(id()), deep_read_state(part()), deep_read_state(type())),
    () => {
      if (id() && part() !== "literal") {
        if (type() === "start") {
          ids.start[part()].set(id());
        } else {
          ids.end[part()].set(id());
        }
      }
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(type()), $startSegment(), deep_read_state(part()), $endSegment()),
    () => {
      set(builder, type() === "start" ? $startSegment()(part()) : $endSegment()(part()));
    }
  );
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_268();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      event("m-click", div, dispatch, false);
      event("m-focusout", div, dispatch, false);
      event("m-keydown", div, dispatch, false);
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_field_segment);
  const filename = Date_range_field_segment.filename;
  const $$original = Date_range_field_segment;
  Date_range_field_segment = hmr(s);
  Date_range_field_segment.filename = filename;
  Date_range_field_segment[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_field_segment_default = Date_range_field_segment;
mark_module_end(Date_range_field_segment);

// node_modules/bits-ui/dist/bits/date-range-picker/index.js
var date_range_picker_exports = {};
__export(date_range_picker_exports, {
  Arrow: () => date_range_picker_arrow_default,
  Calendar: () => date_range_picker_calendar_default,
  Cell: () => date_range_picker_cell_default,
  Close: () => date_range_picker_close_default,
  Content: () => date_range_picker_content_default,
  Day: () => date_range_picker_day_default,
  Field: () => date_range_picker_field_default,
  Grid: () => date_range_picker_grid_default,
  GridBody: () => date_range_picker_grid_body_default,
  GridHead: () => date_range_picker_grid_head_default,
  GridRow: () => date_range_picker_grid_row_default,
  HeadCell: () => date_range_picker_head_cell_default,
  Header: () => date_range_picker_header_default,
  Heading: () => date_range_picker_heading_default,
  Input: () => date_range_picker_input_default,
  Label: () => date_range_picker_label_default,
  NextButton: () => date_range_picker_next_button_default,
  PrevButton: () => date_range_picker_prev_button_default,
  Root: () => date_range_picker_default,
  Segment: () => date_range_picker_segment_default,
  Trigger: () => date_range_picker_trigger_default
});

// node_modules/bits-ui/dist/bits/date-range-picker/ctx.js
function getDateRangePickerData() {
  const NAME = "date-range-picker";
  return {
    NAME
  };
}
function setCtx15(props) {
  const { NAME } = getDateRangePickerData();
  const { NAME: CALENDAR_NAME, PARTS: CALENDAR_PARTS } = getCalendarData();
  const getCalendarAttrs = createBitAttrs(CALENDAR_NAME, CALENDAR_PARTS);
  const { NAME: FIELD_NAME, PARTS: FIELD_PARTS } = getDateFieldData();
  const getFieldAttrs = createBitAttrs(FIELD_NAME, FIELD_PARTS);
  const { NAME: POPOVER_NAME, PARTS: POPOVER_PARTS } = getPopoverData();
  const getPopoverAttrs = createBitAttrs(POPOVER_NAME, POPOVER_PARTS);
  const dateRangePicker = {
    ...createDateRangePicker({ ...removeUndefined2(props), forceVisible: true }),
    getCalendarAttrs,
    getFieldAttrs,
    getPopoverAttrs
  };
  const updateOption = getOptionUpdater(dateRangePicker.options);
  setContext(NAME, { ...dateRangePicker, updateOption });
  return {
    ...dateRangePicker,
    updateOption
  };
}
function getCtx14() {
  const { NAME } = getDateRangePickerData();
  return getContext(NAME);
}
function updatePositioning7(props) {
  const defaultPlacement = {
    side: "bottom",
    align: "center"
  };
  const withDefaults = { ...defaultPlacement, ...props };
  const { options: { positioning } } = getCtx14();
  const updater = getPositioningUpdater(positioning);
  updater(withDefaults);
}

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-arrow.svelte
mark_module_start();
Date_range_picker_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-arrow.svelte";
var root_269 = add_locations(template(`<div></div>`), Date_range_picker_arrow[FILENAME], [[23, 1]]);
function Date_range_picker_arrow($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el", "size"]);
  push($$props, false, Date_range_picker_arrow);
  const $$stores = setup_stores();
  const $arrow = () => (validate_store(arrow2, "arrow"), store_get(arrow2, "$arrow", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  let size2 = prop($$props, "size", 0, 8);
  const {
    elements: { arrow: arrow2 },
    updateOption,
    getPopoverAttrs
  } = getCtx14();
  const attrs = getPopoverAttrs("arrow");
  legacy_pre_effect(() => deep_read_state(size2()), () => {
    updateOption("arrowSize", size2());
  });
  legacy_pre_effect(() => $arrow(), () => {
    set(builder, $arrow());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_269();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_arrow);
  const filename = Date_range_picker_arrow.filename;
  const $$original = Date_range_picker_arrow;
  Date_range_picker_arrow = hmr(s);
  Date_range_picker_arrow.filename = filename;
  Date_range_picker_arrow[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_arrow_default = Date_range_picker_arrow;
mark_module_end(Date_range_picker_arrow);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-cell.svelte
mark_module_start();
Date_range_picker_cell[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-cell.svelte";
var root_270 = add_locations(template(`<td><!></td>`), Date_range_picker_cell[FILENAME], [[21, 1]]);
function Date_range_picker_cell($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["date", "asChild", "el"]);
  push($$props, false, Date_range_picker_cell);
  const $$stores = setup_stores();
  const $isDateDisabled = () => (validate_store(isDateDisabled, "isDateDisabled"), store_get(isDateDisabled, "$isDateDisabled", $$stores));
  const $isDateUnavailable = () => (validate_store(isDateUnavailable, "isDateUnavailable"), store_get(isDateUnavailable, "$isDateUnavailable", $$stores));
  const attrs = mutable_source();
  let date = prop($$props, "date");
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    helpers: { isDateDisabled, isDateUnavailable },
    getCalendarAttrs
  } = getCtx14();
  legacy_pre_effect(
    () => ($isDateDisabled(), deep_read_state(date()), $isDateUnavailable()),
    () => {
      set(attrs, {
        ...getCalendarAttrs("cell"),
        "aria-disabled": $isDateDisabled()(date()) || $isDateUnavailable()(date()),
        "data-disabled": $isDateDisabled()(date()) ? "" : void 0,
        role: "gridcell"
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get attrs() {
            return get2(attrs);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var td = root_270();
      bind_this(td, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(td);
      slot(
        node_2,
        default_slot($$props),
        {
          get attrs() {
            return get2(attrs);
          }
        },
        null
      );
      reset(td);
      template_effect(() => attributes = set_attributes(td, attributes, { ...$$restProps, ...get2(attrs) }, true, ""));
      append($$anchor2, td);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_cell);
  const filename = Date_range_picker_cell.filename;
  const $$original = Date_range_picker_cell;
  Date_range_picker_cell = hmr(s);
  Date_range_picker_cell.filename = filename;
  Date_range_picker_cell[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_cell_default = Date_range_picker_cell;
mark_module_end(Date_range_picker_cell);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-day.svelte
mark_module_start();
Date_range_picker_day[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-day.svelte";
var root_271 = add_locations(template(`<div><!></div>`), Date_range_picker_day[FILENAME], [[26, 1]]);
function Date_range_picker_day($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["date", "month", "asChild", "el"]);
  push($$props, false, Date_range_picker_day);
  const $$stores = setup_stores();
  const $cell = () => (validate_store(cell, "cell"), store_get(cell, "$cell", $$stores));
  const $isDateDisabled = () => (validate_store(isDateDisabled, "isDateDisabled"), store_get(isDateDisabled, "$isDateDisabled", $$stores));
  const $isDateUnavailable = () => (validate_store(isDateUnavailable, "isDateUnavailable"), store_get(isDateUnavailable, "$isDateUnavailable", $$stores));
  const builder = mutable_source();
  const disabled = mutable_source();
  const unavailable = mutable_source();
  let date = prop($$props, "date");
  let month = prop($$props, "month");
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { cell },
    helpers: { isDateDisabled, isDateUnavailable },
    getCalendarAttrs
  } = getCtx14();
  const attrs = getCalendarAttrs("day");
  legacy_pre_effect(
    () => ($cell(), deep_read_state(date()), deep_read_state(month())),
    () => {
      set(builder, $cell()(date(), month()));
    }
  );
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(
    () => ($isDateDisabled(), deep_read_state(date())),
    () => {
      set(disabled, $isDateDisabled()(date()));
    }
  );
  legacy_pre_effect(
    () => ($isDateUnavailable(), deep_read_state(date())),
    () => {
      set(unavailable, $isDateUnavailable()(date()));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get disabled() {
            return get2(disabled);
          },
          get unavailable() {
            return get2(unavailable);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_271();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get disabled() {
            return get2(disabled);
          },
          get unavailable() {
            return get2(unavailable);
          }
        },
        ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, date().day));
          append($$anchor3, text2);
        }
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_day);
  const filename = Date_range_picker_day.filename;
  const $$original = Date_range_picker_day;
  Date_range_picker_day = hmr(s);
  Date_range_picker_day.filename = filename;
  Date_range_picker_day[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_day_default = Date_range_picker_day;
mark_module_end(Date_range_picker_day);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-heading.svelte
mark_module_start();
Date_range_picker_heading[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-heading.svelte";
var root_272 = add_locations(template(`<div><!></div>`), Date_range_picker_heading[FILENAME], [[20, 1]]);
function Date_range_picker_heading($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_range_picker_heading);
  const $$stores = setup_stores();
  const $heading = () => (validate_store(heading, "heading"), store_get(heading, "$heading", $$stores));
  const $headingValue = () => (validate_store(headingValue, "headingValue"), store_get(headingValue, "$headingValue", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { heading },
    states: { headingValue },
    getCalendarAttrs
  } = getCtx14();
  const attrs = getCalendarAttrs("heading");
  legacy_pre_effect(() => $heading(), () => {
    set(builder, $heading());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get headingValue() {
            return $headingValue();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_272();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get headingValue() {
            return $headingValue();
          }
        },
        ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, $headingValue()));
          append($$anchor3, text2);
        }
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_heading);
  const filename = Date_range_picker_heading.filename;
  const $$original = Date_range_picker_heading;
  Date_range_picker_heading = hmr(s);
  Date_range_picker_heading.filename = filename;
  Date_range_picker_heading[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_heading_default = Date_range_picker_heading;
mark_module_end(Date_range_picker_heading);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-next-button.svelte
mark_module_start();
Date_range_picker_next_button[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-next-button.svelte";
var root_273 = add_locations(template(`<button><!></button>`), Date_range_picker_next_button[FILENAME], [[19, 1]]);
function Date_range_picker_next_button($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_range_picker_next_button);
  const $$stores = setup_stores();
  const $nextButton = () => (validate_store(nextButton, "nextButton"), store_get(nextButton, "$nextButton", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { nextButton }, getCalendarAttrs } = getCtx14();
  const attrs = getCalendarAttrs("next-button");
  legacy_pre_effect(() => $nextButton(), () => {
    set(builder, $nextButton());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_273();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_next_button);
  const filename = Date_range_picker_next_button.filename;
  const $$original = Date_range_picker_next_button;
  Date_range_picker_next_button = hmr(s);
  Date_range_picker_next_button.filename = filename;
  Date_range_picker_next_button[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_next_button_default = Date_range_picker_next_button;
mark_module_end(Date_range_picker_next_button);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-prev-button.svelte
mark_module_start();
Date_range_picker_prev_button[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-prev-button.svelte";
var root_274 = add_locations(template(`<button><!></button>`), Date_range_picker_prev_button[FILENAME], [[19, 1]]);
function Date_range_picker_prev_button($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_range_picker_prev_button);
  const $$stores = setup_stores();
  const $prevButton = () => (validate_store(prevButton, "prevButton"), store_get(prevButton, "$prevButton", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { prevButton }, getCalendarAttrs } = getCtx14();
  const attrs = getCalendarAttrs("prev-button");
  legacy_pre_effect(() => $prevButton(), () => {
    set(builder, $prevButton());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_274();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_prev_button);
  const filename = Date_range_picker_prev_button.filename;
  const $$original = Date_range_picker_prev_button;
  Date_range_picker_prev_button = hmr(s);
  Date_range_picker_prev_button.filename = filename;
  Date_range_picker_prev_button[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_prev_button_default = Date_range_picker_prev_button;
mark_module_end(Date_range_picker_prev_button);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-calendar.svelte
mark_module_start();
Date_range_picker_calendar[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-calendar.svelte";
var root_275 = add_locations(template(`<div><!></div>`), Date_range_picker_calendar[FILENAME], [[29, 1]]);
function Date_range_picker_calendar($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Date_range_picker_calendar);
  const $$stores = setup_stores();
  const $calendar = () => (validate_store(calendar, "calendar"), store_get(calendar, "$calendar", $$stores));
  const $localMonths = () => (validate_store(localMonths, "localMonths"), store_get(localMonths, "$localMonths", $$stores));
  const $weekdays = () => (validate_store(weekdays, "weekdays"), store_get(weekdays, "$weekdays", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { calendar },
    states: { months: localMonths, weekdays },
    ids,
    getCalendarAttrs
  } = getCtx14();
  const attrs = getCalendarAttrs("root");
  let months = mutable_source($localMonths());
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.calendar.calendar.set(id());
    }
  });
  legacy_pre_effect(() => $calendar(), () => {
    set(builder, $calendar());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(() => $localMonths(), () => {
    set(months, $localMonths());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get months() {
            return get2(months);
          },
          get weekdays() {
            return $weekdays();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_275();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get months() {
            return get2(months);
          },
          get weekdays() {
            return $weekdays();
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_calendar);
  const filename = Date_range_picker_calendar.filename;
  const $$original = Date_range_picker_calendar;
  Date_range_picker_calendar = hmr(s);
  Date_range_picker_calendar.filename = filename;
  Date_range_picker_calendar[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_calendar_default = Date_range_picker_calendar;
mark_module_end(Date_range_picker_calendar);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-close.svelte
mark_module_start();
Date_range_picker_close[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-close.svelte";
var root_276 = add_locations(template(`<button><!></button>`), Date_range_picker_close[FILENAME], [[21, 1]]);
function Date_range_picker_close($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_range_picker_close);
  const $$stores = setup_stores();
  const $close = () => (validate_store(close, "close"), store_get(close, "$close", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { close }, getPopoverAttrs } = getCtx14();
  const dispatch = createDispatcher();
  const attrs = getPopoverAttrs("close");
  legacy_pre_effect(() => $close(), () => {
    set(builder, $close());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_276();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_close);
  const filename = Date_range_picker_close.filename;
  const $$original = Date_range_picker_close;
  Date_range_picker_close = hmr(s);
  Date_range_picker_close.filename = filename;
  Date_range_picker_close[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_close_default = Date_range_picker_close;
mark_module_end(Date_range_picker_close);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-content.svelte
mark_module_start();
Date_range_picker_content[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-content.svelte";
var root_313 = add_locations(template(`<div><!></div>`), Date_range_picker_content[FILENAME], [[57, 1]]);
var root_59 = add_locations(template(`<div><!></div>`), Date_range_picker_content[FILENAME], [[66, 1]]);
var root_79 = add_locations(template(`<div><!></div>`), Date_range_picker_content[FILENAME], [[76, 1]]);
var root_99 = add_locations(template(`<div><!></div>`), Date_range_picker_content[FILENAME], [[80, 1]]);
var root_119 = add_locations(template(`<div><!></div>`), Date_range_picker_content[FILENAME], [[84, 1]]);
function Date_range_picker_content($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "side",
    "align",
    "sideOffset",
    "alignOffset",
    "collisionPadding",
    "avoidCollisions",
    "collisionBoundary",
    "sameWidth",
    "fitViewport",
    "strategy",
    "overlap",
    "el"
  ]);
  push($$props, false, Date_range_picker_content);
  const $$stores = setup_stores();
  const $content = () => (validate_store(content, "content"), store_get(content, "$content", $$stores));
  const $open = () => (validate_store(open, "open"), store_get(open, "$open", $$stores));
  const builder = mutable_source();
  let transition2 = prop($$props, "transition", 8, () => void 0);
  let transitionConfig = prop($$props, "transitionConfig", 8, () => void 0);
  let inTransition = prop($$props, "inTransition", 8, () => void 0);
  let inTransitionConfig = prop($$props, "inTransitionConfig", 8, () => void 0);
  let outTransition = prop($$props, "outTransition", 8, () => void 0);
  let outTransitionConfig = prop($$props, "outTransitionConfig", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let side = prop($$props, "side", 0, "bottom");
  let align = prop($$props, "align", 0, "center");
  let sideOffset = prop($$props, "sideOffset", 0, 0);
  let alignOffset = prop($$props, "alignOffset", 0, 0);
  let collisionPadding = prop($$props, "collisionPadding", 0, 8);
  let avoidCollisions = prop($$props, "avoidCollisions", 0, true);
  let collisionBoundary = prop($$props, "collisionBoundary", 8, () => void 0);
  let sameWidth = prop($$props, "sameWidth", 0, false);
  let fitViewport = prop($$props, "fitViewport", 0, false);
  let strategy = prop($$props, "strategy", 0, "absolute");
  let overlap = prop($$props, "overlap", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { content },
    states: { open },
    ids,
    getPopoverAttrs
  } = getCtx14();
  const attrs = getPopoverAttrs("content");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.popover.content.set(id());
    }
  });
  legacy_pre_effect(() => $content(), () => {
    set(builder, $content());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(
    () => (deep_read_state(side()), deep_read_state(align()), deep_read_state(sideOffset()), deep_read_state(alignOffset()), deep_read_state(collisionPadding()), deep_read_state(avoidCollisions()), deep_read_state(collisionBoundary()), deep_read_state(sameWidth()), deep_read_state(fitViewport()), deep_read_state(strategy()), deep_read_state(overlap())),
    () => {
      updatePositioning7({
        side: side(),
        align: align(),
        sideOffset: sideOffset(),
        alignOffset: alignOffset(),
        collisionPadding: collisionPadding(),
        avoidCollisions: avoidCollisions(),
        collisionBoundary: collisionBoundary(),
        sameWidth: sameWidth(),
        fitViewport: fitViewport(),
        strategy: strategy(),
        overlap: overlap()
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => asChild() && $open(),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      if_block(
        node_2,
        () => transition2() && $open(),
        ($$anchor3) => {
          var div = root_313();
          bind_this(div, ($$value) => el($$value), () => el());
          transition(3, div, transition2, transitionConfig);
          let attributes;
          var node_3 = child(div);
          slot(
            node_3,
            default_slot($$props),
            {
              get builder() {
                return get2(builder);
              }
            },
            null
          );
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
          action(div, ($$node) => get2(builder).action($$node));
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          if_block(
            node_4,
            () => inTransition() && outTransition() && $open(),
            ($$anchor4) => {
              var div_1 = root_59();
              bind_this(div_1, ($$value) => el($$value), () => el());
              transition(1, div_1, inTransition, inTransitionConfig);
              transition(2, div_1, outTransition, outTransitionConfig);
              let attributes_1;
              var node_5 = child(div_1);
              slot(
                node_5,
                default_slot($$props),
                {
                  get builder() {
                    return get2(builder);
                  }
                },
                null
              );
              reset(div_1);
              template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get2(builder), ...$$restProps }, true, ""));
              action(div_1, ($$node) => get2(builder).action($$node));
              append($$anchor4, div_1);
            },
            ($$anchor4) => {
              var fragment_4 = comment();
              var node_6 = first_child(fragment_4);
              if_block(
                node_6,
                () => inTransition() && $open(),
                ($$anchor5) => {
                  var div_2 = root_79();
                  bind_this(div_2, ($$value) => el($$value), () => el());
                  transition(1, div_2, inTransition, inTransitionConfig);
                  let attributes_2;
                  var node_7 = child(div_2);
                  slot(
                    node_7,
                    default_slot($$props),
                    {
                      get builder() {
                        return get2(builder);
                      }
                    },
                    null
                  );
                  reset(div_2);
                  template_effect(() => attributes_2 = set_attributes(div_2, attributes_2, { ...get2(builder), ...$$restProps }, true, ""));
                  action(div_2, ($$node) => get2(builder).action($$node));
                  append($$anchor5, div_2);
                },
                ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_8 = first_child(fragment_5);
                  if_block(
                    node_8,
                    () => outTransition() && $open(),
                    ($$anchor6) => {
                      var div_3 = root_99();
                      bind_this(div_3, ($$value) => el($$value), () => el());
                      transition(2, div_3, outTransition, outTransitionConfig);
                      let attributes_3;
                      var node_9 = child(div_3);
                      slot(
                        node_9,
                        default_slot($$props),
                        {
                          get builder() {
                            return get2(builder);
                          }
                        },
                        null
                      );
                      reset(div_3);
                      template_effect(() => attributes_3 = set_attributes(div_3, attributes_3, { ...get2(builder), ...$$restProps }, true, ""));
                      action(div_3, ($$node) => get2(builder).action($$node));
                      append($$anchor6, div_3);
                    },
                    ($$anchor6) => {
                      var fragment_6 = comment();
                      var node_10 = first_child(fragment_6);
                      if_block(
                        node_10,
                        $open,
                        ($$anchor7) => {
                          var div_4 = root_119();
                          bind_this(div_4, ($$value) => el($$value), () => el());
                          let attributes_4;
                          var node_11 = child(div_4);
                          slot(
                            node_11,
                            default_slot($$props),
                            {
                              get builder() {
                                return get2(builder);
                              }
                            },
                            null
                          );
                          reset(div_4);
                          template_effect(() => attributes_4 = set_attributes(div_4, attributes_4, { ...get2(builder), ...$$restProps }, true, ""));
                          action(div_4, ($$node) => get2(builder).action($$node));
                          append($$anchor7, div_4);
                        },
                        null,
                        true
                      );
                      append($$anchor6, fragment_6);
                    },
                    true
                  );
                  append($$anchor5, fragment_5);
                },
                true
              );
              append($$anchor4, fragment_4);
            },
            true
          );
          append($$anchor3, fragment_3);
        },
        true
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_content);
  const filename = Date_range_picker_content.filename;
  const $$original = Date_range_picker_content;
  Date_range_picker_content = hmr(s);
  Date_range_picker_content.filename = filename;
  Date_range_picker_content[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_content_default = Date_range_picker_content;
mark_module_end(Date_range_picker_content);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-field.svelte
mark_module_start();
Date_range_picker_field[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-field.svelte";
function Date_range_picker_field($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Date_range_picker_field);
  const $$stores = setup_stores();
  const $localIsInvalid = () => (validate_store(localIsInvalid, "localIsInvalid"), store_get(localIsInvalid, "$localIsInvalid", $$stores));
  let value = prop($$props, "value", 12, () => void 0);
  let onValueChange = prop($$props, "onValueChange", 8, () => void 0);
  let placeholder = prop($$props, "placeholder", 12, () => void 0);
  let onPlaceholderChange = prop($$props, "onPlaceholderChange", 8, () => void 0);
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let isDateUnavailable = prop($$props, "isDateUnavailable", 8, () => void 0);
  let granularity = prop($$props, "granularity", 8, () => void 0);
  let hideTimeZone = prop($$props, "hideTimeZone", 8, () => void 0);
  let hourCycle = prop($$props, "hourCycle", 8, () => void 0);
  let locale = prop($$props, "locale", 8, () => void 0);
  let maxValue = prop($$props, "maxValue", 8, () => void 0);
  let minValue = prop($$props, "minValue", 8, () => void 0);
  let readonly2 = prop($$props, "readonly", 8, () => void 0);
  const {
    states: {
      value: localValue,
      placeholder: localPlaceholder,
      isInvalid: localIsInvalid
    },
    updateOption
  } = setCtx15({
    defaultValue: value(),
    defaultPlaceholder: placeholder(),
    disabled: disabled(),
    granularity: granularity(),
    hideTimeZone: hideTimeZone(),
    hourCycle: hourCycle(),
    locale: locale(),
    maxValue: maxValue(),
    minValue: minValue(),
    readonly: readonly2(),
    isDateUnavailable: isDateUnavailable(),
    onValueChange: ({ next: next2 }) => {
      var _a;
      if (value() !== next2) {
        (_a = onValueChange()) == null ? void 0 : _a(next2);
        value(next2);
      }
      return next2;
    },
    onPlaceholderChange: ({ next: next2 }) => {
      var _a;
      if (placeholder() !== next2) {
        (_a = onPlaceholderChange()) == null ? void 0 : _a(next2);
        placeholder(next2);
      }
      return next2;
    }
  });
  legacy_pre_effect(() => deep_read_state(value()), () => {
    value() !== void 0 && localValue.set(value());
  });
  legacy_pre_effect(() => deep_read_state(placeholder()), () => {
    placeholder() !== void 0 && localPlaceholder.set(placeholder());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => deep_read_state(isDateUnavailable()), () => {
    updateOption("isDateUnavailable", isDateUnavailable());
  });
  legacy_pre_effect(() => deep_read_state(granularity()), () => {
    updateOption("granularity", granularity());
  });
  legacy_pre_effect(() => deep_read_state(hideTimeZone()), () => {
    updateOption("hideTimeZone", hideTimeZone());
  });
  legacy_pre_effect(() => deep_read_state(hourCycle()), () => {
    updateOption("hourCycle", hourCycle());
  });
  legacy_pre_effect(() => deep_read_state(locale()), () => {
    updateOption("locale", locale());
  });
  legacy_pre_effect(() => deep_read_state(maxValue()), () => {
    updateOption("maxValue", maxValue());
  });
  legacy_pre_effect(() => deep_read_state(minValue()), () => {
    updateOption("minValue", minValue());
  });
  legacy_pre_effect(() => deep_read_state(readonly2()), () => {
    updateOption("readonly", readonly2());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get isInvalid() {
        return $localIsInvalid();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_field);
  const filename = Date_range_picker_field.filename;
  const $$original = Date_range_picker_field;
  Date_range_picker_field = hmr(s);
  Date_range_picker_field.filename = filename;
  Date_range_picker_field[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_field_default = Date_range_picker_field;
mark_module_end(Date_range_picker_field);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-input.svelte
mark_module_start();
Date_range_picker_input[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-input.svelte";
var root_277 = add_locations(template(`<div><!></div>`), Date_range_picker_input[FILENAME], [[26, 1]]);
function Date_range_picker_input($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Date_range_picker_input);
  const $$stores = setup_stores();
  const $field = () => (validate_store(field, "field"), store_get(field, "$field", $$stores));
  const $segmentContents = () => (validate_store(segmentContents, "segmentContents"), store_get(segmentContents, "$segmentContents", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { field },
    states: { segmentContents },
    ids,
    getFieldAttrs
  } = getCtx14();
  const attrs = getFieldAttrs("input");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.rangeField.field.field.set(id());
    }
  });
  legacy_pre_effect(() => $field(), () => {
    set(builder, $field());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get segments() {
            return $segmentContents();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_277();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get segments() {
            return $segmentContents();
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_input);
  const filename = Date_range_picker_input.filename;
  const $$original = Date_range_picker_input;
  Date_range_picker_input = hmr(s);
  Date_range_picker_input.filename = filename;
  Date_range_picker_input[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_input_default = Date_range_picker_input;
mark_module_end(Date_range_picker_input);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-label.svelte
mark_module_start();
Date_range_picker_label[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-label.svelte";
var root_278 = add_locations(template(`<span><!></span>`), Date_range_picker_label[FILENAME], [[24, 1]]);
function Date_range_picker_label($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Date_range_picker_label);
  const $$stores = setup_stores();
  const $label = () => (validate_store(label, "label"), store_get(label, "$label", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { label }, ids, getFieldAttrs } = getCtx14();
  if (id()) {
    ids.rangeField.field.label.set(id());
  }
  const attrs = getFieldAttrs("label");
  legacy_pre_effect(() => $label(), () => {
    set(builder, $label());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_278();
      bind_this(span, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(span);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(span);
      template_effect(() => attributes = set_attributes(span, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(span, ($$node) => get2(builder).action($$node));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_label);
  const filename = Date_range_picker_label.filename;
  const $$original = Date_range_picker_label;
  Date_range_picker_label = hmr(s);
  Date_range_picker_label.filename = filename;
  Date_range_picker_label[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_label_default = Date_range_picker_label;
mark_module_end(Date_range_picker_label);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-segment.svelte
mark_module_start();
Date_range_picker_segment[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-segment.svelte";
var root_279 = add_locations(template(`<div><!></div>`), Date_range_picker_segment[FILENAME], [[31, 1]]);
function Date_range_picker_segment($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "part", "type", "el"]);
  push($$props, false, Date_range_picker_segment);
  const $$stores = setup_stores();
  const $startSegment = () => (validate_store(startSegment, "startSegment"), store_get(startSegment, "$startSegment", $$stores));
  const $endSegment = () => (validate_store(endSegment, "endSegment"), store_get(endSegment, "$endSegment", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let part = prop($$props, "part");
  let type = prop($$props, "type");
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { startSegment, endSegment },
    ids,
    getFieldAttrs
  } = getCtx14();
  const attrs = getFieldAttrs("segment");
  legacy_pre_effect(
    () => (deep_read_state(id()), deep_read_state(part()), deep_read_state(type())),
    () => {
      if (id() && part() !== "literal") {
        if (type() === "start") {
          ids.rangeField.start[part()].set(id());
        } else {
          ids.rangeField.end[part()].set(id());
        }
      }
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(type()), $startSegment(), deep_read_state(part()), $endSegment()),
    () => {
      set(builder, type() === "start" ? $startSegment()(part()) : $endSegment()(part()));
    }
  );
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_279();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_segment);
  const filename = Date_range_picker_segment.filename;
  const $$original = Date_range_picker_segment;
  Date_range_picker_segment = hmr(s);
  Date_range_picker_segment.filename = filename;
  Date_range_picker_segment[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_segment_default = Date_range_picker_segment;
mark_module_end(Date_range_picker_segment);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-trigger.svelte
mark_module_start();
Date_range_picker_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-trigger.svelte";
var root_280 = add_locations(template(`<button><!></button>`), Date_range_picker_trigger[FILENAME], [[27, 1]]);
function Date_range_picker_trigger($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Date_range_picker_trigger);
  const $$stores = setup_stores();
  const $trigger = () => (validate_store(trigger, "trigger"), store_get(trigger, "$trigger", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { trigger },
    ids,
    getPopoverAttrs
  } = getCtx14();
  const dispatch = createDispatcher();
  const attrs = getPopoverAttrs("trigger");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.popover.trigger.set(id());
    }
  });
  legacy_pre_effect(() => $trigger(), () => {
    set(builder, $trigger());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_280();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_trigger);
  const filename = Date_range_picker_trigger.filename;
  const $$original = Date_range_picker_trigger;
  Date_range_picker_trigger = hmr(s);
  Date_range_picker_trigger.filename = filename;
  Date_range_picker_trigger[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_trigger_default = Date_range_picker_trigger;
mark_module_end(Date_range_picker_trigger);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker.svelte
mark_module_start();
Date_range_picker[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker.svelte";
function Date_range_picker($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Date_range_picker);
  const $$stores = setup_stores();
  const $localStartValue = () => (validate_store(localStartValue, "localStartValue"), store_get(localStartValue, "$localStartValue", $$stores));
  const $localValue = () => (validate_store(localValue, "localValue"), store_get(localValue, "$localValue", $$stores));
  const $localEndValue = () => (validate_store(localEndValue, "localEndValue"), store_get(localEndValue, "$localEndValue", $$stores));
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  const $localIsInvalid = () => (validate_store(localIsInvalid, "localIsInvalid"), store_get(localIsInvalid, "$localIsInvalid", $$stores));
  let value = prop($$props, "value", 12, () => void 0);
  let onValueChange = prop($$props, "onValueChange", 8, () => void 0);
  let placeholder = prop($$props, "placeholder", 12, () => void 0);
  let onPlaceholderChange = prop($$props, "onPlaceholderChange", 8, () => void 0);
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let isDateUnavailable = prop($$props, "isDateUnavailable", 8, () => void 0);
  let granularity = prop($$props, "granularity", 8, () => void 0);
  let hideTimeZone = prop($$props, "hideTimeZone", 8, () => void 0);
  let hourCycle = prop($$props, "hourCycle", 8, () => void 0);
  let locale = prop($$props, "locale", 8, () => void 0);
  let maxValue = prop($$props, "maxValue", 8, () => void 0);
  let minValue = prop($$props, "minValue", 8, () => void 0);
  let readonly2 = prop($$props, "readonly", 8, () => void 0);
  let validationId = prop($$props, "validationId", 8, () => void 0);
  let descriptionId = prop($$props, "descriptionId", 8, () => void 0);
  let preventDeselect = prop($$props, "preventDeselect", 8, () => void 0);
  let pagedNavigation = prop($$props, "pagedNavigation", 8, () => void 0);
  let weekStartsOn = prop($$props, "weekStartsOn", 8, () => void 0);
  let isDateDisabled = prop($$props, "isDateDisabled", 8, () => void 0);
  let fixedWeeks = prop($$props, "fixedWeeks", 8, () => void 0);
  let calendarLabel = prop($$props, "calendarLabel", 8, () => void 0);
  let weekdayFormat = prop($$props, "weekdayFormat", 8, () => void 0);
  let startValue = prop($$props, "startValue", 12, () => void 0);
  let numberOfMonths = prop($$props, "numberOfMonths", 8, () => void 0);
  let onOutsideClick = prop($$props, "onOutsideClick", 8, () => void 0);
  const {
    states: {
      value: localValue,
      placeholder: localPlaceholder,
      isInvalid: localIsInvalid,
      startValue: localStartValue,
      endValue: localEndValue
    },
    updateOption,
    ids
  } = setCtx15({
    defaultValue: value(),
    defaultPlaceholder: placeholder(),
    preventDeselect: preventDeselect(),
    pagedNavigation: pagedNavigation(),
    weekStartsOn: weekStartsOn(),
    isDateDisabled: isDateDisabled(),
    fixedWeeks: fixedWeeks(),
    calendarLabel: calendarLabel(),
    disabled: disabled(),
    granularity: granularity(),
    hideTimeZone: hideTimeZone(),
    hourCycle: hourCycle(),
    locale: locale(),
    maxValue: maxValue(),
    minValue: minValue(),
    readonly: readonly2(),
    weekdayFormat: weekdayFormat(),
    numberOfMonths: numberOfMonths(),
    isDateUnavailable: isDateUnavailable(),
    onOutsideClick: onOutsideClick(),
    onValueChange: ({ next: next2 }) => {
      var _a;
      if (value() !== next2) {
        (_a = onValueChange()) == null ? void 0 : _a(next2);
        value(next2);
      }
      return next2;
    },
    onPlaceholderChange: ({ next: next2 }) => {
      var _a;
      if (placeholder() !== next2) {
        (_a = onPlaceholderChange()) == null ? void 0 : _a(next2);
        placeholder(next2);
      }
      return next2;
    }
  });
  const startFieldIds = derived(
    [
      ids.rangeField.start.day,
      ids.rangeField.start.dayPeriod,
      ids.rangeField.start.field,
      ids.rangeField.start.hour,
      ids.rangeField.start.minute,
      ids.rangeField.start.month,
      ids.rangeField.start.second,
      ids.rangeField.start.year,
      ids.rangeField.start.timeZoneName
    ],
    ([
      $dayId,
      $dayPeriodId,
      $hourId,
      $minuteId,
      $monthId,
      $secondId,
      $yearId,
      $timeZoneNameId
    ]) => ({
      day: $dayId,
      dayPeriod: $dayPeriodId,
      hour: $hourId,
      minute: $minuteId,
      month: $monthId,
      second: $secondId,
      year: $yearId,
      timeZoneName: $timeZoneNameId
    })
  );
  const endFieldIds = derived(
    [
      ids.rangeField.end.day,
      ids.rangeField.end.dayPeriod,
      ids.rangeField.end.field,
      ids.rangeField.end.hour,
      ids.rangeField.end.minute,
      ids.rangeField.end.month,
      ids.rangeField.end.second,
      ids.rangeField.end.year,
      ids.rangeField.end.timeZoneName
    ],
    ([
      $dayId,
      $dayPeriodId,
      $hourId,
      $minuteId,
      $monthId,
      $secondId,
      $yearId,
      $timeZoneNameId
    ]) => ({
      day: $dayId,
      dayPeriod: $dayPeriodId,
      hour: $hourId,
      minute: $minuteId,
      month: $monthId,
      second: $secondId,
      year: $yearId,
      timeZoneName: $timeZoneNameId
    })
  );
  const idValues = derived(
    [
      ids.rangeField.field.field,
      ids.rangeField.field.description,
      ids.rangeField.field.label,
      ids.rangeField.field.validation,
      ids.calendar.calendar,
      ids.popover.content,
      ids.popover.trigger,
      startFieldIds,
      endFieldIds
    ],
    ([
      $fieldId,
      $descriptionId,
      $labelId,
      $validationId,
      $calendarId,
      $contentId,
      $triggerId,
      $startFieldIds,
      $endFieldIds
    ]) => ({
      field: $fieldId,
      description: $descriptionId,
      label: $labelId,
      validation: $validationId,
      calendar: $calendarId,
      content: $contentId,
      trigger: $triggerId,
      startField: $startFieldIds,
      endField: $endFieldIds
    })
  );
  legacy_pre_effect(() => deep_read_state(validationId()), () => {
    if (validationId()) {
      ids.rangeField.field.validation.set(validationId());
    }
  });
  legacy_pre_effect(() => deep_read_state(descriptionId()), () => {
    if (descriptionId()) {
      ids.rangeField.field.description.set(descriptionId());
    }
  });
  legacy_pre_effect(() => $localStartValue(), () => {
    startValue($localStartValue());
  });
  legacy_pre_effect(
    () => (deep_read_state(value()), $localValue(), $localStartValue(), $localEndValue()),
    () => {
      var _a, _b;
      if (value() !== $localValue()) {
        const nextValue = {
          start: (_a = value()) == null ? void 0 : _a.start,
          end: (_b = value()) == null ? void 0 : _b.end
        };
        if (nextValue.start !== $localStartValue()) localStartValue.set(nextValue.start);
        if (nextValue.end !== $localEndValue()) localEndValue.set(nextValue.end);
        localValue.set(nextValue);
      }
    }
  );
  legacy_pre_effect(() => deep_read_state(placeholder()), () => {
    placeholder() !== void 0 && localPlaceholder.set(placeholder());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => deep_read_state(isDateUnavailable()), () => {
    updateOption("isDateUnavailable", isDateUnavailable());
  });
  legacy_pre_effect(() => deep_read_state(granularity()), () => {
    updateOption("granularity", granularity());
  });
  legacy_pre_effect(() => deep_read_state(hideTimeZone()), () => {
    updateOption("hideTimeZone", hideTimeZone());
  });
  legacy_pre_effect(() => deep_read_state(hourCycle()), () => {
    updateOption("hourCycle", hourCycle());
  });
  legacy_pre_effect(() => deep_read_state(locale()), () => {
    updateOption("locale", locale());
  });
  legacy_pre_effect(() => deep_read_state(maxValue()), () => {
    updateOption("maxValue", maxValue());
  });
  legacy_pre_effect(() => deep_read_state(minValue()), () => {
    updateOption("minValue", minValue());
  });
  legacy_pre_effect(() => deep_read_state(readonly2()), () => {
    updateOption("readonly", readonly2());
  });
  legacy_pre_effect(() => deep_read_state(fixedWeeks()), () => {
    updateOption("fixedWeeks", fixedWeeks());
  });
  legacy_pre_effect(() => deep_read_state(preventDeselect()), () => {
    updateOption("preventDeselect", preventDeselect());
  });
  legacy_pre_effect(() => deep_read_state(pagedNavigation()), () => {
    updateOption("pagedNavigation", pagedNavigation());
  });
  legacy_pre_effect(() => deep_read_state(weekStartsOn()), () => {
    updateOption("weekStartsOn", weekStartsOn());
  });
  legacy_pre_effect(() => deep_read_state(isDateDisabled()), () => {
    updateOption("isDateDisabled", isDateDisabled());
  });
  legacy_pre_effect(() => deep_read_state(calendarLabel()), () => {
    updateOption("calendarLabel", calendarLabel());
  });
  legacy_pre_effect(() => deep_read_state(weekdayFormat()), () => {
    updateOption("weekdayFormat", weekdayFormat());
  });
  legacy_pre_effect(() => deep_read_state(numberOfMonths()), () => {
    updateOption("numberOfMonths", numberOfMonths());
  });
  legacy_pre_effect(() => deep_read_state(onOutsideClick()), () => {
    updateOption("onOutsideClick", onOutsideClick());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get ids() {
        return $idValues();
      },
      get isInvalid() {
        return $localIsInvalid();
      },
      get startValue() {
        return $localStartValue();
      },
      get endValue() {
        return $localEndValue();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker);
  const filename = Date_range_picker.filename;
  const $$original = Date_range_picker;
  Date_range_picker = hmr(s);
  Date_range_picker.filename = filename;
  Date_range_picker[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_default = Date_range_picker;
mark_module_end(Date_range_picker);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-grid.svelte
mark_module_start();
Date_range_picker_grid[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-grid.svelte";
var root_281 = add_locations(template(`<table><!></table>`), Date_range_picker_grid[FILENAME], [[19, 1]]);
function Date_range_picker_grid($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_range_picker_grid);
  const $$stores = setup_stores();
  const $grid = () => (validate_store(grid, "grid"), store_get(grid, "$grid", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { grid }, getCalendarAttrs } = getCtx14();
  const attrs = getCalendarAttrs("grid");
  legacy_pre_effect(() => $grid(), () => {
    set(builder, $grid());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var table = root_281();
      bind_this(table, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(table);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(table);
      template_effect(() => attributes = set_attributes(table, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(table, ($$node) => get2(builder).action($$node));
      append($$anchor2, table);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_grid);
  const filename = Date_range_picker_grid.filename;
  const $$original = Date_range_picker_grid;
  Date_range_picker_grid = hmr(s);
  Date_range_picker_grid.filename = filename;
  Date_range_picker_grid[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_grid_default = Date_range_picker_grid;
mark_module_end(Date_range_picker_grid);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-grid-body.svelte
mark_module_start();
Date_range_picker_grid_body[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-grid-body.svelte";
var root_282 = add_locations(template(`<tbody><!></tbody>`), Date_range_picker_grid_body[FILENAME], [[11, 1]]);
function Date_range_picker_grid_body($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_range_picker_grid_body);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getCalendarAttrs } = getCtx14();
  const attrs = getCalendarAttrs("grid-body");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var tbody = root_282();
      bind_this(tbody, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(tbody);
      slot(node_2, default_slot($$props), {}, null);
      reset(tbody);
      template_effect(() => attributes = set_attributes(tbody, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, tbody);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_grid_body);
  const filename = Date_range_picker_grid_body.filename;
  const $$original = Date_range_picker_grid_body;
  Date_range_picker_grid_body = hmr(s);
  Date_range_picker_grid_body.filename = filename;
  Date_range_picker_grid_body[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_grid_body_default = Date_range_picker_grid_body;
mark_module_end(Date_range_picker_grid_body);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-grid-head.svelte
mark_module_start();
Date_range_picker_grid_head[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-grid-head.svelte";
var root_283 = add_locations(template(`<thead><!></thead>`), Date_range_picker_grid_head[FILENAME], [[11, 1]]);
function Date_range_picker_grid_head($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_range_picker_grid_head);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getCalendarAttrs } = getCtx14();
  const attrs = {
    ...getCalendarAttrs("grid-head"),
    "aria-hidden": true
  };
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var thead = root_283();
      bind_this(thead, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(thead);
      slot(node_2, default_slot($$props), {}, null);
      reset(thead);
      template_effect(() => attributes = set_attributes(thead, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, thead);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_grid_head);
  const filename = Date_range_picker_grid_head.filename;
  const $$original = Date_range_picker_grid_head;
  Date_range_picker_grid_head = hmr(s);
  Date_range_picker_grid_head.filename = filename;
  Date_range_picker_grid_head[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_grid_head_default = Date_range_picker_grid_head;
mark_module_end(Date_range_picker_grid_head);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-grid-row.svelte
mark_module_start();
Date_range_picker_grid_row[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-grid-row.svelte";
var root_284 = add_locations(template(`<tr><!></tr>`), Date_range_picker_grid_row[FILENAME], [[11, 1]]);
function Date_range_picker_grid_row($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_range_picker_grid_row);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getCalendarAttrs } = getCtx14();
  const attrs = getCalendarAttrs("grid-row");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var tr = root_284();
      bind_this(tr, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(tr);
      slot(node_2, default_slot($$props), { attrs }, null);
      reset(tr);
      template_effect(() => attributes = set_attributes(tr, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, tr);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_grid_row);
  const filename = Date_range_picker_grid_row.filename;
  const $$original = Date_range_picker_grid_row;
  Date_range_picker_grid_row = hmr(s);
  Date_range_picker_grid_row.filename = filename;
  Date_range_picker_grid_row[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_grid_row_default = Date_range_picker_grid_row;
mark_module_end(Date_range_picker_grid_row);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-head-cell.svelte
mark_module_start();
Date_range_picker_head_cell[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-head-cell.svelte";
var root_285 = add_locations(template(`<th><!></th>`), Date_range_picker_head_cell[FILENAME], [[11, 1]]);
function Date_range_picker_head_cell($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_range_picker_head_cell);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getCalendarAttrs } = getCtx14();
  const attrs = getCalendarAttrs("head-cell");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var th = root_285();
      bind_this(th, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(th);
      slot(node_2, default_slot($$props), {}, null);
      reset(th);
      template_effect(() => attributes = set_attributes(th, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, th);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_head_cell);
  const filename = Date_range_picker_head_cell.filename;
  const $$original = Date_range_picker_head_cell;
  Date_range_picker_head_cell = hmr(s);
  Date_range_picker_head_cell.filename = filename;
  Date_range_picker_head_cell[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_head_cell_default = Date_range_picker_head_cell;
mark_module_end(Date_range_picker_head_cell);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-header.svelte
mark_module_start();
Date_range_picker_header[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-header.svelte";
var root_286 = add_locations(template(`<header><!></header>`), Date_range_picker_header[FILENAME], [[11, 1]]);
function Date_range_picker_header($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Date_range_picker_header);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getCalendarAttrs } = getCtx14();
  const attrs = getCalendarAttrs("header");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var header = root_286();
      bind_this(header, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(header);
      slot(node_2, default_slot($$props), { attrs }, null);
      reset(header);
      template_effect(() => attributes = set_attributes(header, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, header);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Date_range_picker_header);
  const filename = Date_range_picker_header.filename;
  const $$original = Date_range_picker_header;
  Date_range_picker_header = hmr(s);
  Date_range_picker_header.filename = filename;
  Date_range_picker_header[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var date_range_picker_header_default = Date_range_picker_header;
mark_module_end(Date_range_picker_header);

// node_modules/bits-ui/dist/bits/dialog/index.js
var dialog_exports = {};
__export(dialog_exports, {
  Close: () => dialog_close_default,
  Content: () => dialog_content_default,
  Description: () => dialog_description_default,
  Overlay: () => dialog_overlay_default,
  Portal: () => dialog_portal_default,
  Root: () => dialog_default,
  Title: () => dialog_title_default,
  Trigger: () => dialog_trigger_default
});

// node_modules/bits-ui/dist/bits/dialog/ctx.js
function getDialogData() {
  const NAME = "dialog";
  const PARTS = [
    "close",
    "content",
    "description",
    "overlay",
    "portal",
    "title",
    "trigger"
  ];
  return {
    NAME,
    PARTS
  };
}
function setCtx16(props) {
  const { NAME, PARTS } = getDialogData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const dialog = {
    ...createDialog({ ...removeUndefined2(props), role: "dialog", forceVisible: true }),
    getAttrs: getAttrs2
  };
  setContext(NAME, dialog);
  return {
    ...dialog,
    updateOption: getOptionUpdater(dialog.options)
  };
}
function getCtx15() {
  const { NAME } = getDialogData();
  return getContext(NAME);
}

// node_modules/bits-ui/dist/bits/dialog/components/dialog.svelte
mark_module_start();
Dialog[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog.svelte";
function Dialog($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Dialog);
  const $$stores = setup_stores();
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  let preventScroll = prop($$props, "preventScroll", 8, () => void 0);
  let closeOnEscape = prop($$props, "closeOnEscape", 8, () => void 0);
  let closeOnOutsideClick = prop($$props, "closeOnOutsideClick", 8, () => void 0);
  let portal = prop($$props, "portal", 8, () => void 0);
  let open = prop($$props, "open", 12, () => void 0);
  let onOpenChange = prop($$props, "onOpenChange", 8, () => void 0);
  let openFocus = prop($$props, "openFocus", 8, () => void 0);
  let closeFocus = prop($$props, "closeFocus", 8, () => void 0);
  let onOutsideClick = prop($$props, "onOutsideClick", 8, () => void 0);
  const {
    states: { open: localOpen },
    updateOption,
    ids
  } = setCtx16({
    closeOnEscape: closeOnEscape(),
    preventScroll: preventScroll(),
    closeOnOutsideClick: closeOnOutsideClick(),
    portal: portal(),
    forceVisible: true,
    defaultOpen: open(),
    openFocus: openFocus(),
    closeFocus: closeFocus(),
    onOutsideClick: onOutsideClick(),
    onOpenChange: ({ next: next2 }) => {
      var _a;
      if (open() !== next2) {
        (_a = onOpenChange()) == null ? void 0 : _a(next2);
        open(next2);
      }
      return next2;
    }
  });
  const idValues = derived([ids.content, ids.description, ids.title], ([$contentId, $descriptionId, $titleId]) => ({
    content: $contentId,
    description: $descriptionId,
    title: $titleId
  }));
  legacy_pre_effect(() => deep_read_state(open()), () => {
    open() !== void 0 && localOpen.set(open());
  });
  legacy_pre_effect(() => deep_read_state(preventScroll()), () => {
    updateOption("preventScroll", preventScroll());
  });
  legacy_pre_effect(() => deep_read_state(closeOnEscape()), () => {
    updateOption("closeOnEscape", closeOnEscape());
  });
  legacy_pre_effect(
    () => deep_read_state(closeOnOutsideClick()),
    () => {
      updateOption("closeOnOutsideClick", closeOnOutsideClick());
    }
  );
  legacy_pre_effect(() => deep_read_state(portal()), () => {
    updateOption("portal", portal());
  });
  legacy_pre_effect(() => deep_read_state(openFocus()), () => {
    updateOption("openFocus", openFocus());
  });
  legacy_pre_effect(() => deep_read_state(closeFocus()), () => {
    updateOption("closeFocus", closeFocus());
  });
  legacy_pre_effect(() => deep_read_state(onOutsideClick()), () => {
    updateOption("onOutsideClick", onOutsideClick());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get ids() {
        return $idValues();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Dialog);
  const filename = Dialog.filename;
  const $$original = Dialog;
  Dialog = hmr(s);
  Dialog.filename = filename;
  Dialog[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var dialog_default = Dialog;
mark_module_end(Dialog);

// node_modules/bits-ui/dist/bits/dialog/components/dialog-title.svelte
mark_module_start();
Dialog_title[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-title.svelte";
function Dialog_title($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["level", "asChild", "id", "el"]);
  push($$props, false, Dialog_title);
  const $$stores = setup_stores();
  const $title = () => (validate_store(title, "title"), store_get(title, "$title", $$stores));
  const builder = mutable_source();
  let level = prop($$props, "level", 0, "h2");
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { title }, ids, getAttrs: getAttrs2 } = getCtx15();
  const attrs = getAttrs2("title");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.title.set(id());
    }
  });
  legacy_pre_effect(() => $title(), () => {
    set(builder, $title());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      validate_void_dynamic_element(level);
      validate_dynamic_element_tag(level);
      element(
        node_2,
        level,
        false,
        ($$element, $$anchor3) => {
          bind_this($$element, ($$value) => el($$value), () => el());
          let attributes;
          template_effect(() => attributes = set_dynamic_element_attributes($$element, attributes, { ...get2(builder), ...$$restProps }, ""));
          action($$element, ($$node) => get2(builder).action($$node));
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          slot(
            node_3,
            default_slot($$props),
            {
              get builder() {
                return get2(builder);
              }
            },
            null
          );
          append($$anchor3, fragment_3);
        },
        void 0,
        [26, 1]
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Dialog_title);
  const filename = Dialog_title.filename;
  const $$original = Dialog_title;
  Dialog_title = hmr(s);
  Dialog_title.filename = filename;
  Dialog_title[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var dialog_title_default = Dialog_title;
mark_module_end(Dialog_title);

// node_modules/bits-ui/dist/bits/dialog/components/dialog-close.svelte
mark_module_start();
Dialog_close[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-close.svelte";
var root_287 = add_locations(template(`<button><!></button>`), Dialog_close[FILENAME], [[21, 1]]);
function Dialog_close($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Dialog_close);
  const $$stores = setup_stores();
  const $close = () => (validate_store(close, "close"), store_get(close, "$close", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { close }, getAttrs: getAttrs2 } = getCtx15();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("close");
  legacy_pre_effect(() => $close(), () => {
    set(builder, $close());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_287();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Dialog_close);
  const filename = Dialog_close.filename;
  const $$original = Dialog_close;
  Dialog_close = hmr(s);
  Dialog_close.filename = filename;
  Dialog_close[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var dialog_close_default = Dialog_close;
mark_module_end(Dialog_close);

// node_modules/bits-ui/dist/bits/dialog/components/dialog-portal.svelte
mark_module_start();
Dialog_portal[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-portal.svelte";
var root_288 = add_locations(template(`<div><!></div>`), Dialog_portal[FILENAME], [[19, 1]]);
function Dialog_portal($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Dialog_portal);
  const $$stores = setup_stores();
  const $portalled = () => (validate_store(portalled, "portalled"), store_get(portalled, "$portalled", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { portalled }, getAttrs: getAttrs2 } = getCtx15();
  const attrs = getAttrs2("portal");
  legacy_pre_effect(() => $portalled(), () => {
    set(builder, $portalled());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_288();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Dialog_portal);
  const filename = Dialog_portal.filename;
  const $$original = Dialog_portal;
  Dialog_portal = hmr(s);
  Dialog_portal.filename = filename;
  Dialog_portal[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var dialog_portal_default = Dialog_portal;
mark_module_end(Dialog_portal);

// node_modules/bits-ui/dist/bits/dialog/components/dialog-content.svelte
mark_module_start();
Dialog_content[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-content.svelte";
var root_314 = add_locations(template(`<div><!></div>`), Dialog_content[FILENAME], [[32, 1]]);
var root_510 = add_locations(template(`<div><!></div>`), Dialog_content[FILENAME], [[48, 1]]);
var root_710 = add_locations(template(`<div><!></div>`), Dialog_content[FILENAME], [[65, 1]]);
var root_910 = add_locations(template(`<div><!></div>`), Dialog_content[FILENAME], [[81, 1]]);
var root_1110 = add_locations(template(`<div><!></div>`), Dialog_content[FILENAME], [[97, 1]]);
function Dialog_content($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "el"
  ]);
  push($$props, false, Dialog_content);
  const $$stores = setup_stores();
  const $content = () => (validate_store(content, "content"), store_get(content, "$content", $$stores));
  const $open = () => (validate_store(open, "open"), store_get(open, "$open", $$stores));
  const builder = mutable_source();
  let transition2 = prop($$props, "transition", 8, () => void 0);
  let transitionConfig = prop($$props, "transitionConfig", 8, () => void 0);
  let inTransition = prop($$props, "inTransition", 8, () => void 0);
  let inTransitionConfig = prop($$props, "inTransitionConfig", 8, () => void 0);
  let outTransition = prop($$props, "outTransition", 8, () => void 0);
  let outTransitionConfig = prop($$props, "outTransitionConfig", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { content },
    states: { open },
    ids,
    getAttrs: getAttrs2
  } = getCtx15();
  const attrs = getAttrs2("content");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.content.set(id());
    }
  });
  legacy_pre_effect(() => $content(), () => {
    set(builder, $content());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => asChild() && $open(),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      if_block(
        node_2,
        () => transition2() && $open(),
        ($$anchor3) => {
          var div = root_314();
          bind_this(div, ($$value) => el($$value), () => el());
          transition(3, div, transition2, transitionConfig);
          let attributes;
          var node_3 = child(div);
          slot(
            node_3,
            default_slot($$props),
            {
              get builder() {
                return get2(builder);
              }
            },
            null
          );
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
          action(div, ($$node) => get2(builder).action($$node));
          event("pointerdown", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("pointermove", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("pointerup", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("touchcancel", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("touchend", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("touchmove", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("touchstart", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          if_block(
            node_4,
            () => inTransition() && outTransition() && $open(),
            ($$anchor4) => {
              var div_1 = root_510();
              bind_this(div_1, ($$value) => el($$value), () => el());
              transition(1, div_1, inTransition, inTransitionConfig);
              transition(2, div_1, outTransition, outTransitionConfig);
              let attributes_1;
              var node_5 = child(div_1);
              slot(
                node_5,
                default_slot($$props),
                {
                  get builder() {
                    return get2(builder);
                  }
                },
                null
              );
              reset(div_1);
              template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get2(builder), ...$$restProps }, true, ""));
              action(div_1, ($$node) => get2(builder).action($$node));
              event("pointerdown", div_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("pointermove", div_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("pointerup", div_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("touchcancel", div_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("touchend", div_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("touchmove", div_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("touchstart", div_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              append($$anchor4, div_1);
            },
            ($$anchor4) => {
              var fragment_4 = comment();
              var node_6 = first_child(fragment_4);
              if_block(
                node_6,
                () => inTransition() && $open(),
                ($$anchor5) => {
                  var div_2 = root_710();
                  bind_this(div_2, ($$value) => el($$value), () => el());
                  transition(1, div_2, inTransition, inTransitionConfig);
                  let attributes_2;
                  var node_7 = child(div_2);
                  slot(
                    node_7,
                    default_slot($$props),
                    {
                      get builder() {
                        return get2(builder);
                      }
                    },
                    null
                  );
                  reset(div_2);
                  template_effect(() => attributes_2 = set_attributes(div_2, attributes_2, { ...get2(builder), ...$$restProps }, true, ""));
                  action(div_2, ($$node) => get2(builder).action($$node));
                  event("pointerdown", div_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("pointermove", div_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("pointerup", div_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("touchcancel", div_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("touchend", div_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("touchmove", div_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("touchstart", div_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  append($$anchor5, div_2);
                },
                ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_8 = first_child(fragment_5);
                  if_block(
                    node_8,
                    () => outTransition() && $open(),
                    ($$anchor6) => {
                      var div_3 = root_910();
                      bind_this(div_3, ($$value) => el($$value), () => el());
                      transition(2, div_3, outTransition, outTransitionConfig);
                      let attributes_3;
                      var node_9 = child(div_3);
                      slot(
                        node_9,
                        default_slot($$props),
                        {
                          get builder() {
                            return get2(builder);
                          }
                        },
                        null
                      );
                      reset(div_3);
                      template_effect(() => attributes_3 = set_attributes(div_3, attributes_3, { ...get2(builder), ...$$restProps }, true, ""));
                      action(div_3, ($$node) => get2(builder).action($$node));
                      event("pointerdown", div_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("pointermove", div_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("pointerup", div_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("touchcancel", div_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("touchend", div_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("touchmove", div_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("touchstart", div_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      append($$anchor6, div_3);
                    },
                    ($$anchor6) => {
                      var fragment_6 = comment();
                      var node_10 = first_child(fragment_6);
                      if_block(
                        node_10,
                        $open,
                        ($$anchor7) => {
                          var div_4 = root_1110();
                          bind_this(div_4, ($$value) => el($$value), () => el());
                          let attributes_4;
                          var node_11 = child(div_4);
                          slot(
                            node_11,
                            default_slot($$props),
                            {
                              get builder() {
                                return get2(builder);
                              }
                            },
                            null
                          );
                          reset(div_4);
                          template_effect(() => attributes_4 = set_attributes(div_4, attributes_4, { ...get2(builder), ...$$restProps }, true, ""));
                          action(div_4, ($$node) => get2(builder).action($$node));
                          event("pointerdown", div_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("pointermove", div_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("pointerup", div_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("touchcancel", div_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("touchend", div_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("touchmove", div_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("touchstart", div_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          append($$anchor7, div_4);
                        },
                        null,
                        true
                      );
                      append($$anchor6, fragment_6);
                    },
                    true
                  );
                  append($$anchor5, fragment_5);
                },
                true
              );
              append($$anchor4, fragment_4);
            },
            true
          );
          append($$anchor3, fragment_3);
        },
        true
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Dialog_content);
  const filename = Dialog_content.filename;
  const $$original = Dialog_content;
  Dialog_content = hmr(s);
  Dialog_content.filename = filename;
  Dialog_content[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var dialog_content_default = Dialog_content;
mark_module_end(Dialog_content);

// node_modules/bits-ui/dist/bits/dialog/components/dialog-overlay.svelte
mark_module_start();
Dialog_overlay[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-overlay.svelte";
var root_315 = add_locations(template(`<div></div>`), Dialog_overlay[FILENAME], [[27, 1]]);
var root_511 = add_locations(template(`<div></div>`), Dialog_overlay[FILENAME], [[36, 1]]);
var root_711 = add_locations(template(`<div></div>`), Dialog_overlay[FILENAME], [[46, 1]]);
var root_911 = add_locations(template(`<div></div>`), Dialog_overlay[FILENAME], [[55, 1]]);
var root_1111 = add_locations(template(`<div></div>`), Dialog_overlay[FILENAME], [[64, 1]]);
function Dialog_overlay($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "el"
  ]);
  push($$props, false, Dialog_overlay);
  const $$stores = setup_stores();
  const $overlay = () => (validate_store(overlay, "overlay"), store_get(overlay, "$overlay", $$stores));
  const $open = () => (validate_store(open, "open"), store_get(open, "$open", $$stores));
  const builder = mutable_source();
  let transition2 = prop($$props, "transition", 8, () => void 0);
  let transitionConfig = prop($$props, "transitionConfig", 8, () => void 0);
  let inTransition = prop($$props, "inTransition", 8, () => void 0);
  let inTransitionConfig = prop($$props, "inTransitionConfig", 8, () => void 0);
  let outTransition = prop($$props, "outTransition", 8, () => void 0);
  let outTransitionConfig = prop($$props, "outTransitionConfig", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { overlay },
    states: { open },
    getAttrs: getAttrs2
  } = getCtx15();
  const attrs = getAttrs2("overlay");
  legacy_pre_effect(() => $overlay(), () => {
    set(builder, $overlay());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => asChild() && $open(),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      if_block(
        node_2,
        () => transition2() && $open(),
        ($$anchor3) => {
          var div = root_315();
          bind_this(div, ($$value) => el($$value), () => el());
          transition(3, div, transition2, transitionConfig);
          let attributes;
          template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
          event("mouseup", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          action(div, ($$node) => get2(builder).action($$node));
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          if_block(
            node_3,
            () => inTransition() && outTransition() && $open(),
            ($$anchor4) => {
              var div_1 = root_511();
              bind_this(div_1, ($$value) => el($$value), () => el());
              transition(1, div_1, inTransition, inTransitionConfig);
              transition(2, div_1, outTransition, outTransitionConfig);
              let attributes_1;
              template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get2(builder), ...$$restProps }, true, ""));
              action(div_1, ($$node) => get2(builder).action($$node));
              event("mouseup", div_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              append($$anchor4, div_1);
            },
            ($$anchor4) => {
              var fragment_4 = comment();
              var node_4 = first_child(fragment_4);
              if_block(
                node_4,
                () => inTransition() && $open(),
                ($$anchor5) => {
                  var div_2 = root_711();
                  bind_this(div_2, ($$value) => el($$value), () => el());
                  transition(1, div_2, inTransition, inTransitionConfig);
                  let attributes_2;
                  template_effect(() => attributes_2 = set_attributes(div_2, attributes_2, { ...get2(builder), ...$$restProps }, true, ""));
                  action(div_2, ($$node) => get2(builder).action($$node));
                  event("mouseup", div_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  append($$anchor5, div_2);
                },
                ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_5 = first_child(fragment_5);
                  if_block(
                    node_5,
                    () => outTransition() && $open(),
                    ($$anchor6) => {
                      var div_3 = root_911();
                      bind_this(div_3, ($$value) => el($$value), () => el());
                      transition(2, div_3, outTransition, outTransitionConfig);
                      let attributes_3;
                      template_effect(() => attributes_3 = set_attributes(div_3, attributes_3, { ...get2(builder), ...$$restProps }, true, ""));
                      action(div_3, ($$node) => get2(builder).action($$node));
                      event("mouseup", div_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      append($$anchor6, div_3);
                    },
                    ($$anchor6) => {
                      var fragment_6 = comment();
                      var node_6 = first_child(fragment_6);
                      if_block(
                        node_6,
                        $open,
                        ($$anchor7) => {
                          var div_4 = root_1111();
                          bind_this(div_4, ($$value) => el($$value), () => el());
                          let attributes_4;
                          template_effect(() => attributes_4 = set_attributes(div_4, attributes_4, { ...get2(builder), ...$$restProps }, true, ""));
                          action(div_4, ($$node) => get2(builder).action($$node));
                          event("mouseup", div_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          append($$anchor7, div_4);
                        },
                        null,
                        true
                      );
                      append($$anchor6, fragment_6);
                    },
                    true
                  );
                  append($$anchor5, fragment_5);
                },
                true
              );
              append($$anchor4, fragment_4);
            },
            true
          );
          append($$anchor3, fragment_3);
        },
        true
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Dialog_overlay);
  const filename = Dialog_overlay.filename;
  const $$original = Dialog_overlay;
  Dialog_overlay = hmr(s);
  Dialog_overlay.filename = filename;
  Dialog_overlay[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var dialog_overlay_default = Dialog_overlay;
mark_module_end(Dialog_overlay);

// node_modules/bits-ui/dist/bits/dialog/components/dialog-trigger.svelte
mark_module_start();
Dialog_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-trigger.svelte";
var root_289 = add_locations(template(`<button><!></button>`), Dialog_trigger[FILENAME], [[21, 1]]);
function Dialog_trigger($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Dialog_trigger);
  const $$stores = setup_stores();
  const $trigger = () => (validate_store(trigger, "trigger"), store_get(trigger, "$trigger", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { trigger }, getAttrs: getAttrs2 } = getCtx15();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("trigger");
  legacy_pre_effect(() => $trigger(), () => {
    set(builder, $trigger());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_289();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Dialog_trigger);
  const filename = Dialog_trigger.filename;
  const $$original = Dialog_trigger;
  Dialog_trigger = hmr(s);
  Dialog_trigger.filename = filename;
  Dialog_trigger[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var dialog_trigger_default = Dialog_trigger;
mark_module_end(Dialog_trigger);

// node_modules/bits-ui/dist/bits/dialog/components/dialog-description.svelte
mark_module_start();
Dialog_description[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-description.svelte";
var root_290 = add_locations(template(`<div><!></div>`), Dialog_description[FILENAME], [[25, 1]]);
function Dialog_description($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Dialog_description);
  const $$stores = setup_stores();
  const $description = () => (validate_store(description, "description"), store_get(description, "$description", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { description }, ids, getAttrs: getAttrs2 } = getCtx15();
  const attrs = getAttrs2("description");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.description.set(id());
    }
  });
  legacy_pre_effect(() => $description(), () => {
    set(builder, $description());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_290();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Dialog_description);
  const filename = Dialog_description.filename;
  const $$original = Dialog_description;
  Dialog_description = hmr(s);
  Dialog_description.filename = filename;
  Dialog_description[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var dialog_description_default = Dialog_description;
mark_module_end(Dialog_description);

// node_modules/bits-ui/dist/bits/dropdown-menu/index.js
var dropdown_menu_exports = {};
__export(dropdown_menu_exports, {
  Arrow: () => menu_arrow_default,
  CheckboxIndicator: () => menu_checkbox_indicator_default,
  CheckboxItem: () => menu_checkbox_item_default,
  Content: () => menu_content_default,
  Group: () => menu_group_default,
  Item: () => menu_item_default,
  Label: () => menu_label_default,
  RadioGroup: () => menu_radio_group_default,
  RadioIndicator: () => menu_radio_indicator_default,
  RadioItem: () => menu_radio_item_default,
  Root: () => menu_default,
  Separator: () => menu_separator_default,
  Sub: () => menu_sub_default,
  SubContent: () => menu_sub_content_default,
  SubTrigger: () => menu_sub_trigger_default,
  Trigger: () => menu_trigger_default
});

// node_modules/bits-ui/dist/bits/menu/components/menu.svelte
mark_module_start();
Menu[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu.svelte";
function Menu($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Menu);
  const $$stores = setup_stores();
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  let closeOnOutsideClick = prop($$props, "closeOnOutsideClick", 8, () => void 0);
  let closeOnEscape = prop($$props, "closeOnEscape", 8, () => void 0);
  let portal = prop($$props, "portal", 8, () => void 0);
  let open = prop($$props, "open", 12, () => void 0);
  let onOpenChange = prop($$props, "onOpenChange", 8, () => void 0);
  let preventScroll = prop($$props, "preventScroll", 8, () => void 0);
  let loop = prop($$props, "loop", 8, () => void 0);
  let dir = prop($$props, "dir", 8, () => void 0);
  let typeahead = prop($$props, "typeahead", 8, () => void 0);
  let closeFocus = prop($$props, "closeFocus", 8, () => void 0);
  let disableFocusFirstItem = prop($$props, "disableFocusFirstItem", 8, () => void 0);
  let closeOnItemClick = prop($$props, "closeOnItemClick", 8, () => void 0);
  let onOutsideClick = prop($$props, "onOutsideClick", 8, () => void 0);
  const {
    states: { open: localOpen },
    updateOption,
    ids
  } = setCtx10({
    closeOnOutsideClick: closeOnOutsideClick(),
    closeOnEscape: closeOnEscape(),
    portal: portal(),
    forceVisible: true,
    defaultOpen: open(),
    preventScroll: preventScroll(),
    loop: loop(),
    dir: dir(),
    typeahead: typeahead(),
    closeFocus: closeFocus(),
    disableFocusFirstItem: disableFocusFirstItem(),
    closeOnItemClick: closeOnItemClick(),
    onOutsideClick: onOutsideClick(),
    onOpenChange: ({ next: next2 }) => {
      var _a;
      if (open() !== next2) {
        (_a = onOpenChange()) == null ? void 0 : _a(next2);
        open(next2);
      }
      return next2;
    }
  });
  const idValues = derived([ids.menu, ids.trigger], ([$menuId, $triggerId]) => ({ menu: $menuId, trigger: $triggerId }));
  legacy_pre_effect(() => deep_read_state(open()), () => {
    open() !== void 0 && localOpen.set(open());
  });
  legacy_pre_effect(
    () => deep_read_state(closeOnOutsideClick()),
    () => {
      updateOption("closeOnOutsideClick", closeOnOutsideClick());
    }
  );
  legacy_pre_effect(() => deep_read_state(closeOnEscape()), () => {
    updateOption("closeOnEscape", closeOnEscape());
  });
  legacy_pre_effect(() => deep_read_state(portal()), () => {
    updateOption("portal", portal());
  });
  legacy_pre_effect(() => deep_read_state(preventScroll()), () => {
    updateOption("preventScroll", preventScroll());
  });
  legacy_pre_effect(() => deep_read_state(loop()), () => {
    updateOption("loop", loop());
  });
  legacy_pre_effect(() => deep_read_state(dir()), () => {
    updateOption("dir", dir());
  });
  legacy_pre_effect(() => deep_read_state(closeFocus()), () => {
    updateOption("closeFocus", closeFocus());
  });
  legacy_pre_effect(
    () => deep_read_state(disableFocusFirstItem()),
    () => {
      updateOption("disableFocusFirstItem", disableFocusFirstItem());
    }
  );
  legacy_pre_effect(() => deep_read_state(typeahead()), () => {
    updateOption("typeahead", typeahead());
  });
  legacy_pre_effect(() => deep_read_state(closeOnItemClick()), () => {
    updateOption("closeOnItemClick", closeOnItemClick());
  });
  legacy_pre_effect(() => deep_read_state(onOutsideClick()), () => {
    updateOption("onOutsideClick", onOutsideClick());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get ids() {
        return $idValues();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menu);
  const filename = Menu.filename;
  const $$original = Menu;
  Menu = hmr(s);
  Menu.filename = filename;
  Menu[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menu_default = Menu;
mark_module_end(Menu);

// node_modules/bits-ui/dist/bits/menu/components/menu-content.svelte
mark_module_start();
Menu_content[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-content.svelte";
var root_316 = add_locations(template(`<div><!></div>`), Menu_content[FILENAME], [[61, 1]]);
var root_512 = add_locations(template(`<div><!></div>`), Menu_content[FILENAME], [[71, 1]]);
var root_712 = add_locations(template(`<div><!></div>`), Menu_content[FILENAME], [[82, 1]]);
var root_912 = add_locations(template(`<div><!></div>`), Menu_content[FILENAME], [[92, 1]]);
var root_1112 = add_locations(template(`<div><!></div>`), Menu_content[FILENAME], [[102, 1]]);
function Menu_content($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "side",
    "align",
    "sideOffset",
    "alignOffset",
    "collisionPadding",
    "avoidCollisions",
    "collisionBoundary",
    "sameWidth",
    "fitViewport",
    "strategy",
    "overlap",
    "el"
  ]);
  push($$props, false, Menu_content);
  const $$stores = setup_stores();
  const $menu = () => (validate_store(menu, "menu"), store_get(menu, "$menu", $$stores));
  const $open = () => (validate_store(open, "open"), store_get(open, "$open", $$stores));
  const builder = mutable_source();
  let transition2 = prop($$props, "transition", 8, () => void 0);
  let transitionConfig = prop($$props, "transitionConfig", 8, () => void 0);
  let inTransition = prop($$props, "inTransition", 8, () => void 0);
  let inTransitionConfig = prop($$props, "inTransitionConfig", 8, () => void 0);
  let outTransition = prop($$props, "outTransition", 8, () => void 0);
  let outTransitionConfig = prop($$props, "outTransitionConfig", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let side = prop($$props, "side", 0, "bottom");
  let align = prop($$props, "align", 0, "center");
  let sideOffset = prop($$props, "sideOffset", 0, 0);
  let alignOffset = prop($$props, "alignOffset", 0, 0);
  let collisionPadding = prop($$props, "collisionPadding", 0, 8);
  let avoidCollisions = prop($$props, "avoidCollisions", 0, true);
  let collisionBoundary = prop($$props, "collisionBoundary", 8, () => void 0);
  let sameWidth = prop($$props, "sameWidth", 0, false);
  let fitViewport = prop($$props, "fitViewport", 0, false);
  let strategy = prop($$props, "strategy", 0, "absolute");
  let overlap = prop($$props, "overlap", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { menu },
    states: { open },
    ids,
    getAttrs: getAttrs2
  } = getCtx9();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("content");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.menu.set(id());
    }
  });
  legacy_pre_effect(() => $menu(), () => {
    set(builder, $menu());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(
    () => ($open(), deep_read_state(side()), deep_read_state(align()), deep_read_state(sideOffset()), deep_read_state(alignOffset()), deep_read_state(collisionPadding()), deep_read_state(avoidCollisions()), deep_read_state(collisionBoundary()), deep_read_state(sameWidth()), deep_read_state(fitViewport()), deep_read_state(strategy()), deep_read_state(overlap())),
    () => {
      if ($open()) {
        updatePositioning4({
          side: side(),
          align: align(),
          sideOffset: sideOffset(),
          alignOffset: alignOffset(),
          collisionPadding: collisionPadding(),
          avoidCollisions: avoidCollisions(),
          collisionBoundary: collisionBoundary(),
          sameWidth: sameWidth(),
          fitViewport: fitViewport(),
          strategy: strategy(),
          overlap: overlap()
        });
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => asChild() && $open(),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      if_block(
        node_2,
        () => transition2() && $open(),
        ($$anchor3) => {
          var div = root_316();
          bind_this(div, ($$value) => el($$value), () => el());
          transition(3, div, transition2, transitionConfig);
          let attributes;
          var node_3 = child(div);
          slot(
            node_3,
            default_slot($$props),
            {
              get builder() {
                return get2(builder);
              }
            },
            null
          );
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
          action(div, ($$node) => get2(builder).action($$node));
          event("m-keydown", div, dispatch, false);
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          if_block(
            node_4,
            () => inTransition() && outTransition() && $open(),
            ($$anchor4) => {
              var div_1 = root_512();
              bind_this(div_1, ($$value) => el($$value), () => el());
              transition(1, div_1, inTransition, inTransitionConfig);
              transition(2, div_1, outTransition, outTransitionConfig);
              let attributes_1;
              var node_5 = child(div_1);
              slot(
                node_5,
                default_slot($$props),
                {
                  get builder() {
                    return get2(builder);
                  }
                },
                null
              );
              reset(div_1);
              template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get2(builder), ...$$restProps }, true, ""));
              action(div_1, ($$node) => get2(builder).action($$node));
              event("m-keydown", div_1, dispatch, false);
              append($$anchor4, div_1);
            },
            ($$anchor4) => {
              var fragment_4 = comment();
              var node_6 = first_child(fragment_4);
              if_block(
                node_6,
                () => inTransition() && $open(),
                ($$anchor5) => {
                  var div_2 = root_712();
                  bind_this(div_2, ($$value) => el($$value), () => el());
                  transition(1, div_2, inTransition, inTransitionConfig);
                  let attributes_2;
                  var node_7 = child(div_2);
                  slot(
                    node_7,
                    default_slot($$props),
                    {
                      get builder() {
                        return get2(builder);
                      }
                    },
                    null
                  );
                  reset(div_2);
                  template_effect(() => attributes_2 = set_attributes(div_2, attributes_2, { ...get2(builder), ...$$restProps }, true, ""));
                  action(div_2, ($$node) => get2(builder).action($$node));
                  event("m-keydown", div_2, dispatch, false);
                  append($$anchor5, div_2);
                },
                ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_8 = first_child(fragment_5);
                  if_block(
                    node_8,
                    () => outTransition() && $open(),
                    ($$anchor6) => {
                      var div_3 = root_912();
                      bind_this(div_3, ($$value) => el($$value), () => el());
                      transition(2, div_3, outTransition, outTransitionConfig);
                      let attributes_3;
                      var node_9 = child(div_3);
                      slot(
                        node_9,
                        default_slot($$props),
                        {
                          get builder() {
                            return get2(builder);
                          }
                        },
                        null
                      );
                      reset(div_3);
                      template_effect(() => attributes_3 = set_attributes(div_3, attributes_3, { ...get2(builder), ...$$restProps }, true, ""));
                      action(div_3, ($$node) => get2(builder).action($$node));
                      event("m-keydown", div_3, dispatch, false);
                      append($$anchor6, div_3);
                    },
                    ($$anchor6) => {
                      var fragment_6 = comment();
                      var node_10 = first_child(fragment_6);
                      if_block(
                        node_10,
                        $open,
                        ($$anchor7) => {
                          var div_4 = root_1112();
                          bind_this(div_4, ($$value) => el($$value), () => el());
                          let attributes_4;
                          var node_11 = child(div_4);
                          slot(
                            node_11,
                            default_slot($$props),
                            {
                              get builder() {
                                return get2(builder);
                              }
                            },
                            null
                          );
                          reset(div_4);
                          template_effect(() => attributes_4 = set_attributes(div_4, attributes_4, { ...get2(builder), ...$$restProps }, true, ""));
                          action(div_4, ($$node) => get2(builder).action($$node));
                          event("m-keydown", div_4, dispatch, false);
                          append($$anchor7, div_4);
                        },
                        null,
                        true
                      );
                      append($$anchor6, fragment_6);
                    },
                    true
                  );
                  append($$anchor5, fragment_5);
                },
                true
              );
              append($$anchor4, fragment_4);
            },
            true
          );
          append($$anchor3, fragment_3);
        },
        true
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menu_content);
  const filename = Menu_content.filename;
  const $$original = Menu_content;
  Menu_content = hmr(s);
  Menu_content.filename = filename;
  Menu_content[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menu_content_default = Menu_content;
mark_module_end(Menu_content);

// node_modules/bits-ui/dist/bits/menu/components/menu-trigger.svelte
mark_module_start();
Menu_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-trigger.svelte";
var root_291 = add_locations(template(`<button><!></button>`), Menu_trigger[FILENAME], [[27, 1]]);
function Menu_trigger($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Menu_trigger);
  const $$stores = setup_stores();
  const $trigger = () => (validate_store(trigger, "trigger"), store_get(trigger, "$trigger", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { trigger }, ids, getAttrs: getAttrs2 } = getCtx9();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("trigger");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.trigger.set(id());
    }
  });
  legacy_pre_effect(() => $trigger(), () => {
    set(builder, $trigger());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_291();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-keydown", button, dispatch, false);
      event("m-pointerdown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menu_trigger);
  const filename = Menu_trigger.filename;
  const $$original = Menu_trigger;
  Menu_trigger = hmr(s);
  Menu_trigger.filename = filename;
  Menu_trigger[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menu_trigger_default = Menu_trigger;
mark_module_end(Menu_trigger);

// node_modules/bits-ui/dist/bits/label/index.js
var label_exports = {};
__export(label_exports, {
  Root: () => label_default
});

// node_modules/bits-ui/dist/bits/label/ctx.js
function getLabelData() {
  const NAME = "label";
  const PARTS = ["root"];
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  return {
    NAME,
    getAttrs: getAttrs2
  };
}

// node_modules/bits-ui/dist/bits/label/components/label.svelte
mark_module_start();
Label[FILENAME] = "node_modules/bits-ui/dist/bits/label/components/label.svelte";
var root_317 = add_locations(template(`<label><!></label>`), Label[FILENAME], [[21, 1]]);
function Label($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Label);
  const $$stores = setup_stores();
  const $root = () => (validate_store(root5, "root"), store_get(root5, "$root", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { root: root5 } } = createLabel();
  const dispatch = createDispatcher();
  const { getAttrs: getAttrs2 } = getLabelData();
  const attrs = getAttrs2("root");
  legacy_pre_effect(() => $root(), () => {
    set(builder, $root());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var label = root_317();
      bind_this(label, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(label);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(label);
      template_effect(() => attributes = set_attributes(label, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(label, ($$node) => get2(builder).action($$node));
      event("m-mousedown", label, dispatch, false);
      append($$anchor2, label);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Label);
  const filename = Label.filename;
  const $$original = Label;
  Label = hmr(s);
  Label.filename = filename;
  Label[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var label_default = Label;
mark_module_end(Label);

// node_modules/bits-ui/dist/bits/link-preview/index.js
var link_preview_exports = {};
__export(link_preview_exports, {
  Arrow: () => link_preview_arrow_default,
  Content: () => link_preview_content_default,
  Root: () => link_preview_default,
  Trigger: () => link_preview_trigger_default
});

// node_modules/bits-ui/dist/bits/link-preview/ctx.js
function getLinkPreviewData() {
  const NAME = "link-preview";
  const PARTS = ["arrow", "content", "trigger"];
  return {
    NAME,
    PARTS
  };
}
function setCtx17(props) {
  const { NAME, PARTS } = getLinkPreviewData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const linkPreview = {
    ...createLinkPreview({
      ...removeUndefined2(props),
      forceVisible: true
    }),
    getAttrs: getAttrs2
  };
  setContext(NAME, linkPreview);
  return {
    ...linkPreview,
    updateOption: getOptionUpdater(linkPreview.options)
  };
}
function getCtx16() {
  const { NAME } = getLinkPreviewData();
  return getContext(NAME);
}
function setArrow4(size2 = 8) {
  const linkPreview = getCtx16();
  linkPreview.options.arrowSize.set(size2);
  return linkPreview;
}
function updatePositioning8(props) {
  const defaultPlacement = {
    side: "bottom",
    align: "center"
  };
  const withDefaults = { ...defaultPlacement, ...props };
  const { options: { positioning } } = getCtx16();
  const updater = getPositioningUpdater(positioning);
  updater(withDefaults);
}

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview.svelte
mark_module_start();
Link_preview[FILENAME] = "node_modules/bits-ui/dist/bits/link-preview/components/link-preview.svelte";
function Link_preview($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Link_preview);
  const $$stores = setup_stores();
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  let open = prop($$props, "open", 12, () => void 0);
  let onOpenChange = prop($$props, "onOpenChange", 8, () => void 0);
  let openDelay = prop($$props, "openDelay", 0, 700);
  let closeDelay = prop($$props, "closeDelay", 0, 300);
  let closeOnOutsideClick = prop($$props, "closeOnOutsideClick", 8, () => void 0);
  let closeOnEscape = prop($$props, "closeOnEscape", 8, () => void 0);
  let portal = prop($$props, "portal", 8, () => void 0);
  let onOutsideClick = prop($$props, "onOutsideClick", 8, () => void 0);
  const {
    states: { open: localOpen },
    updateOption,
    ids
  } = setCtx17({
    defaultOpen: open(),
    openDelay: openDelay(),
    closeDelay: closeDelay(),
    closeOnOutsideClick: closeOnOutsideClick(),
    closeOnEscape: closeOnEscape(),
    portal: portal(),
    onOutsideClick: onOutsideClick(),
    onOpenChange: ({ next: next2 }) => {
      var _a;
      if (open() !== next2) {
        (_a = onOpenChange()) == null ? void 0 : _a(next2);
        open(next2);
      }
      return next2;
    }
  });
  const idValues = derived([ids.content, ids.trigger], ([$contentId, $triggerId]) => ({ content: $contentId, trigger: $triggerId }));
  legacy_pre_effect(() => deep_read_state(open()), () => {
    open() !== void 0 && localOpen.set(open());
  });
  legacy_pre_effect(() => deep_read_state(openDelay()), () => {
    updateOption("openDelay", openDelay());
  });
  legacy_pre_effect(() => deep_read_state(closeDelay()), () => {
    updateOption("closeDelay", closeDelay());
  });
  legacy_pre_effect(
    () => deep_read_state(closeOnOutsideClick()),
    () => {
      updateOption("closeOnOutsideClick", closeOnOutsideClick());
    }
  );
  legacy_pre_effect(() => deep_read_state(closeOnEscape()), () => {
    updateOption("closeOnEscape", closeOnEscape());
  });
  legacy_pre_effect(() => deep_read_state(portal()), () => {
    updateOption("portal", portal());
  });
  legacy_pre_effect(() => deep_read_state(onOutsideClick()), () => {
    updateOption("onOutsideClick", onOutsideClick());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get ids() {
        return $idValues();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Link_preview);
  const filename = Link_preview.filename;
  const $$original = Link_preview;
  Link_preview = hmr(s);
  Link_preview.filename = filename;
  Link_preview[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var link_preview_default = Link_preview;
mark_module_end(Link_preview);

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview-arrow.svelte
mark_module_start();
Link_preview_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/link-preview/components/link-preview-arrow.svelte";
var root_292 = add_locations(template(`<div></div>`), Link_preview_arrow[FILENAME], [[20, 1]]);
function Link_preview_arrow($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el", "size"]);
  push($$props, false, Link_preview_arrow);
  const $$stores = setup_stores();
  const $arrow = () => (validate_store(arrow2, "arrow"), store_get(arrow2, "$arrow", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  let size2 = prop($$props, "size", 0, 8);
  const { elements: { arrow: arrow2 }, getAttrs: getAttrs2 } = setArrow4(size2());
  const attrs = getAttrs2("arrow");
  legacy_pre_effect(() => $arrow(), () => {
    set(builder, $arrow());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_292();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Link_preview_arrow);
  const filename = Link_preview_arrow.filename;
  const $$original = Link_preview_arrow;
  Link_preview_arrow = hmr(s);
  Link_preview_arrow.filename = filename;
  Link_preview_arrow[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var link_preview_arrow_default = Link_preview_arrow;
mark_module_end(Link_preview_arrow);

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview-content.svelte
mark_module_start();
Link_preview_content[FILENAME] = "node_modules/bits-ui/dist/bits/link-preview/components/link-preview-content.svelte";
var root_318 = add_locations(template(`<div><!></div>`), Link_preview_content[FILENAME], [[61, 1]]);
var root_513 = add_locations(template(`<div><!></div>`), Link_preview_content[FILENAME], [[74, 1]]);
var root_713 = add_locations(template(`<div><!></div>`), Link_preview_content[FILENAME], [[88, 1]]);
var root_913 = add_locations(template(`<div><!></div>`), Link_preview_content[FILENAME], [[101, 1]]);
var root_1113 = add_locations(template(`<div><!></div>`), Link_preview_content[FILENAME], [[114, 1]]);
function Link_preview_content($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "side",
    "align",
    "sideOffset",
    "alignOffset",
    "collisionPadding",
    "avoidCollisions",
    "collisionBoundary",
    "sameWidth",
    "fitViewport",
    "strategy",
    "overlap",
    "el"
  ]);
  push($$props, false, Link_preview_content);
  const $$stores = setup_stores();
  const $content = () => (validate_store(content, "content"), store_get(content, "$content", $$stores));
  const $open = () => (validate_store(open, "open"), store_get(open, "$open", $$stores));
  const builder = mutable_source();
  let transition2 = prop($$props, "transition", 8, () => void 0);
  let transitionConfig = prop($$props, "transitionConfig", 8, () => void 0);
  let inTransition = prop($$props, "inTransition", 8, () => void 0);
  let inTransitionConfig = prop($$props, "inTransitionConfig", 8, () => void 0);
  let outTransition = prop($$props, "outTransition", 8, () => void 0);
  let outTransitionConfig = prop($$props, "outTransitionConfig", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let side = prop($$props, "side", 0, "bottom");
  let align = prop($$props, "align", 0, "center");
  let sideOffset = prop($$props, "sideOffset", 0, 0);
  let alignOffset = prop($$props, "alignOffset", 0, 0);
  let collisionPadding = prop($$props, "collisionPadding", 0, 8);
  let avoidCollisions = prop($$props, "avoidCollisions", 0, true);
  let collisionBoundary = prop($$props, "collisionBoundary", 8, () => void 0);
  let sameWidth = prop($$props, "sameWidth", 0, false);
  let fitViewport = prop($$props, "fitViewport", 0, false);
  let strategy = prop($$props, "strategy", 0, "absolute");
  let overlap = prop($$props, "overlap", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { content },
    states: { open },
    ids,
    getAttrs: getAttrs2
  } = getCtx16();
  const attrs = getAttrs2("content");
  const dispatch = createDispatcher();
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.content.set(id());
    }
  });
  legacy_pre_effect(() => $content(), () => {
    set(builder, $content());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(
    () => ($open(), deep_read_state(side()), deep_read_state(align()), deep_read_state(sideOffset()), deep_read_state(alignOffset()), deep_read_state(collisionPadding()), deep_read_state(avoidCollisions()), deep_read_state(collisionBoundary()), deep_read_state(sameWidth()), deep_read_state(fitViewport()), deep_read_state(strategy()), deep_read_state(overlap())),
    () => {
      if ($open()) {
        updatePositioning8({
          side: side(),
          align: align(),
          sideOffset: sideOffset(),
          alignOffset: alignOffset(),
          collisionPadding: collisionPadding(),
          avoidCollisions: avoidCollisions(),
          collisionBoundary: collisionBoundary(),
          sameWidth: sameWidth(),
          fitViewport: fitViewport(),
          strategy: strategy(),
          overlap: overlap()
        });
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => asChild() && $open(),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      if_block(
        node_2,
        () => transition2() && $open(),
        ($$anchor3) => {
          var div = root_318();
          bind_this(div, ($$value) => el($$value), () => el());
          transition(3, div, transition2, transitionConfig);
          let attributes;
          var node_3 = child(div);
          slot(
            node_3,
            default_slot($$props),
            {
              get builder() {
                return get2(builder);
              }
            },
            null
          );
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
          action(div, ($$node) => get2(builder).action($$node));
          event("m-focusout", div, dispatch, false);
          event("m-pointerdown", div, dispatch, false);
          event("m-pointerenter", div, dispatch, false);
          event("m-pointerleave", div, dispatch, false);
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          if_block(
            node_4,
            () => inTransition() && outTransition() && $open(),
            ($$anchor4) => {
              var div_1 = root_513();
              bind_this(div_1, ($$value) => el($$value), () => el());
              transition(1, div_1, inTransition, inTransitionConfig);
              transition(2, div_1, outTransition, outTransitionConfig);
              let attributes_1;
              var node_5 = child(div_1);
              slot(
                node_5,
                default_slot($$props),
                {
                  get builder() {
                    return get2(builder);
                  }
                },
                null
              );
              reset(div_1);
              template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get2(builder), ...$$restProps }, true, ""));
              action(div_1, ($$node) => get2(builder).action($$node));
              event("m-focusout", div_1, dispatch, false);
              event("m-pointerdown", div_1, dispatch, false);
              event("m-pointerenter", div_1, dispatch, false);
              event("m-pointerleave", div_1, dispatch, false);
              append($$anchor4, div_1);
            },
            ($$anchor4) => {
              var fragment_4 = comment();
              var node_6 = first_child(fragment_4);
              if_block(
                node_6,
                () => inTransition() && $open(),
                ($$anchor5) => {
                  var div_2 = root_713();
                  bind_this(div_2, ($$value) => el($$value), () => el());
                  transition(1, div_2, inTransition, inTransitionConfig);
                  let attributes_2;
                  var node_7 = child(div_2);
                  slot(
                    node_7,
                    default_slot($$props),
                    {
                      get builder() {
                        return get2(builder);
                      }
                    },
                    null
                  );
                  reset(div_2);
                  template_effect(() => attributes_2 = set_attributes(div_2, attributes_2, { ...get2(builder), ...$$restProps }, true, ""));
                  action(div_2, ($$node) => get2(builder).action($$node));
                  event("m-focusout", div_2, dispatch, false);
                  event("m-pointerdown", div_2, dispatch, false);
                  event("m-pointerenter", div_2, dispatch, false);
                  event("m-pointerleave", div_2, dispatch, false);
                  append($$anchor5, div_2);
                },
                ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_8 = first_child(fragment_5);
                  if_block(
                    node_8,
                    () => outTransition() && $open(),
                    ($$anchor6) => {
                      var div_3 = root_913();
                      bind_this(div_3, ($$value) => el($$value), () => el());
                      transition(2, div_3, outTransition, outTransitionConfig);
                      let attributes_3;
                      var node_9 = child(div_3);
                      slot(
                        node_9,
                        default_slot($$props),
                        {
                          get builder() {
                            return get2(builder);
                          }
                        },
                        null
                      );
                      reset(div_3);
                      template_effect(() => attributes_3 = set_attributes(div_3, attributes_3, { ...get2(builder), ...$$restProps }, true, ""));
                      action(div_3, ($$node) => get2(builder).action($$node));
                      event("m-focusout", div_3, dispatch, false);
                      event("m-pointerdown", div_3, dispatch, false);
                      event("m-pointerenter", div_3, dispatch, false);
                      event("m-pointerleave", div_3, dispatch, false);
                      append($$anchor6, div_3);
                    },
                    ($$anchor6) => {
                      var fragment_6 = comment();
                      var node_10 = first_child(fragment_6);
                      if_block(
                        node_10,
                        $open,
                        ($$anchor7) => {
                          var div_4 = root_1113();
                          bind_this(div_4, ($$value) => el($$value), () => el());
                          let attributes_4;
                          var node_11 = child(div_4);
                          slot(
                            node_11,
                            default_slot($$props),
                            {
                              get builder() {
                                return get2(builder);
                              }
                            },
                            null
                          );
                          reset(div_4);
                          template_effect(() => attributes_4 = set_attributes(div_4, attributes_4, { ...get2(builder), ...$$restProps }, true, ""));
                          action(div_4, ($$node) => get2(builder).action($$node));
                          event("m-focusout", div_4, dispatch, false);
                          event("m-pointerdown", div_4, dispatch, false);
                          event("m-pointerenter", div_4, dispatch, false);
                          event("m-pointerleave", div_4, dispatch, false);
                          append($$anchor7, div_4);
                        },
                        null,
                        true
                      );
                      append($$anchor6, fragment_6);
                    },
                    true
                  );
                  append($$anchor5, fragment_5);
                },
                true
              );
              append($$anchor4, fragment_4);
            },
            true
          );
          append($$anchor3, fragment_3);
        },
        true
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Link_preview_content);
  const filename = Link_preview_content.filename;
  const $$original = Link_preview_content;
  Link_preview_content = hmr(s);
  Link_preview_content.filename = filename;
  Link_preview_content[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var link_preview_content_default = Link_preview_content;
mark_module_end(Link_preview_content);

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview-trigger.svelte
mark_module_start();
Link_preview_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/link-preview/components/link-preview-trigger.svelte";
var root_293 = add_locations(template(`<a><!></a>`), Link_preview_trigger[FILENAME], [[28, 1]]);
function Link_preview_trigger($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Link_preview_trigger);
  const $$stores = setup_stores();
  const $trigger = () => (validate_store(trigger, "trigger"), store_get(trigger, "$trigger", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { trigger }, ids, getAttrs: getAttrs2 } = getCtx16();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("trigger");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.trigger.set(id());
    }
  });
  legacy_pre_effect(() => $trigger(), () => {
    set(builder, $trigger());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var a = root_293();
      bind_this(a, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(a);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(a);
      template_effect(() => attributes = set_attributes(
        a,
        attributes,
        {
          ...get2(builder),
          ...$$restProps,
          ...attrs
        },
        true,
        ""
      ));
      action(a, ($$node) => get2(builder).action($$node));
      event("m-blur", a, dispatch, false);
      event("m-focus", a, dispatch, false);
      event("m-pointerenter", a, dispatch, false);
      event("m-pointerleave", a, dispatch, false);
      append($$anchor2, a);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Link_preview_trigger);
  const filename = Link_preview_trigger.filename;
  const $$original = Link_preview_trigger;
  Link_preview_trigger = hmr(s);
  Link_preview_trigger.filename = filename;
  Link_preview_trigger[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var link_preview_trigger_default = Link_preview_trigger;
mark_module_end(Link_preview_trigger);

// node_modules/bits-ui/dist/bits/menubar/index.js
var menubar_exports = {};
__export(menubar_exports, {
  Arrow: () => menu_arrow_default,
  CheckboxIndicator: () => menu_checkbox_indicator_default,
  CheckboxItem: () => menu_checkbox_item_default,
  Content: () => menu_content_default,
  Group: () => menu_group_default,
  Item: () => menu_item_default,
  Label: () => menu_label_default,
  Menu: () => menubar_menu_default,
  RadioGroup: () => menu_radio_group_default,
  RadioIndicator: () => menu_radio_indicator_default,
  RadioItem: () => menu_radio_item_default,
  Root: () => menubar_default,
  Separator: () => menu_separator_default,
  Sub: () => menubar_sub_default,
  SubContent: () => menu_sub_content_default,
  SubTrigger: () => menu_sub_trigger_default,
  Trigger: () => menubar_trigger_default
});

// node_modules/bits-ui/dist/bits/menubar/ctx.js
function getMenubarData() {
  const NAME = "menubar";
  const MENU_NAME = "menu";
  const SUB_NAME = "menu-submenu";
  const PARTS = [
    "arrow",
    "checkbox-indicator",
    "checkbox-item",
    "content",
    "group",
    "item",
    "label",
    "radio-group",
    "radio-item",
    "separator",
    "sub-content",
    "sub-trigger",
    "trigger"
  ];
  return {
    NAME,
    MENU_NAME,
    SUB_NAME,
    PARTS
  };
}
function setCtx18(props) {
  const { NAME, PARTS, MENU_NAME } = getMenubarData();
  const getMenubarAttrs = createBitAttrs(NAME, ["root"]);
  const getAttrs2 = createBitAttrs(MENU_NAME, PARTS);
  const menubar = { ...createMenubar(removeUndefined2(props)), getAttrs: getAttrs2, getMenubarAttrs };
  setContext(NAME, menubar);
  return {
    ...menubar,
    updateOption: getOptionUpdater(menubar.options)
  };
}
function getCtx17() {
  const { NAME } = getMenubarData();
  return getContext(NAME);
}
function setMenuCtx(props) {
  const { MENU_NAME } = getMenubarData();
  const { builders: { createMenu }, getAttrs: getAttrs2 } = getCtx17();
  const menu = { ...createMenu({ ...removeUndefined2(props), forceVisible: false }), getAttrs: getAttrs2 };
  setContext(MENU_NAME, menu);
  return {
    ...menu,
    updateOption: getOptionUpdater(menu.options)
  };
}
function getMenuCtx() {
  const { MENU_NAME } = getMenubarData();
  return getContext(MENU_NAME);
}
function setSubMenuCtx2(props) {
  const { SUB_NAME } = getMenubarData();
  const { builders: { createSubmenu }, getAttrs: getAttrs2 } = getMenuCtx();
  const sub = { ...createSubmenu(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(SUB_NAME, sub);
  return {
    ...sub,
    updateOption: getOptionUpdater(sub.options)
  };
}

// node_modules/bits-ui/dist/bits/menubar/components/menubar.svelte
mark_module_start();
Menubar[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar.svelte";
var root_294 = add_locations(template(`<div><!></div>`), Menubar[FILENAME], [[39, 1]]);
function Menubar($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "loop",
    "closeOnEscape",
    "asChild",
    "id",
    "preventScroll",
    "el"
  ]);
  push($$props, false, Menubar);
  const $$stores = setup_stores();
  const $menubar = () => (validate_store(menubar, "menubar"), store_get(menubar, "$menubar", $$stores));
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  const builder = mutable_source();
  let loop = prop($$props, "loop", 0, true);
  let closeOnEscape = prop($$props, "closeOnEscape", 0, true);
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let preventScroll = prop($$props, "preventScroll", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { menubar },
    updateOption,
    ids,
    getMenubarAttrs
  } = setCtx18({
    loop: loop(),
    closeOnEscape: closeOnEscape(),
    preventScroll: preventScroll()
  });
  const idValues = derived([ids.menubar], ([$menubarId]) => ({ menubar: $menubarId }));
  const attrs = getMenubarAttrs("root");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.menubar.set(id());
    }
  });
  legacy_pre_effect(() => deep_read_state(loop()), () => {
    updateOption("loop", loop());
  });
  legacy_pre_effect(() => deep_read_state(closeOnEscape()), () => {
    updateOption("closeOnEscape", closeOnEscape());
  });
  legacy_pre_effect(() => deep_read_state(preventScroll()), () => {
    updateOption("preventScroll", preventScroll());
  });
  legacy_pre_effect(() => $menubar(), () => {
    set(builder, $menubar());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get ids() {
            return $idValues();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_294();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get ids() {
            return $idValues();
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menubar);
  const filename = Menubar.filename;
  const $$original = Menubar;
  Menubar = hmr(s);
  Menubar.filename = filename;
  Menubar[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menubar_default = Menubar;
mark_module_end(Menubar);

// node_modules/bits-ui/dist/bits/menubar/components/menubar-sub.svelte
mark_module_start();
Menubar_sub[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar-sub.svelte";
function Menubar_sub($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Menubar_sub);
  const $$stores = setup_stores();
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let open = prop($$props, "open", 12, () => void 0);
  let onOpenChange = prop($$props, "onOpenChange", 8, () => void 0);
  const { updateOption, ids, states: { subOpen } } = setSubMenuCtx2({
    disabled: disabled(),
    onOpenChange: ({ next: next2 }) => {
      var _a;
      if (open() !== next2) {
        (_a = onOpenChange()) == null ? void 0 : _a(next2);
        open(next2);
      }
      return next2;
    }
  });
  const idValues = derived([ids.menu, ids.trigger], ([$menuId, $triggerId]) => ({ menu: $menuId, trigger: $triggerId }));
  legacy_pre_effect(() => deep_read_state(open()), () => {
    open() !== void 0 && subOpen.set(open());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get subIds() {
        return $idValues();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menubar_sub);
  const filename = Menubar_sub.filename;
  const $$original = Menubar_sub;
  Menubar_sub = hmr(s);
  Menubar_sub.filename = filename;
  Menubar_sub[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menubar_sub_default = Menubar_sub;
mark_module_end(Menubar_sub);

// node_modules/bits-ui/dist/bits/menubar/components/menubar-menu.svelte
mark_module_start();
Menubar_menu[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar-menu.svelte";
function Menubar_menu($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Menubar_menu);
  const $$stores = setup_stores();
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  let closeOnOutsideClick = prop($$props, "closeOnOutsideClick", 8, () => void 0);
  let closeOnEscape = prop($$props, "closeOnEscape", 8, () => void 0);
  let portal = prop($$props, "portal", 8, () => void 0);
  let open = prop($$props, "open", 12, () => void 0);
  let onOpenChange = prop($$props, "onOpenChange", 8, () => void 0);
  let loop = prop($$props, "loop", 8, () => void 0);
  let dir = prop($$props, "dir", 8, () => void 0);
  let typeahead = prop($$props, "typeahead", 8, () => void 0);
  let closeFocus = prop($$props, "closeFocus", 8, () => void 0);
  let disableFocusFirstItem = prop($$props, "disableFocusFirstItem", 8, () => void 0);
  let closeOnItemClick = prop($$props, "closeOnItemClick", 8, () => void 0);
  let onOutsideClick = prop($$props, "onOutsideClick", 8, () => void 0);
  const {
    states: { open: localOpen },
    updateOption,
    ids
  } = setMenuCtx({
    closeOnOutsideClick: closeOnOutsideClick(),
    closeOnEscape: closeOnEscape(),
    portal: portal(),
    loop: loop(),
    dir: dir(),
    typeahead: typeahead(),
    closeFocus: closeFocus(),
    disableFocusFirstItem: disableFocusFirstItem(),
    closeOnItemClick: closeOnItemClick(),
    onOutsideClick: onOutsideClick(),
    onOpenChange: ({ next: next2 }) => {
      var _a;
      if (open() !== next2) {
        (_a = onOpenChange()) == null ? void 0 : _a(next2);
        open(next2);
      }
      return next2;
    }
  });
  const idValues = derived([ids.menu, ids.trigger], ([$menuId, $triggerId]) => ({ menu: $menuId, trigger: $triggerId }));
  legacy_pre_effect(() => deep_read_state(open()), () => {
    open() !== void 0 && localOpen.set(open());
  });
  legacy_pre_effect(
    () => deep_read_state(closeOnOutsideClick()),
    () => {
      updateOption("closeOnOutsideClick", closeOnOutsideClick());
    }
  );
  legacy_pre_effect(() => deep_read_state(closeOnEscape()), () => {
    updateOption("closeOnEscape", closeOnEscape());
  });
  legacy_pre_effect(() => deep_read_state(portal()), () => {
    updateOption("portal", portal());
  });
  legacy_pre_effect(() => deep_read_state(loop()), () => {
    updateOption("loop", loop());
  });
  legacy_pre_effect(() => deep_read_state(dir()), () => {
    updateOption("dir", dir());
  });
  legacy_pre_effect(() => deep_read_state(closeFocus()), () => {
    updateOption("closeFocus", closeFocus());
  });
  legacy_pre_effect(
    () => deep_read_state(disableFocusFirstItem()),
    () => {
      updateOption("disableFocusFirstItem", disableFocusFirstItem());
    }
  );
  legacy_pre_effect(() => deep_read_state(typeahead()), () => {
    updateOption("typeahead", typeahead());
  });
  legacy_pre_effect(() => deep_read_state(closeOnItemClick()), () => {
    updateOption("closeOnItemClick", closeOnItemClick());
  });
  legacy_pre_effect(() => deep_read_state(onOutsideClick()), () => {
    updateOption("onOutsideClick", onOutsideClick());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get menuIds() {
        return $idValues();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menubar_menu);
  const filename = Menubar_menu.filename;
  const $$original = Menubar_menu;
  Menubar_menu = hmr(s);
  Menubar_menu.filename = filename;
  Menubar_menu[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menubar_menu_default = Menubar_menu;
mark_module_end(Menubar_menu);

// node_modules/bits-ui/dist/bits/menubar/components/menubar-trigger.svelte
mark_module_start();
Menubar_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar-trigger.svelte";
var root_295 = add_locations(template(`<button><!></button>`), Menubar_trigger[FILENAME], [[27, 1]]);
function Menubar_trigger($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Menubar_trigger);
  const $$stores = setup_stores();
  const $trigger = () => (validate_store(trigger, "trigger"), store_get(trigger, "$trigger", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { trigger }, ids, getAttrs: getAttrs2 } = getMenuCtx();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("trigger");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.trigger.set(id());
    }
  });
  legacy_pre_effect(() => $trigger(), () => {
    set(builder, $trigger());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_295();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      event("m-pointerenter", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Menubar_trigger);
  const filename = Menubar_trigger.filename;
  const $$original = Menubar_trigger;
  Menubar_trigger = hmr(s);
  Menubar_trigger.filename = filename;
  Menubar_trigger[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var menubar_trigger_default = Menubar_trigger;
mark_module_end(Menubar_trigger);

// node_modules/bits-ui/dist/bits/pagination/index.js
var pagination_exports = {};
__export(pagination_exports, {
  NextButton: () => pagination_next_button_default,
  Page: () => pagination_page_default,
  PrevButton: () => pagination_prev_button_default,
  Root: () => pagination_default
});

// node_modules/bits-ui/dist/bits/pagination/ctx.js
function getPaginationData() {
  const NAME = "pagination";
  const PARTS = ["root", "prev-button", "next-button", "page"];
  return {
    NAME,
    PARTS
  };
}
function setCtx19(props) {
  const { NAME, PARTS } = getPaginationData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const pagination = { ...createPagination(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(NAME, pagination);
  return {
    ...pagination,
    updateOption: getOptionUpdater(pagination.options)
  };
}
function getCtx18() {
  const { NAME } = getPaginationData();
  return getContext(NAME);
}

// node_modules/bits-ui/dist/bits/pagination/components/pagination.svelte
mark_module_start();
Pagination[FILENAME] = "node_modules/bits-ui/dist/bits/pagination/components/pagination.svelte";
var root_319 = add_locations(template(`<div><!></div>`), Pagination[FILENAME], [[46, 1]]);
function Pagination($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "count",
    "page",
    "onPageChange",
    "perPage",
    "siblingCount",
    "asChild",
    "el"
  ]);
  push($$props, false, Pagination);
  const $$stores = setup_stores();
  const $root = () => (validate_store(root5, "root"), store_get(root5, "$root", $$stores));
  const $pages = () => (validate_store(pages, "pages"), store_get(pages, "$pages", $$stores));
  const $range = () => (validate_store(range, "range"), store_get(range, "$range", $$stores));
  const builder = mutable_source();
  let count = prop($$props, "count");
  let page = prop($$props, "page", 12, () => void 0);
  let onPageChange = prop($$props, "onPageChange", 8, () => void 0);
  let perPage = prop($$props, "perPage", 8, () => void 0);
  let siblingCount = prop($$props, "siblingCount", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { root: root5 },
    states: { pages, range, page: localPage },
    getAttrs: getAttrs2,
    updateOption
  } = setCtx19({
    count: count(),
    perPage: perPage(),
    siblingCount: siblingCount(),
    defaultPage: page(),
    onPageChange: ({ next: next2 }) => {
      var _a;
      if (page() !== next2) {
        (_a = onPageChange()) == null ? void 0 : _a(next2);
        page(next2);
      }
      return next2;
    }
  });
  const attrs = getAttrs2("root");
  legacy_pre_effect(() => deep_read_state(page()), () => {
    page() !== void 0 && localPage.set(page());
  });
  legacy_pre_effect(() => $root(), () => {
    set(builder, $root());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(() => deep_read_state(count()), () => {
    updateOption("count", count());
  });
  legacy_pre_effect(() => deep_read_state(perPage()), () => {
    updateOption("perPage", perPage());
  });
  legacy_pre_effect(() => deep_read_state(siblingCount()), () => {
    updateOption("siblingCount", siblingCount());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get pages() {
            return $pages();
          },
          get range() {
            return $range();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_319();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get pages() {
            return $pages();
          },
          get range() {
            return $range();
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Pagination);
  const filename = Pagination.filename;
  const $$original = Pagination;
  Pagination = hmr(s);
  Pagination.filename = filename;
  Pagination[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var pagination_default = Pagination;
mark_module_end(Pagination);

// node_modules/bits-ui/dist/bits/pagination/components/pagination-prev-button.svelte
mark_module_start();
Pagination_prev_button[FILENAME] = "node_modules/bits-ui/dist/bits/pagination/components/pagination-prev-button.svelte";
var root_296 = add_locations(template(`<button><!></button>`), Pagination_prev_button[FILENAME], [[21, 1]]);
function Pagination_prev_button($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Pagination_prev_button);
  const $$stores = setup_stores();
  const $prevButton = () => (validate_store(prevButton, "prevButton"), store_get(prevButton, "$prevButton", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { prevButton }, getAttrs: getAttrs2 } = getCtx18();
  const attrs = getAttrs2("prev-button");
  const dispatch = createDispatcher();
  legacy_pre_effect(() => $prevButton(), () => {
    set(builder, $prevButton());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_296();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Pagination_prev_button);
  const filename = Pagination_prev_button.filename;
  const $$original = Pagination_prev_button;
  Pagination_prev_button = hmr(s);
  Pagination_prev_button.filename = filename;
  Pagination_prev_button[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var pagination_prev_button_default = Pagination_prev_button;
mark_module_end(Pagination_prev_button);

// node_modules/bits-ui/dist/bits/pagination/components/pagination-next-button.svelte
mark_module_start();
Pagination_next_button[FILENAME] = "node_modules/bits-ui/dist/bits/pagination/components/pagination-next-button.svelte";
var root_297 = add_locations(template(`<button><!></button>`), Pagination_next_button[FILENAME], [[21, 1]]);
function Pagination_next_button($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Pagination_next_button);
  const $$stores = setup_stores();
  const $nextButton = () => (validate_store(nextButton, "nextButton"), store_get(nextButton, "$nextButton", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { nextButton }, getAttrs: getAttrs2 } = getCtx18();
  const attrs = getAttrs2("next-button");
  const dispatch = createDispatcher();
  legacy_pre_effect(() => $nextButton(), () => {
    set(builder, $nextButton());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_297();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Pagination_next_button);
  const filename = Pagination_next_button.filename;
  const $$original = Pagination_next_button;
  Pagination_next_button = hmr(s);
  Pagination_next_button.filename = filename;
  Pagination_next_button[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var pagination_next_button_default = Pagination_next_button;
mark_module_end(Pagination_next_button);

// node_modules/bits-ui/dist/bits/pagination/components/pagination-page.svelte
mark_module_start();
Pagination_page[FILENAME] = "node_modules/bits-ui/dist/bits/pagination/components/pagination-page.svelte";
var root_298 = add_locations(template(`<button><!></button>`), Pagination_page[FILENAME], [[22, 1]]);
function Pagination_page($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "page", "el"]);
  push($$props, false, Pagination_page);
  const $$stores = setup_stores();
  const $pageTrigger = () => (validate_store(pageTrigger, "pageTrigger"), store_get(pageTrigger, "$pageTrigger", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 8, () => void 0);
  let page = prop($$props, "page");
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { pageTrigger }, getAttrs: getAttrs2 } = getCtx18();
  const attrs = getAttrs2("page");
  const dispatch = createDispatcher();
  legacy_pre_effect(
    () => ($pageTrigger(), deep_read_state(page())),
    () => {
      set(builder, $pageTrigger()(page()));
    }
  );
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_298();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, page().value));
          append($$anchor3, text2);
        }
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          type: "button",
          ...get2(builder),
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Pagination_page);
  const filename = Pagination_page.filename;
  const $$original = Pagination_page;
  Pagination_page = hmr(s);
  Pagination_page.filename = filename;
  Pagination_page[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var pagination_page_default = Pagination_page;
mark_module_end(Pagination_page);

// node_modules/bits-ui/dist/bits/pin-input/index.js
var pin_input_exports = {};
__export(pin_input_exports, {
  HiddenInput: () => pin_input_hidden_input_default,
  Input: () => pin_input_input_default,
  Root: () => pin_input_default
});

// node_modules/bits-ui/dist/bits/pin-input/ctx.js
function getPinInputData() {
  const NAME = "pin-input";
  const PARTS = ["root", "input", "hidden-input"];
  return {
    NAME,
    PARTS
  };
}
function setCtx20(props) {
  const { NAME, PARTS } = getPinInputData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const pinInput = { ...createPinInput(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(NAME, pinInput);
  return {
    ...pinInput,
    updateOption: getOptionUpdater(pinInput.options)
  };
}
function getCtx19() {
  const { NAME } = getPinInputData();
  return getContext(NAME);
}

// node_modules/bits-ui/dist/bits/pin-input/components/pin-input.svelte
mark_module_start();
Pin_input[FILENAME] = "node_modules/bits-ui/dist/bits/pin-input/components/pin-input.svelte";
var root_320 = add_locations(template(`<div><!></div>`), Pin_input[FILENAME], [[65, 1]]);
function Pin_input($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "placeholder",
    "value",
    "name",
    "disabled",
    "type",
    "onValueChange",
    "id",
    "asChild",
    "el"
  ]);
  push($$props, false, Pin_input);
  const $$stores = setup_stores();
  const $root = () => (validate_store(root5, "root"), store_get(root5, "$root", $$stores));
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  const builder = mutable_source();
  const slotProps = mutable_source();
  let placeholder = prop($$props, "placeholder", 8, () => void 0);
  let value = prop($$props, "value", 12, () => void 0);
  let name27 = prop($$props, "name", 8, () => void 0);
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let type = prop($$props, "type", 0, "text");
  let onValueChange = prop($$props, "onValueChange", 8, () => void 0);
  let id = prop($$props, "id", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { root: root5 },
    states: { value: localValue },
    updateOption,
    ids,
    getAttrs: getAttrs2
  } = setCtx20({
    placeholder: placeholder(),
    defaultValue: value(),
    name: name27(),
    disabled: disabled(),
    type: type(),
    onValueChange: ({ next: next2 }) => {
      var _a;
      if (value() !== next2) {
        (_a = onValueChange()) == null ? void 0 : _a(next2);
        value(next2);
      }
      return next2;
    }
  });
  const attrs = getAttrs2("root");
  const idValues = derived([ids.root], ([$menubarId]) => ({ menubar: $menubarId }));
  legacy_pre_effect(() => deep_read_state(value()), () => {
    value() !== void 0 && localValue.set(value());
  });
  legacy_pre_effect(() => deep_read_state(placeholder()), () => {
    updateOption("placeholder", placeholder());
  });
  legacy_pre_effect(() => deep_read_state(name27()), () => {
    updateOption("name", name27());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => deep_read_state(type()), () => {
    updateOption("type", type());
  });
  legacy_pre_effect(() => $root(), () => {
    set(builder, $root());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.root.set(id());
    }
  });
  legacy_pre_effect(() => (get2(builder), $idValues()), () => {
    set(slotProps, {
      builder: get2(builder),
      ids: $idValues()
    });
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), spread_props({}, () => get2(slotProps)), null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_320();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(node_2, default_slot($$props), spread_props({}, () => get2(slotProps)), null);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Pin_input);
  const filename = Pin_input.filename;
  const $$original = Pin_input;
  Pin_input = hmr(s);
  Pin_input.filename = filename;
  Pin_input[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var pin_input_default = Pin_input;
mark_module_end(Pin_input);

// node_modules/bits-ui/dist/bits/pin-input/components/pin-input-input.svelte
mark_module_start();
Pin_input_input[FILENAME] = "node_modules/bits-ui/dist/bits/pin-input/components/pin-input-input.svelte";
var root_299 = add_locations(template(`<input>`), Pin_input_input[FILENAME], [[21, 1]]);
function Pin_input_input($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Pin_input_input);
  const $$stores = setup_stores();
  const $input = () => (validate_store(input, "input"), store_get(input, "$input", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { input }, getAttrs: getAttrs2 } = getCtx19();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("input");
  legacy_pre_effect(() => $input(), () => {
    set(builder, $input()());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var input_1 = root_299();
      bind_this(input_1, ($$value) => el($$value), () => el());
      remove_input_defaults(input_1);
      let attributes;
      template_effect(() => attributes = set_attributes(input_1, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(input_1, ($$node) => get2(builder).action($$node));
      event("m-keydown", input_1, dispatch, false);
      event("m-input", input_1, dispatch, false);
      event("m-paste", input_1, dispatch, false);
      event("m-change", input_1, dispatch, false);
      event("m-focus", input_1, dispatch, false);
      event("m-blur", input_1, dispatch, false);
      append($$anchor2, input_1);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Pin_input_input);
  const filename = Pin_input_input.filename;
  const $$original = Pin_input_input;
  Pin_input_input = hmr(s);
  Pin_input_input.filename = filename;
  Pin_input_input[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var pin_input_input_default = Pin_input_input;
mark_module_end(Pin_input_input);

// node_modules/bits-ui/dist/bits/pin-input/components/pin-input-hidden-input.svelte
mark_module_start();
Pin_input_hidden_input[FILENAME] = "node_modules/bits-ui/dist/bits/pin-input/components/pin-input-hidden-input.svelte";
var root_2100 = add_locations(template(`<input>`), Pin_input_hidden_input[FILENAME], [[24, 1]]);
function Pin_input_hidden_input($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Pin_input_hidden_input);
  const $$stores = setup_stores();
  const $disabled = () => (validate_store(disabled, "disabled"), store_get(disabled, "$disabled", $$stores));
  const $hiddenInput = () => (validate_store(hiddenInput, "hiddenInput"), store_get(hiddenInput, "$hiddenInput", $$stores));
  const attrs = mutable_source();
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { hiddenInput },
    options: { disabled },
    getAttrs: getAttrs2
  } = getCtx19();
  legacy_pre_effect(() => $disabled(), () => {
    set(attrs, {
      ...getAttrs2("hidden-input"),
      disabled: $disabled() ? true : void 0
    });
  });
  legacy_pre_effect(() => $hiddenInput(), () => {
    set(builder, $hiddenInput());
  });
  legacy_pre_effect(() => (get2(builder), get2(attrs)), () => {
    Object.assign(get2(builder), get2(attrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var input = root_2100();
      bind_this(input, ($$value) => el($$value), () => el());
      remove_input_defaults(input);
      let attributes;
      template_effect(() => attributes = set_attributes(input, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(input, ($$node) => get2(builder).action($$node));
      append($$anchor2, input);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Pin_input_hidden_input);
  const filename = Pin_input_hidden_input.filename;
  const $$original = Pin_input_hidden_input;
  Pin_input_hidden_input = hmr(s);
  Pin_input_hidden_input.filename = filename;
  Pin_input_hidden_input[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var pin_input_hidden_input_default = Pin_input_hidden_input;
mark_module_end(Pin_input_hidden_input);

// node_modules/bits-ui/dist/bits/popover/index.js
var popover_exports = {};
__export(popover_exports, {
  Arrow: () => popover_arrow_default,
  Close: () => popover_close_default,
  Content: () => popover_content_default,
  Root: () => popover_default,
  Trigger: () => popover_trigger_default
});

// node_modules/bits-ui/dist/bits/popover/components/popover.svelte
mark_module_start();
Popover[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover.svelte";
function Popover($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Popover);
  const $$stores = setup_stores();
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  let disableFocusTrap = prop($$props, "disableFocusTrap", 8, () => void 0);
  let closeOnEscape = prop($$props, "closeOnEscape", 8, () => void 0);
  let closeOnOutsideClick = prop($$props, "closeOnOutsideClick", 8, () => void 0);
  let preventScroll = prop($$props, "preventScroll", 8, () => void 0);
  let portal = prop($$props, "portal", 8, () => void 0);
  let open = prop($$props, "open", 12, () => void 0);
  let onOpenChange = prop($$props, "onOpenChange", 8, () => void 0);
  let openFocus = prop($$props, "openFocus", 8, () => void 0);
  let closeFocus = prop($$props, "closeFocus", 8, () => void 0);
  let onOutsideClick = prop($$props, "onOutsideClick", 8, () => void 0);
  const {
    updateOption,
    states: { open: localOpen },
    ids
  } = setCtx12({
    disableFocusTrap: disableFocusTrap(),
    closeOnEscape: closeOnEscape(),
    closeOnOutsideClick: closeOnOutsideClick(),
    preventScroll: preventScroll(),
    portal: portal(),
    defaultOpen: open(),
    openFocus: openFocus(),
    closeFocus: closeFocus(),
    onOutsideClick: onOutsideClick(),
    onOpenChange: ({ next: next2 }) => {
      var _a;
      if (open() !== next2) {
        (_a = onOpenChange()) == null ? void 0 : _a(next2);
        open(next2);
      }
      return next2;
    },
    positioning: { gutter: 0, offset: { mainAxis: 1 } }
  });
  const idValues = derived([ids.content, ids.trigger], ([$contentId, $triggerId]) => ({ content: $contentId, trigger: $triggerId }));
  legacy_pre_effect(() => deep_read_state(open()), () => {
    open() !== void 0 && localOpen.set(open());
  });
  legacy_pre_effect(() => deep_read_state(disableFocusTrap()), () => {
    updateOption("disableFocusTrap", disableFocusTrap());
  });
  legacy_pre_effect(() => deep_read_state(closeOnEscape()), () => {
    updateOption("closeOnEscape", closeOnEscape());
  });
  legacy_pre_effect(
    () => deep_read_state(closeOnOutsideClick()),
    () => {
      updateOption("closeOnOutsideClick", closeOnOutsideClick());
    }
  );
  legacy_pre_effect(() => deep_read_state(preventScroll()), () => {
    updateOption("preventScroll", preventScroll());
  });
  legacy_pre_effect(() => deep_read_state(portal()), () => {
    updateOption("portal", portal());
  });
  legacy_pre_effect(() => deep_read_state(openFocus()), () => {
    updateOption("openFocus", openFocus());
  });
  legacy_pre_effect(() => deep_read_state(closeFocus()), () => {
    updateOption("closeFocus", closeFocus());
  });
  legacy_pre_effect(() => deep_read_state(onOutsideClick()), () => {
    updateOption("onOutsideClick", onOutsideClick());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get ids() {
        return $idValues();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Popover);
  const filename = Popover.filename;
  const $$original = Popover;
  Popover = hmr(s);
  Popover.filename = filename;
  Popover[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var popover_default = Popover;
mark_module_end(Popover);

// node_modules/bits-ui/dist/bits/popover/components/popover-arrow.svelte
mark_module_start();
Popover_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-arrow.svelte";
var root_2101 = add_locations(template(`<div></div>`), Popover_arrow[FILENAME], [[20, 1]]);
function Popover_arrow($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el", "size"]);
  push($$props, false, Popover_arrow);
  const $$stores = setup_stores();
  const $arrow = () => (validate_store(arrow2, "arrow"), store_get(arrow2, "$arrow", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  let size2 = prop($$props, "size", 0, 8);
  const { elements: { arrow: arrow2 }, getAttrs: getAttrs2 } = setArrow3(size2());
  const attrs = getAttrs2("arrow");
  legacy_pre_effect(() => $arrow(), () => {
    set(builder, $arrow());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2101();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Popover_arrow);
  const filename = Popover_arrow.filename;
  const $$original = Popover_arrow;
  Popover_arrow = hmr(s);
  Popover_arrow.filename = filename;
  Popover_arrow[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var popover_arrow_default = Popover_arrow;
mark_module_end(Popover_arrow);

// node_modules/bits-ui/dist/bits/popover/components/popover-content.svelte
mark_module_start();
Popover_content[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-content.svelte";
var root_321 = add_locations(template(`<div><!></div>`), Popover_content[FILENAME], [[59, 1]]);
var root_514 = add_locations(template(`<div><!></div>`), Popover_content[FILENAME], [[68, 1]]);
var root_714 = add_locations(template(`<div><!></div>`), Popover_content[FILENAME], [[78, 1]]);
var root_914 = add_locations(template(`<div><!></div>`), Popover_content[FILENAME], [[82, 1]]);
var root_1114 = add_locations(template(`<div><!></div>`), Popover_content[FILENAME], [[86, 1]]);
function Popover_content($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "side",
    "align",
    "sideOffset",
    "alignOffset",
    "collisionPadding",
    "avoidCollisions",
    "collisionBoundary",
    "sameWidth",
    "fitViewport",
    "strategy",
    "overlap",
    "el"
  ]);
  push($$props, false, Popover_content);
  const $$stores = setup_stores();
  const $content = () => (validate_store(content, "content"), store_get(content, "$content", $$stores));
  const $open = () => (validate_store(open, "open"), store_get(open, "$open", $$stores));
  const builder = mutable_source();
  let transition2 = prop($$props, "transition", 8, () => void 0);
  let transitionConfig = prop($$props, "transitionConfig", 8, () => void 0);
  let inTransition = prop($$props, "inTransition", 8, () => void 0);
  let inTransitionConfig = prop($$props, "inTransitionConfig", 8, () => void 0);
  let outTransition = prop($$props, "outTransition", 8, () => void 0);
  let outTransitionConfig = prop($$props, "outTransitionConfig", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let side = prop($$props, "side", 0, "bottom");
  let align = prop($$props, "align", 0, "center");
  let sideOffset = prop($$props, "sideOffset", 0, 0);
  let alignOffset = prop($$props, "alignOffset", 0, 0);
  let collisionPadding = prop($$props, "collisionPadding", 0, 8);
  let avoidCollisions = prop($$props, "avoidCollisions", 0, true);
  let collisionBoundary = prop($$props, "collisionBoundary", 8, () => void 0);
  let sameWidth = prop($$props, "sameWidth", 0, false);
  let fitViewport = prop($$props, "fitViewport", 0, false);
  let strategy = prop($$props, "strategy", 0, "absolute");
  let overlap = prop($$props, "overlap", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { content },
    states: { open },
    ids,
    getAttrs: getAttrs2
  } = getCtx11();
  const attrs = getAttrs2("content");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.content.set(id());
    }
  });
  legacy_pre_effect(() => $content(), () => {
    set(builder, $content());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(
    () => ($open(), deep_read_state(side()), deep_read_state(align()), deep_read_state(sideOffset()), deep_read_state(alignOffset()), deep_read_state(collisionPadding()), deep_read_state(avoidCollisions()), deep_read_state(collisionBoundary()), deep_read_state(sameWidth()), deep_read_state(fitViewport()), deep_read_state(strategy()), deep_read_state(overlap())),
    () => {
      if ($open()) {
        updatePositioning5({
          side: side(),
          align: align(),
          sideOffset: sideOffset(),
          alignOffset: alignOffset(),
          collisionPadding: collisionPadding(),
          avoidCollisions: avoidCollisions(),
          collisionBoundary: collisionBoundary(),
          sameWidth: sameWidth(),
          fitViewport: fitViewport(),
          strategy: strategy(),
          overlap: overlap()
        });
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => asChild() && $open(),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      if_block(
        node_2,
        () => transition2() && $open(),
        ($$anchor3) => {
          var div = root_321();
          bind_this(div, ($$value) => el($$value), () => el());
          transition(3, div, transition2, transitionConfig);
          let attributes;
          var node_3 = child(div);
          slot(
            node_3,
            default_slot($$props),
            {
              get builder() {
                return get2(builder);
              }
            },
            null
          );
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
          action(div, ($$node) => get2(builder).action($$node));
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          if_block(
            node_4,
            () => inTransition() && outTransition() && $open(),
            ($$anchor4) => {
              var div_1 = root_514();
              bind_this(div_1, ($$value) => el($$value), () => el());
              transition(1, div_1, inTransition, inTransitionConfig);
              transition(2, div_1, outTransition, outTransitionConfig);
              let attributes_1;
              var node_5 = child(div_1);
              slot(
                node_5,
                default_slot($$props),
                {
                  get builder() {
                    return get2(builder);
                  }
                },
                null
              );
              reset(div_1);
              template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get2(builder), ...$$restProps }, true, ""));
              action(div_1, ($$node) => get2(builder).action($$node));
              append($$anchor4, div_1);
            },
            ($$anchor4) => {
              var fragment_4 = comment();
              var node_6 = first_child(fragment_4);
              if_block(
                node_6,
                () => inTransition() && $open(),
                ($$anchor5) => {
                  var div_2 = root_714();
                  bind_this(div_2, ($$value) => el($$value), () => el());
                  transition(1, div_2, inTransition, inTransitionConfig);
                  let attributes_2;
                  var node_7 = child(div_2);
                  slot(
                    node_7,
                    default_slot($$props),
                    {
                      get builder() {
                        return get2(builder);
                      }
                    },
                    null
                  );
                  reset(div_2);
                  template_effect(() => attributes_2 = set_attributes(div_2, attributes_2, { ...get2(builder), ...$$restProps }, true, ""));
                  action(div_2, ($$node) => get2(builder).action($$node));
                  append($$anchor5, div_2);
                },
                ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_8 = first_child(fragment_5);
                  if_block(
                    node_8,
                    () => outTransition() && $open(),
                    ($$anchor6) => {
                      var div_3 = root_914();
                      bind_this(div_3, ($$value) => el($$value), () => el());
                      transition(2, div_3, outTransition, outTransitionConfig);
                      let attributes_3;
                      var node_9 = child(div_3);
                      slot(
                        node_9,
                        default_slot($$props),
                        {
                          get builder() {
                            return get2(builder);
                          }
                        },
                        null
                      );
                      reset(div_3);
                      template_effect(() => attributes_3 = set_attributes(div_3, attributes_3, { ...get2(builder), ...$$restProps }, true, ""));
                      action(div_3, ($$node) => get2(builder).action($$node));
                      append($$anchor6, div_3);
                    },
                    ($$anchor6) => {
                      var fragment_6 = comment();
                      var node_10 = first_child(fragment_6);
                      if_block(
                        node_10,
                        $open,
                        ($$anchor7) => {
                          var div_4 = root_1114();
                          bind_this(div_4, ($$value) => el($$value), () => el());
                          let attributes_4;
                          var node_11 = child(div_4);
                          slot(
                            node_11,
                            default_slot($$props),
                            {
                              get builder() {
                                return get2(builder);
                              }
                            },
                            null
                          );
                          reset(div_4);
                          template_effect(() => attributes_4 = set_attributes(div_4, attributes_4, { ...get2(builder), ...$$restProps }, true, ""));
                          action(div_4, ($$node) => get2(builder).action($$node));
                          append($$anchor7, div_4);
                        },
                        null,
                        true
                      );
                      append($$anchor6, fragment_6);
                    },
                    true
                  );
                  append($$anchor5, fragment_5);
                },
                true
              );
              append($$anchor4, fragment_4);
            },
            true
          );
          append($$anchor3, fragment_3);
        },
        true
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Popover_content);
  const filename = Popover_content.filename;
  const $$original = Popover_content;
  Popover_content = hmr(s);
  Popover_content.filename = filename;
  Popover_content[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var popover_content_default = Popover_content;
mark_module_end(Popover_content);

// node_modules/bits-ui/dist/bits/popover/components/popover-trigger.svelte
mark_module_start();
Popover_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-trigger.svelte";
var root_2102 = add_locations(template(`<button><!></button>`), Popover_trigger[FILENAME], [[33, 1]]);
function Popover_trigger($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Popover_trigger);
  const $$stores = setup_stores();
  const $open = () => (validate_store(open, "open"), store_get(open, "$open", $$stores));
  const $trigger = () => (validate_store(trigger, "trigger"), store_get(trigger, "$trigger", $$stores));
  const attrs = mutable_source();
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { trigger },
    states: { open },
    ids,
    getAttrs: getAttrs2
  } = getCtx11();
  const dispatch = createDispatcher();
  const bitsAttrs = getAttrs2("trigger");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.trigger.set(id());
    }
  });
  legacy_pre_effect(() => $open(), () => {
    set(attrs, {
      ...bitsAttrs,
      "aria-controls": $open() ? ids.content : void 0
    });
  });
  legacy_pre_effect(() => $trigger(), () => {
    set(builder, $trigger());
  });
  legacy_pre_effect(() => (get2(builder), get2(attrs)), () => {
    Object.assign(get2(builder), get2(attrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_2102();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Popover_trigger);
  const filename = Popover_trigger.filename;
  const $$original = Popover_trigger;
  Popover_trigger = hmr(s);
  Popover_trigger.filename = filename;
  Popover_trigger[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var popover_trigger_default = Popover_trigger;
mark_module_end(Popover_trigger);

// node_modules/bits-ui/dist/bits/popover/components/popover-close.svelte
mark_module_start();
Popover_close[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-close.svelte";
var root_2103 = add_locations(template(`<button><!></button>`), Popover_close[FILENAME], [[21, 1]]);
function Popover_close($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Popover_close);
  const $$stores = setup_stores();
  const $close = () => (validate_store(close, "close"), store_get(close, "$close", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { close }, getAttrs: getAttrs2 } = getCtx11();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("close");
  legacy_pre_effect(() => $close(), () => {
    set(builder, $close());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_2103();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Popover_close);
  const filename = Popover_close.filename;
  const $$original = Popover_close;
  Popover_close = hmr(s);
  Popover_close.filename = filename;
  Popover_close[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var popover_close_default = Popover_close;
mark_module_end(Popover_close);

// node_modules/bits-ui/dist/bits/progress/index.js
var progress_exports = {};
__export(progress_exports, {
  Root: () => progress_default
});

// node_modules/bits-ui/dist/bits/progress/ctx.js
function getProgressData() {
  const NAME = "progress";
  const PARTS = ["root"];
  return {
    NAME,
    PARTS
  };
}
function setCtx21(props) {
  const { NAME, PARTS } = getProgressData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const progress = { ...createProgress(removeUndefined2(props)), getAttrs: getAttrs2 };
  return {
    ...progress,
    updateOption: getOptionUpdater(progress.options)
  };
}

// node_modules/bits-ui/dist/bits/progress/components/progress.svelte
mark_module_start();
Progress[FILENAME] = "node_modules/bits-ui/dist/bits/progress/components/progress.svelte";
var root_322 = add_locations(template(`<div><!></div>`), Progress[FILENAME], [[36, 1]]);
function Progress($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "max",
    "value",
    "onValueChange",
    "asChild",
    "el"
  ]);
  push($$props, false, Progress);
  const $$stores = setup_stores();
  const $root = () => (validate_store(root5, "root"), store_get(root5, "$root", $$stores));
  const builder = mutable_source();
  let max = prop($$props, "max", 8, () => void 0);
  let value = prop($$props, "value", 12, () => void 0);
  let onValueChange = prop($$props, "onValueChange", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { root: root5 },
    states: { value: localValue },
    updateOption,
    getAttrs: getAttrs2
  } = setCtx21({
    max: max(),
    defaultValue: value(),
    onValueChange: ({ next: next2 }) => {
      var _a;
      (_a = onValueChange()) == null ? void 0 : _a(next2);
      value(next2);
      return next2;
    }
  });
  const attrs = getAttrs2("root");
  legacy_pre_effect(() => deep_read_state(value()), () => {
    value() !== void 0 && localValue.set(value());
  });
  legacy_pre_effect(() => deep_read_state(max()), () => {
    updateOption("max", max());
  });
  legacy_pre_effect(() => $root(), () => {
    set(builder, $root());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_322();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Progress);
  const filename = Progress.filename;
  const $$original = Progress;
  Progress = hmr(s);
  Progress.filename = filename;
  Progress[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var progress_default = Progress;
mark_module_end(Progress);

// node_modules/bits-ui/dist/bits/radio-group/index.js
var radio_group_exports = {};
__export(radio_group_exports, {
  Input: () => radio_group_input_default,
  Item: () => radio_group_item_default,
  ItemIndicator: () => radio_group_item_indicator_default,
  Root: () => radio_group_default
});

// node_modules/bits-ui/dist/bits/radio-group/ctx.js
function getRadioGroupData() {
  const NAME = "radio-group";
  const ITEM_NAME = "radio-group-item";
  const PARTS = ["root", "item", "input", "item-indicator"];
  return {
    NAME,
    ITEM_NAME,
    PARTS
  };
}
function setCtx22(props) {
  const { NAME, PARTS } = getRadioGroupData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const radioGroup = { ...createRadioGroup(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(NAME, radioGroup);
  return {
    ...radioGroup,
    updateOption: getOptionUpdater(radioGroup.options)
  };
}
function getCtx20() {
  const { NAME } = getRadioGroupData();
  return getContext(NAME);
}
function setItemCtx2(value) {
  const { ITEM_NAME } = getRadioGroupData();
  const radioGroup = { ...getCtx20(), value };
  setContext(ITEM_NAME, radioGroup);
  return radioGroup;
}
function getRadioIndicator2() {
  const { ITEM_NAME } = getRadioGroupData();
  return getContext(ITEM_NAME);
}

// node_modules/bits-ui/dist/bits/radio-group/components/radio-group.svelte
mark_module_start();
Radio_group[FILENAME] = "node_modules/bits-ui/dist/bits/radio-group/components/radio-group.svelte";
var root_323 = add_locations(template(`<div><!></div>`), Radio_group[FILENAME], [[50, 1]]);
function Radio_group($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "required",
    "disabled",
    "value",
    "onValueChange",
    "loop",
    "orientation",
    "asChild",
    "el"
  ]);
  push($$props, false, Radio_group);
  const $$stores = setup_stores();
  const $root = () => (validate_store(root5, "root"), store_get(root5, "$root", $$stores));
  const builder = mutable_source();
  let required = prop($$props, "required", 8, () => void 0);
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let value = prop($$props, "value", 12, () => void 0);
  let onValueChange = prop($$props, "onValueChange", 8, () => void 0);
  let loop = prop($$props, "loop", 8, () => void 0);
  let orientation = prop($$props, "orientation", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { root: root5 },
    states: { value: localValue },
    updateOption,
    getAttrs: getAttrs2
  } = setCtx22({
    required: required(),
    disabled: disabled(),
    defaultValue: value(),
    loop: loop(),
    orientation: orientation(),
    onValueChange: ({ next: next2 }) => {
      var _a;
      if (value() !== next2) {
        (_a = onValueChange()) == null ? void 0 : _a(next2);
        value(next2);
      }
      return next2;
    }
  });
  const attrs = getAttrs2("root");
  legacy_pre_effect(() => deep_read_state(value()), () => {
    value() !== void 0 && localValue.set(value());
  });
  legacy_pre_effect(() => deep_read_state(required()), () => {
    updateOption("required", required());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => deep_read_state(loop()), () => {
    updateOption("loop", loop());
  });
  legacy_pre_effect(() => deep_read_state(orientation()), () => {
    updateOption("orientation", orientation());
  });
  legacy_pre_effect(() => $root(), () => {
    set(builder, $root());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_323();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Radio_group);
  const filename = Radio_group.filename;
  const $$original = Radio_group;
  Radio_group = hmr(s);
  Radio_group.filename = filename;
  Radio_group[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var radio_group_default = Radio_group;
mark_module_end(Radio_group);

// node_modules/bits-ui/dist/bits/radio-group/components/radio-group-input.svelte
mark_module_start();
Radio_group_input[FILENAME] = "node_modules/bits-ui/dist/bits/radio-group/components/radio-group-input.svelte";
var root_2104 = add_locations(template(`<input>`), Radio_group_input[FILENAME], [[19, 1]]);
function Radio_group_input($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Radio_group_input);
  const $$stores = setup_stores();
  const $hiddenInput = () => (validate_store(hiddenInput, "hiddenInput"), store_get(hiddenInput, "$hiddenInput", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { hiddenInput }, getAttrs: getAttrs2 } = getCtx20();
  const attrs = getAttrs2("input");
  legacy_pre_effect(() => $hiddenInput(), () => {
    set(builder, $hiddenInput());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var input = root_2104();
      bind_this(input, ($$value) => el($$value), () => el());
      remove_input_defaults(input);
      let attributes;
      template_effect(() => attributes = set_attributes(input, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(input, ($$node) => get2(builder).action($$node));
      append($$anchor2, input);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Radio_group_input);
  const filename = Radio_group_input.filename;
  const $$original = Radio_group_input;
  Radio_group_input = hmr(s);
  Radio_group_input.filename = filename;
  Radio_group_input[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var radio_group_input_default = Radio_group_input;
mark_module_end(Radio_group_input);

// node_modules/bits-ui/dist/bits/radio-group/components/radio-group-item.svelte
mark_module_start();
Radio_group_item[FILENAME] = "node_modules/bits-ui/dist/bits/radio-group/components/radio-group-item.svelte";
var root_2105 = add_locations(template(`<button><!></button>`), Radio_group_item[FILENAME], [[23, 1]]);
function Radio_group_item($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["value", "disabled", "asChild", "el"]);
  push($$props, false, Radio_group_item);
  const $$stores = setup_stores();
  const $item = () => (validate_store(item, "item"), store_get(item, "$item", $$stores));
  const builder = mutable_source();
  let value = prop($$props, "value");
  let disabled = prop($$props, "disabled", 0, false);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { item }, getAttrs: getAttrs2 } = setItemCtx2(value());
  const dispatch = createDispatcher();
  const attrs = getAttrs2("item");
  legacy_pre_effect(
    () => ($item(), deep_read_state(value()), deep_read_state(disabled())),
    () => {
      set(builder, $item()({ value: value(), disabled: disabled() }));
    }
  );
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_2105();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-focus", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Radio_group_item);
  const filename = Radio_group_item.filename;
  const $$original = Radio_group_item;
  Radio_group_item = hmr(s);
  Radio_group_item.filename = filename;
  Radio_group_item[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var radio_group_item_default = Radio_group_item;
mark_module_end(Radio_group_item);

// node_modules/bits-ui/dist/bits/radio-group/components/radio-group-item-indicator.svelte
mark_module_start();
Radio_group_item_indicator[FILENAME] = "node_modules/bits-ui/dist/bits/radio-group/components/radio-group-item-indicator.svelte";
var root_2106 = add_locations(template(`<div><!></div>`), Radio_group_item_indicator[FILENAME], [[17, 1]]);
function Radio_group_item_indicator($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Radio_group_item_indicator);
  const $$stores = setup_stores();
  const $isChecked = () => (validate_store(isChecked, "isChecked"), store_get(isChecked, "$isChecked", $$stores));
  const checked = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { helpers: { isChecked }, value, getAttrs: getAttrs2 } = getRadioIndicator2();
  const attrs = getAttrs2("item-indicator");
  legacy_pre_effect(() => $isChecked(), () => {
    set(checked, $isChecked()(value));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get checked() {
            return get2(checked);
          },
          attrs
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2106();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      if_block(node_2, () => get2(checked), ($$anchor3) => {
        var fragment_2 = comment();
        var node_3 = first_child(fragment_2);
        slot(
          node_3,
          default_slot($$props),
          {
            get checked() {
              return get2(checked);
            },
            attrs
          },
          null
        );
        append($$anchor3, fragment_2);
      });
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...attrs, ...$$restProps }, true, ""));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Radio_group_item_indicator);
  const filename = Radio_group_item_indicator.filename;
  const $$original = Radio_group_item_indicator;
  Radio_group_item_indicator = hmr(s);
  Radio_group_item_indicator.filename = filename;
  Radio_group_item_indicator[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var radio_group_item_indicator_default = Radio_group_item_indicator;
mark_module_end(Radio_group_item_indicator);

// node_modules/bits-ui/dist/bits/range-calendar/index.js
var range_calendar_exports = {};
__export(range_calendar_exports, {
  Cell: () => range_calendar_cell_default,
  Day: () => range_calendar_day_default,
  Grid: () => range_calendar_grid_default,
  GridBody: () => range_calendar_grid_body_default,
  GridHead: () => range_calendar_grid_head_default,
  GridRow: () => range_calendar_grid_row_default,
  HeadCell: () => range_calendar_head_cell_default,
  Header: () => range_calendar_header_default,
  Heading: () => range_calendar_heading_default,
  NextButton: () => range_calendar_next_button_default,
  PrevButton: () => range_calendar_prev_button_default,
  Root: () => range_calendar_default
});

// node_modules/bits-ui/dist/bits/range-calendar/ctx.js
function getRangeCalendarData() {
  const NAME = "calendar";
  const PARTS = [
    "root",
    "prev-button",
    "next-button",
    "heading",
    "grid",
    "day",
    "header",
    "grid-head",
    "head-cell",
    "grid-body",
    "cell",
    "grid-row"
  ];
  return { NAME, PARTS };
}
function setCtx23(props) {
  const { NAME, PARTS } = getRangeCalendarData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const rangeCalendar = { ...createRangeCalendar(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(NAME, rangeCalendar);
  return {
    ...rangeCalendar,
    updateOption: getOptionUpdater(rangeCalendar.options)
  };
}
function getCtx21() {
  const { NAME } = getRangeCalendarData();
  return getContext(NAME);
}

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar.svelte
mark_module_start();
Range_calendar[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar.svelte";
var root_2107 = add_locations(template(`<div><!></div>`), Range_calendar[FILENAME], [[137, 1]]);
function Range_calendar($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "placeholder",
    "onPlaceholderChange",
    "value",
    "onValueChange",
    "preventDeselect",
    "minValue",
    "maxValue",
    "pagedNavigation",
    "weekStartsOn",
    "locale",
    "isDateUnavailable",
    "isDateDisabled",
    "disabled",
    "readonly",
    "fixedWeeks",
    "calendarLabel",
    "asChild",
    "id",
    "weekdayFormat",
    "initialFocus",
    "startValue",
    "numberOfMonths",
    "el"
  ]);
  push($$props, false, Range_calendar);
  const $$stores = setup_stores();
  const $localStartValue = () => (validate_store(localStartValue, "localStartValue"), store_get(localStartValue, "$localStartValue", $$stores));
  const $calendar = () => (validate_store(calendar, "calendar"), store_get(calendar, "$calendar", $$stores));
  const $localMonths = () => (validate_store(localMonths, "localMonths"), store_get(localMonths, "$localMonths", $$stores));
  const $weekdays = () => (validate_store(weekdays, "weekdays"), store_get(weekdays, "$weekdays", $$stores));
  const $endValue = () => (validate_store(endValue, "endValue"), store_get(endValue, "$endValue", $$stores));
  const builder = mutable_source();
  let placeholder = prop($$props, "placeholder", 12, () => void 0);
  let onPlaceholderChange = prop($$props, "onPlaceholderChange", 8, () => void 0);
  let value = prop($$props, "value", 12, () => void 0);
  let onValueChange = prop($$props, "onValueChange", 8, () => void 0);
  let preventDeselect = prop($$props, "preventDeselect", 8, () => void 0);
  let minValue = prop($$props, "minValue", 8, () => void 0);
  let maxValue = prop($$props, "maxValue", 8, () => void 0);
  let pagedNavigation = prop($$props, "pagedNavigation", 8, () => void 0);
  let weekStartsOn = prop($$props, "weekStartsOn", 8, () => void 0);
  let locale = prop($$props, "locale", 8, () => void 0);
  let isDateUnavailable = prop($$props, "isDateUnavailable", 8, () => void 0);
  let isDateDisabled = prop($$props, "isDateDisabled", 8, () => void 0);
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let readonly2 = prop($$props, "readonly", 8, () => void 0);
  let fixedWeeks = prop($$props, "fixedWeeks", 8, () => void 0);
  let calendarLabel = prop($$props, "calendarLabel", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let weekdayFormat = prop($$props, "weekdayFormat", 8, () => void 0);
  let initialFocus = prop($$props, "initialFocus", 0, false);
  let startValue = prop($$props, "startValue", 12, () => void 0);
  let numberOfMonths = prop($$props, "numberOfMonths", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  onMount(() => {
    if (!initialFocus() || !el()) return;
    handleCalendarInitialFocus(el());
  });
  const {
    elements: { calendar },
    states: {
      value: localValue,
      placeholder: localPlaceholder,
      months: localMonths,
      weekdays,
      startValue: localStartValue,
      endValue
    },
    updateOption,
    ids,
    getAttrs: getAttrs2
  } = setCtx23({
    defaultPlaceholder: placeholder(),
    defaultValue: value(),
    preventDeselect: preventDeselect(),
    minValue: minValue(),
    maxValue: maxValue(),
    pagedNavigation: pagedNavigation(),
    weekStartsOn: weekStartsOn(),
    locale: locale(),
    isDateUnavailable: isDateUnavailable(),
    isDateDisabled: isDateDisabled(),
    disabled: disabled(),
    readonly: readonly2(),
    fixedWeeks: fixedWeeks(),
    calendarLabel: calendarLabel(),
    weekdayFormat: weekdayFormat(),
    numberOfMonths: numberOfMonths(),
    onPlaceholderChange: ({ next: next2 }) => {
      var _a;
      if (placeholder() !== next2) {
        (_a = onPlaceholderChange()) == null ? void 0 : _a(next2);
        placeholder(next2);
      }
      return next2;
    },
    onValueChange: ({ next: next2 }) => {
      var _a;
      if (value() !== next2) {
        (_a = onValueChange()) == null ? void 0 : _a(next2);
        value(next2);
      }
      return next2;
    }
  });
  const attrs = getAttrs2("root");
  const dispatch = createDispatcher();
  let months = mutable_source($localMonths());
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.calendar.set(id());
    }
  });
  legacy_pre_effect(() => $localStartValue(), () => {
    startValue($localStartValue());
  });
  legacy_pre_effect(() => deep_read_state(value()), () => {
    value() !== void 0 && localValue.set(value());
  });
  legacy_pre_effect(() => deep_read_state(placeholder()), () => {
    placeholder() !== void 0 && localPlaceholder.set(placeholder());
  });
  legacy_pre_effect(() => deep_read_state(preventDeselect()), () => {
    updateOption("preventDeselect", preventDeselect());
  });
  legacy_pre_effect(() => deep_read_state(minValue()), () => {
    updateOption("minValue", minValue());
  });
  legacy_pre_effect(() => deep_read_state(maxValue()), () => {
    updateOption("maxValue", maxValue());
  });
  legacy_pre_effect(() => deep_read_state(pagedNavigation()), () => {
    updateOption("pagedNavigation", pagedNavigation());
  });
  legacy_pre_effect(() => deep_read_state(weekStartsOn()), () => {
    updateOption("weekStartsOn", weekStartsOn());
  });
  legacy_pre_effect(() => deep_read_state(locale()), () => {
    updateOption("locale", locale());
  });
  legacy_pre_effect(() => deep_read_state(isDateUnavailable()), () => {
    updateOption("isDateUnavailable", isDateUnavailable());
  });
  legacy_pre_effect(() => deep_read_state(isDateDisabled()), () => {
    updateOption("isDateDisabled", isDateDisabled());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => deep_read_state(readonly2()), () => {
    updateOption("readonly", readonly2());
  });
  legacy_pre_effect(() => deep_read_state(fixedWeeks()), () => {
    updateOption("fixedWeeks", fixedWeeks());
  });
  legacy_pre_effect(() => deep_read_state(calendarLabel()), () => {
    updateOption("calendarLabel", calendarLabel());
  });
  legacy_pre_effect(() => deep_read_state(weekdayFormat()), () => {
    updateOption("weekdayFormat", weekdayFormat());
  });
  legacy_pre_effect(() => deep_read_state(numberOfMonths()), () => {
    updateOption("numberOfMonths", numberOfMonths());
  });
  legacy_pre_effect(() => $calendar(), () => {
    set(builder, $calendar());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(() => $localMonths(), () => {
    set(months, $localMonths());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get months() {
            return get2(months);
          },
          get weekdays() {
            return $weekdays();
          },
          get startValue() {
            return $localStartValue();
          },
          get endValue() {
            return $endValue();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2107();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get months() {
            return get2(months);
          },
          get weekdays() {
            return $weekdays();
          },
          get startValue() {
            return $localStartValue();
          },
          get endValue() {
            return $endValue();
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      event("m-keydown", div, dispatch, false);
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Range_calendar);
  const filename = Range_calendar.filename;
  const $$original = Range_calendar;
  Range_calendar = hmr(s);
  Range_calendar.filename = filename;
  Range_calendar[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var range_calendar_default = Range_calendar;
mark_module_end(Range_calendar);

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-day.svelte
mark_module_start();
Range_calendar_day[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-day.svelte";
var root_2108 = add_locations(template(`<div><!></div>`), Range_calendar_day[FILENAME], [[28, 1]]);
function Range_calendar_day($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["date", "month", "asChild", "el"]);
  push($$props, false, Range_calendar_day);
  const $$stores = setup_stores();
  const $cell = () => (validate_store(cell, "cell"), store_get(cell, "$cell", $$stores));
  const $isDateDisabled = () => (validate_store(isDateDisabled, "isDateDisabled"), store_get(isDateDisabled, "$isDateDisabled", $$stores));
  const $isDateUnavailable = () => (validate_store(isDateUnavailable, "isDateUnavailable"), store_get(isDateUnavailable, "$isDateUnavailable", $$stores));
  const builder = mutable_source();
  const disabled = mutable_source();
  const unavailable = mutable_source();
  let date = prop($$props, "date");
  let month = prop($$props, "month");
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { cell },
    helpers: { isDateDisabled, isDateUnavailable },
    getAttrs: getAttrs2
  } = getCtx21();
  const attrs = getAttrs2("day");
  const dispatch = createDispatcher();
  legacy_pre_effect(
    () => ($cell(), deep_read_state(date()), deep_read_state(month())),
    () => {
      set(builder, $cell()(date(), month()));
    }
  );
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(
    () => ($isDateDisabled(), deep_read_state(date())),
    () => {
      set(disabled, $isDateDisabled()(date()));
    }
  );
  legacy_pre_effect(
    () => ($isDateUnavailable(), deep_read_state(date())),
    () => {
      set(unavailable, $isDateUnavailable()(date()));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get disabled() {
            return get2(disabled);
          },
          get unavailable() {
            return get2(unavailable);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2108();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get disabled() {
            return get2(disabled);
          },
          get unavailable() {
            return get2(unavailable);
          }
        },
        ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, date().day));
          append($$anchor3, text2);
        }
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      event("m-click", div, dispatch, false);
      event("m-focusin", div, dispatch, false);
      event("m-mouseenter", div, dispatch, false);
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Range_calendar_day);
  const filename = Range_calendar_day.filename;
  const $$original = Range_calendar_day;
  Range_calendar_day = hmr(s);
  Range_calendar_day.filename = filename;
  Range_calendar_day[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var range_calendar_day_default = Range_calendar_day;
mark_module_end(Range_calendar_day);

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-grid.svelte
mark_module_start();
Range_calendar_grid[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-grid.svelte";
var root_2109 = add_locations(template(`<table><!></table>`), Range_calendar_grid[FILENAME], [[19, 1]]);
function Range_calendar_grid($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Range_calendar_grid);
  const $$stores = setup_stores();
  const $grid = () => (validate_store(grid, "grid"), store_get(grid, "$grid", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { grid }, getAttrs: getAttrs2 } = getCtx21();
  const attrs = getAttrs2("grid");
  legacy_pre_effect(() => $grid(), () => {
    set(builder, $grid());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var table = root_2109();
      bind_this(table, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(table);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(table);
      template_effect(() => attributes = set_attributes(table, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(table, ($$node) => get2(builder).action($$node));
      append($$anchor2, table);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Range_calendar_grid);
  const filename = Range_calendar_grid.filename;
  const $$original = Range_calendar_grid;
  Range_calendar_grid = hmr(s);
  Range_calendar_grid.filename = filename;
  Range_calendar_grid[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var range_calendar_grid_default = Range_calendar_grid;
mark_module_end(Range_calendar_grid);

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-grid-body.svelte
mark_module_start();
Range_calendar_grid_body[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-grid-body.svelte";
var root_2110 = add_locations(template(`<tbody><!></tbody>`), Range_calendar_grid_body[FILENAME], [[11, 1]]);
function Range_calendar_grid_body($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Range_calendar_grid_body);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getAttrs: getAttrs2 } = getCtx21();
  const attrs = getAttrs2("grid-body");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var tbody = root_2110();
      bind_this(tbody, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(tbody);
      slot(node_2, default_slot($$props), {}, null);
      reset(tbody);
      template_effect(() => attributes = set_attributes(tbody, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, tbody);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Range_calendar_grid_body);
  const filename = Range_calendar_grid_body.filename;
  const $$original = Range_calendar_grid_body;
  Range_calendar_grid_body = hmr(s);
  Range_calendar_grid_body.filename = filename;
  Range_calendar_grid_body[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var range_calendar_grid_body_default = Range_calendar_grid_body;
mark_module_end(Range_calendar_grid_body);

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-cell.svelte
mark_module_start();
Range_calendar_cell[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-cell.svelte";
var root_2111 = add_locations(template(`<td><!></td>`), Range_calendar_cell[FILENAME], [[20, 1]]);
function Range_calendar_cell($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["date", "asChild", "el"]);
  push($$props, false, Range_calendar_cell);
  const $$stores = setup_stores();
  const $isDateDisabled = () => (validate_store(isDateDisabled, "isDateDisabled"), store_get(isDateDisabled, "$isDateDisabled", $$stores));
  const $isDateUnavailable = () => (validate_store(isDateUnavailable, "isDateUnavailable"), store_get(isDateUnavailable, "$isDateUnavailable", $$stores));
  const attrs = mutable_source();
  let date = prop($$props, "date");
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    helpers: { isDateDisabled, isDateUnavailable },
    getAttrs: getAttrs2
  } = getCtx21();
  legacy_pre_effect(
    () => ($isDateDisabled(), deep_read_state(date()), $isDateUnavailable()),
    () => {
      set(attrs, {
        ...getAttrs2("cell"),
        "aria-disabled": $isDateDisabled()(date()) || $isDateUnavailable()(date()),
        role: "gridcell"
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get attrs() {
            return get2(attrs);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var td = root_2111();
      bind_this(td, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(td);
      slot(
        node_2,
        default_slot($$props),
        {
          get attrs() {
            return get2(attrs);
          }
        },
        null
      );
      reset(td);
      template_effect(() => attributes = set_attributes(td, attributes, { ...$$restProps, ...get2(attrs) }, true, ""));
      append($$anchor2, td);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Range_calendar_cell);
  const filename = Range_calendar_cell.filename;
  const $$original = Range_calendar_cell;
  Range_calendar_cell = hmr(s);
  Range_calendar_cell.filename = filename;
  Range_calendar_cell[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var range_calendar_cell_default = Range_calendar_cell;
mark_module_end(Range_calendar_cell);

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-grid-head.svelte
mark_module_start();
Range_calendar_grid_head[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-grid-head.svelte";
var root_2112 = add_locations(template(`<thead><!></thead>`), Range_calendar_grid_head[FILENAME], [[11, 1]]);
function Range_calendar_grid_head($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Range_calendar_grid_head);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getAttrs: getAttrs2 } = getCtx21();
  const attrs = {
    ...getAttrs2("grid-head"),
    "aria-hidden": true
  };
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var thead = root_2112();
      bind_this(thead, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(thead);
      slot(node_2, default_slot($$props), {}, null);
      reset(thead);
      template_effect(() => attributes = set_attributes(thead, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, thead);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Range_calendar_grid_head);
  const filename = Range_calendar_grid_head.filename;
  const $$original = Range_calendar_grid_head;
  Range_calendar_grid_head = hmr(s);
  Range_calendar_grid_head.filename = filename;
  Range_calendar_grid_head[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var range_calendar_grid_head_default = Range_calendar_grid_head;
mark_module_end(Range_calendar_grid_head);

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-head-cell.svelte
mark_module_start();
Range_calendar_head_cell[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-head-cell.svelte";
var root_2113 = add_locations(template(`<th><!></th>`), Range_calendar_head_cell[FILENAME], [[11, 1]]);
function Range_calendar_head_cell($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Range_calendar_head_cell);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getAttrs: getAttrs2 } = getCtx21();
  const attrs = getAttrs2("head-cell");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var th = root_2113();
      bind_this(th, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(th);
      slot(node_2, default_slot($$props), {}, null);
      reset(th);
      template_effect(() => attributes = set_attributes(th, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, th);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Range_calendar_head_cell);
  const filename = Range_calendar_head_cell.filename;
  const $$original = Range_calendar_head_cell;
  Range_calendar_head_cell = hmr(s);
  Range_calendar_head_cell.filename = filename;
  Range_calendar_head_cell[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var range_calendar_head_cell_default = Range_calendar_head_cell;
mark_module_end(Range_calendar_head_cell);

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-grid-row.svelte
mark_module_start();
Range_calendar_grid_row[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-grid-row.svelte";
var root_2114 = add_locations(template(`<tr><!></tr>`), Range_calendar_grid_row[FILENAME], [[11, 1]]);
function Range_calendar_grid_row($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Range_calendar_grid_row);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getAttrs: getAttrs2 } = getCtx21();
  const attrs = getAttrs2("grid-row");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var tr = root_2114();
      bind_this(tr, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(tr);
      slot(node_2, default_slot($$props), { attrs }, null);
      reset(tr);
      template_effect(() => attributes = set_attributes(tr, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, tr);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Range_calendar_grid_row);
  const filename = Range_calendar_grid_row.filename;
  const $$original = Range_calendar_grid_row;
  Range_calendar_grid_row = hmr(s);
  Range_calendar_grid_row.filename = filename;
  Range_calendar_grid_row[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var range_calendar_grid_row_default = Range_calendar_grid_row;
mark_module_end(Range_calendar_grid_row);

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-header.svelte
mark_module_start();
Range_calendar_header[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-header.svelte";
var root_2115 = add_locations(template(`<header><!></header>`), Range_calendar_header[FILENAME], [[11, 1]]);
function Range_calendar_header($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Range_calendar_header);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { getAttrs: getAttrs2 } = getCtx21();
  const attrs = getAttrs2("header");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, default_slot($$props), { attrs }, null);
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var header = root_2115();
      bind_this(header, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(header);
      slot(node_2, default_slot($$props), { attrs }, null);
      reset(header);
      template_effect(() => attributes = set_attributes(header, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, header);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Range_calendar_header);
  const filename = Range_calendar_header.filename;
  const $$original = Range_calendar_header;
  Range_calendar_header = hmr(s);
  Range_calendar_header.filename = filename;
  Range_calendar_header[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var range_calendar_header_default = Range_calendar_header;
mark_module_end(Range_calendar_header);

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-heading.svelte
mark_module_start();
Range_calendar_heading[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-heading.svelte";
var root_2116 = add_locations(template(`<div><!></div>`), Range_calendar_heading[FILENAME], [[20, 1]]);
function Range_calendar_heading($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Range_calendar_heading);
  const $$stores = setup_stores();
  const $heading = () => (validate_store(heading, "heading"), store_get(heading, "$heading", $$stores));
  const $headingValue = () => (validate_store(headingValue, "headingValue"), store_get(headingValue, "$headingValue", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { heading },
    states: { headingValue },
    getAttrs: getAttrs2
  } = getCtx21();
  const attrs = getAttrs2("heading");
  legacy_pre_effect(() => $heading(), () => {
    set(builder, $heading());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get headingValue() {
            return $headingValue();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2116();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get headingValue() {
            return $headingValue();
          }
        },
        ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, $headingValue()));
          append($$anchor3, text2);
        }
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Range_calendar_heading);
  const filename = Range_calendar_heading.filename;
  const $$original = Range_calendar_heading;
  Range_calendar_heading = hmr(s);
  Range_calendar_heading.filename = filename;
  Range_calendar_heading[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var range_calendar_heading_default = Range_calendar_heading;
mark_module_end(Range_calendar_heading);

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-next-button.svelte
mark_module_start();
Range_calendar_next_button[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-next-button.svelte";
var root_2117 = add_locations(template(`<button><!></button>`), Range_calendar_next_button[FILENAME], [[21, 1]]);
function Range_calendar_next_button($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Range_calendar_next_button);
  const $$stores = setup_stores();
  const $nextButton = () => (validate_store(nextButton, "nextButton"), store_get(nextButton, "$nextButton", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { nextButton }, getAttrs: getAttrs2 } = getCtx21();
  const attrs = getAttrs2("next-button");
  const dispatch = createDispatcher();
  legacy_pre_effect(() => $nextButton(), () => {
    set(builder, $nextButton());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_2117();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Range_calendar_next_button);
  const filename = Range_calendar_next_button.filename;
  const $$original = Range_calendar_next_button;
  Range_calendar_next_button = hmr(s);
  Range_calendar_next_button.filename = filename;
  Range_calendar_next_button[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var range_calendar_next_button_default = Range_calendar_next_button;
mark_module_end(Range_calendar_next_button);

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-prev-button.svelte
mark_module_start();
Range_calendar_prev_button[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-prev-button.svelte";
var root_2118 = add_locations(template(`<button><!></button>`), Range_calendar_prev_button[FILENAME], [[21, 1]]);
function Range_calendar_prev_button($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Range_calendar_prev_button);
  const $$stores = setup_stores();
  const $prevButton = () => (validate_store(prevButton, "prevButton"), store_get(prevButton, "$prevButton", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { prevButton }, getAttrs: getAttrs2 } = getCtx21();
  const attrs = getAttrs2("prev-button");
  const dispatch = createDispatcher();
  legacy_pre_effect(() => $prevButton(), () => {
    set(builder, $prevButton());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_2118();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Range_calendar_prev_button);
  const filename = Range_calendar_prev_button.filename;
  const $$original = Range_calendar_prev_button;
  Range_calendar_prev_button = hmr(s);
  Range_calendar_prev_button.filename = filename;
  Range_calendar_prev_button[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var range_calendar_prev_button_default = Range_calendar_prev_button;
mark_module_end(Range_calendar_prev_button);

// node_modules/bits-ui/dist/bits/scroll-area/index.js
var scroll_area_exports = {};
__export(scroll_area_exports, {
  Content: () => scroll_area_content_default,
  Corner: () => scroll_area_corner_default,
  Root: () => scroll_area_default,
  Scrollbar: () => scroll_area_scrollbar_default,
  Thumb: () => scroll_area_thumb_default,
  Viewport: () => scroll_area_viewport_default
});

// node_modules/bits-ui/dist/bits/scroll-area/ctx.js
function getScrollAreaData() {
  const NAME = "scroll-area";
  const SCROLLBAR_NAME = "scrollbar";
  const PARTS = [
    "scrollbar-x",
    "scrollbar-y",
    "thumb-x",
    "thumb-y",
    "viewport",
    "content",
    "root",
    "corner"
  ];
  return { NAME, PARTS, SCROLLBAR_NAME };
}
function setCtx24(props) {
  const { NAME, PARTS } = getScrollAreaData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const scrollArea = { ...createScrollArea(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(NAME, scrollArea);
  return {
    ...scrollArea,
    updateOption: getOptionUpdater(scrollArea.options)
  };
}
function getCtx22() {
  const { NAME } = getScrollAreaData();
  return getContext(NAME);
}
function setScrollbarOrientation(orientation) {
  const { SCROLLBAR_NAME } = getScrollAreaData();
  return setContext(SCROLLBAR_NAME, orientation);
}
function getScrollbarOrientation() {
  const { SCROLLBAR_NAME } = getScrollAreaData();
  return getContext(SCROLLBAR_NAME);
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area.svelte
mark_module_start();
Scroll_area[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area.svelte";
var root_324 = add_locations(template(`<div><!></div>`), Scroll_area[FILENAME], [[43, 1]]);
function Scroll_area($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "type",
    "dir",
    "hideDelay",
    "asChild",
    "el"
  ]);
  push($$props, false, Scroll_area);
  const $$stores = setup_stores();
  const $root = () => (validate_store(root5, "root"), store_get(root5, "$root", $$stores));
  const builder = mutable_source();
  const attrs = mutable_source();
  let type = prop($$props, "type", 0, "hover");
  let dir = prop($$props, "dir", 0, "ltr");
  let hideDelay = prop($$props, "hideDelay", 0, 600);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { root: root5 }, updateOption, getAttrs: getAttrs2 } = setCtx24({
    type: type(),
    dir: dir(),
    hideDelay: hideDelay()
  });
  const bitsAttrs = getAttrs2("root");
  const style = styleToString2({ overflow: "hidden" });
  legacy_pre_effect(() => $root(), () => {
    set(builder, $root());
  });
  legacy_pre_effect(() => deep_read_state(type()), () => {
    updateOption("type", type());
  });
  legacy_pre_effect(() => deep_read_state(dir()), () => {
    updateOption("dir", dir());
  });
  legacy_pre_effect(() => deep_read_state(hideDelay()), () => {
    updateOption("hideDelay", hideDelay());
  });
  legacy_pre_effect(() => deep_read_state($$restProps), () => {
    set(attrs, { ...$$restProps, ...bitsAttrs, style });
  });
  legacy_pre_effect(() => (get2(builder), get2(attrs)), () => {
    Object.assign(get2(builder), get2(attrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_324();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...get2(attrs) }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Scroll_area);
  const filename = Scroll_area.filename;
  const $$original = Scroll_area;
  Scroll_area = hmr(s);
  Scroll_area.filename = filename;
  Scroll_area[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var scroll_area_default = Scroll_area;
mark_module_end(Scroll_area);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-viewport.svelte
mark_module_start();
Scroll_area_viewport[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-viewport.svelte";
var root_2119 = add_locations(template(`<div><!></div>`), Scroll_area_viewport[FILENAME], [[24, 1]]);
function Scroll_area_viewport($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Scroll_area_viewport);
  const $$stores = setup_stores();
  const $viewport = () => (validate_store(viewport, "viewport"), store_get(viewport, "$viewport", $$stores));
  const attrs = mutable_source();
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { viewport }, getAttrs: getAttrs2 } = getCtx22();
  const bitsAttrs = getAttrs2("viewport");
  legacy_pre_effect(() => deep_read_state($$restProps), () => {
    set(attrs, { ...$$restProps, ...bitsAttrs });
  });
  legacy_pre_effect(() => $viewport(), () => {
    set(builder, $viewport());
  });
  legacy_pre_effect(() => (get2(builder), get2(attrs)), () => {
    Object.assign(get2(builder), get2(attrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2119();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder) }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Scroll_area_viewport);
  const filename = Scroll_area_viewport.filename;
  const $$original = Scroll_area_viewport;
  Scroll_area_viewport = hmr(s);
  Scroll_area_viewport.filename = filename;
  Scroll_area_viewport[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var scroll_area_viewport_default = Scroll_area_viewport;
mark_module_end(Scroll_area_viewport);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-content.svelte
mark_module_start();
Scroll_area_content[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-content.svelte";
var root_2120 = add_locations(template(`<div><!></div>`), Scroll_area_content[FILENAME], [[24, 1]]);
function Scroll_area_content($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Scroll_area_content);
  const $$stores = setup_stores();
  const $content = () => (validate_store(content, "content"), store_get(content, "$content", $$stores));
  const attrs = mutable_source();
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { content }, getAttrs: getAttrs2 } = getCtx22();
  const bitsAttrs = getAttrs2("content");
  legacy_pre_effect(() => deep_read_state($$restProps), () => {
    set(attrs, { ...$$restProps, ...bitsAttrs });
  });
  legacy_pre_effect(() => $content(), () => {
    set(builder, $content());
  });
  legacy_pre_effect(() => (get2(builder), get2(attrs)), () => {
    Object.assign(get2(builder), get2(attrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2120();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder) }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Scroll_area_content);
  const filename = Scroll_area_content.filename;
  const $$original = Scroll_area_content;
  Scroll_area_content = hmr(s);
  Scroll_area_content.filename = filename;
  Scroll_area_content[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var scroll_area_content_default = Scroll_area_content;
mark_module_end(Scroll_area_content);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-y.svelte
mark_module_start();
Scroll_area_scrollbar_y[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-y.svelte";
var root_2121 = add_locations(template(`<div><!></div>`), Scroll_area_scrollbar_y[FILENAME], [[24, 1]]);
function Scroll_area_scrollbar_y($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Scroll_area_scrollbar_y);
  const $$stores = setup_stores();
  const $scrollbarY = () => (validate_store(scrollbarY, "scrollbarY"), store_get(scrollbarY, "$scrollbarY", $$stores));
  const attrs = mutable_source();
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { scrollbarY }, getAttrs: getAttrs2 } = getCtx22();
  const bitsAttrs = getAttrs2("scrollbar-y");
  legacy_pre_effect(() => deep_read_state($$restProps), () => {
    set(attrs, { ...$$restProps, ...bitsAttrs });
  });
  legacy_pre_effect(() => $scrollbarY(), () => {
    set(builder, $scrollbarY());
  });
  legacy_pre_effect(() => (get2(builder), get2(attrs)), () => {
    Object.assign(get2(builder), get2(attrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2121();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder) }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Scroll_area_scrollbar_y);
  const filename = Scroll_area_scrollbar_y.filename;
  const $$original = Scroll_area_scrollbar_y;
  Scroll_area_scrollbar_y = hmr(s);
  Scroll_area_scrollbar_y.filename = filename;
  Scroll_area_scrollbar_y[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var scroll_area_scrollbar_y_default = Scroll_area_scrollbar_y;
mark_module_end(Scroll_area_scrollbar_y);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-x.svelte
mark_module_start();
Scroll_area_scrollbar_x[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-x.svelte";
var root_2122 = add_locations(template(`<div><!></div>`), Scroll_area_scrollbar_x[FILENAME], [[24, 1]]);
function Scroll_area_scrollbar_x($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Scroll_area_scrollbar_x);
  const $$stores = setup_stores();
  const $scrollbarX = () => (validate_store(scrollbarX, "scrollbarX"), store_get(scrollbarX, "$scrollbarX", $$stores));
  const attrs = mutable_source();
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { scrollbarX }, getAttrs: getAttrs2 } = getCtx22();
  const bitsAttrs = getAttrs2("scrollbar-x");
  legacy_pre_effect(() => deep_read_state($$restProps), () => {
    set(attrs, { ...$$restProps, ...bitsAttrs });
  });
  legacy_pre_effect(() => $scrollbarX(), () => {
    set(builder, $scrollbarX());
  });
  legacy_pre_effect(() => (get2(builder), get2(attrs)), () => {
    Object.assign(get2(builder), get2(attrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2122();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder) }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Scroll_area_scrollbar_x);
  const filename = Scroll_area_scrollbar_x.filename;
  const $$original = Scroll_area_scrollbar_x;
  Scroll_area_scrollbar_x = hmr(s);
  Scroll_area_scrollbar_x.filename = filename;
  Scroll_area_scrollbar_x[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var scroll_area_scrollbar_x_default = Scroll_area_scrollbar_x;
mark_module_end(Scroll_area_scrollbar_x);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar.svelte
mark_module_start();
Scroll_area_scrollbar[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar.svelte";
function Scroll_area_scrollbar($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["orientation"]);
  push($$props, false, Scroll_area_scrollbar);
  const $$stores = setup_stores();
  const $orientationStore = () => (validate_store(orientationStore, "orientationStore"), store_get(orientationStore, "$orientationStore", $$stores));
  let orientation = prop($$props, "orientation");
  const orientationStore = writable(orientation());
  setScrollbarOrientation(orientationStore);
  legacy_pre_effect(() => deep_read_state(orientation()), () => {
    orientationStore.set(orientation());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $orientationStore() === "vertical",
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      validate_component(scroll_area_scrollbar_y_default)(node_1, spread_props(() => $$restProps, {
        $$slots: {
          default: ($$anchor3, $$slotProps) => {
            const builder = derived_safe_equal(() => $$slotProps.builder);
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            slot(
              node_2,
              default_slot($$props),
              {
                get builder() {
                  return get2(builder);
                }
              },
              null
            );
            append($$anchor3, fragment_2);
          }
        },
        $$legacy: true
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_3 = comment();
      var node_3 = first_child(fragment_3);
      validate_component(scroll_area_scrollbar_x_default)(node_3, spread_props(() => $$restProps, {
        $$slots: {
          default: ($$anchor3, $$slotProps) => {
            const builder = derived_safe_equal(() => $$slotProps.builder);
            var fragment_4 = comment();
            var node_4 = first_child(fragment_4);
            slot(
              node_4,
              default_slot($$props),
              {
                get builder() {
                  return get2(builder);
                }
              },
              null
            );
            append($$anchor3, fragment_4);
          }
        },
        $$legacy: true
      }));
      append($$anchor2, fragment_3);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Scroll_area_scrollbar);
  const filename = Scroll_area_scrollbar.filename;
  const $$original = Scroll_area_scrollbar;
  Scroll_area_scrollbar = hmr(s);
  Scroll_area_scrollbar.filename = filename;
  Scroll_area_scrollbar[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var scroll_area_scrollbar_default = Scroll_area_scrollbar;
mark_module_end(Scroll_area_scrollbar);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb-y.svelte
mark_module_start();
Scroll_area_thumb_y[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb-y.svelte";
var root_2123 = add_locations(template(`<div><!></div>`), Scroll_area_thumb_y[FILENAME], [[24, 1]]);
function Scroll_area_thumb_y($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Scroll_area_thumb_y);
  const $$stores = setup_stores();
  const $thumbY = () => (validate_store(thumbY, "thumbY"), store_get(thumbY, "$thumbY", $$stores));
  const attrs = mutable_source();
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { thumbY }, getAttrs: getAttrs2 } = getCtx22();
  const bitsAttrs = getAttrs2("thumb-y");
  legacy_pre_effect(() => deep_read_state($$restProps), () => {
    set(attrs, { ...$$restProps, ...bitsAttrs });
  });
  legacy_pre_effect(() => $thumbY(), () => {
    set(builder, $thumbY());
  });
  legacy_pre_effect(() => (get2(builder), get2(attrs)), () => {
    Object.assign(get2(builder), get2(attrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2123();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder) }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Scroll_area_thumb_y);
  const filename = Scroll_area_thumb_y.filename;
  const $$original = Scroll_area_thumb_y;
  Scroll_area_thumb_y = hmr(s);
  Scroll_area_thumb_y.filename = filename;
  Scroll_area_thumb_y[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var scroll_area_thumb_y_default = Scroll_area_thumb_y;
mark_module_end(Scroll_area_thumb_y);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb-x.svelte
mark_module_start();
Scroll_area_thumb_x[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb-x.svelte";
var root_2124 = add_locations(template(`<div><!></div>`), Scroll_area_thumb_x[FILENAME], [[24, 1]]);
function Scroll_area_thumb_x($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Scroll_area_thumb_x);
  const $$stores = setup_stores();
  const $thumbX = () => (validate_store(thumbX, "thumbX"), store_get(thumbX, "$thumbX", $$stores));
  const attrs = mutable_source();
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { thumbX }, getAttrs: getAttrs2 } = getCtx22();
  const bitsAttrs = getAttrs2("thumb-x");
  legacy_pre_effect(() => deep_read_state($$restProps), () => {
    set(attrs, { ...$$restProps, ...bitsAttrs });
  });
  legacy_pre_effect(() => $thumbX(), () => {
    set(builder, $thumbX());
  });
  legacy_pre_effect(() => (get2(builder), get2(attrs)), () => {
    Object.assign(get2(builder), get2(attrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2124();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder) }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Scroll_area_thumb_x);
  const filename = Scroll_area_thumb_x.filename;
  const $$original = Scroll_area_thumb_x;
  Scroll_area_thumb_x = hmr(s);
  Scroll_area_thumb_x.filename = filename;
  Scroll_area_thumb_x[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var scroll_area_thumb_x_default = Scroll_area_thumb_x;
mark_module_end(Scroll_area_thumb_x);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb.svelte
mark_module_start();
Scroll_area_thumb[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb.svelte";
function Scroll_area_thumb($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, Scroll_area_thumb);
  const $$stores = setup_stores();
  const $orientation = () => (validate_store(orientation, "orientation"), store_get(orientation, "$orientation", $$stores));
  const orientation = getScrollbarOrientation();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $orientation() === "vertical",
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      validate_component(scroll_area_thumb_y_default)(node_1, spread_props(() => $$restProps, {
        $$slots: {
          default: ($$anchor3, $$slotProps) => {
            const builder = derived_safe_equal(() => $$slotProps.builder);
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            slot(
              node_2,
              default_slot($$props),
              {
                get builder() {
                  return get2(builder);
                }
              },
              null
            );
            append($$anchor3, fragment_2);
          }
        },
        $$legacy: true
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_3 = comment();
      var node_3 = first_child(fragment_3);
      validate_component(scroll_area_thumb_x_default)(node_3, spread_props(() => $$restProps, {
        $$slots: {
          default: ($$anchor3, $$slotProps) => {
            const builder = derived_safe_equal(() => $$slotProps.builder);
            var fragment_4 = comment();
            var node_4 = first_child(fragment_4);
            slot(
              node_4,
              default_slot($$props),
              {
                get builder() {
                  return get2(builder);
                }
              },
              null
            );
            append($$anchor3, fragment_4);
          }
        },
        $$legacy: true
      }));
      append($$anchor2, fragment_3);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Scroll_area_thumb);
  const filename = Scroll_area_thumb.filename;
  const $$original = Scroll_area_thumb;
  Scroll_area_thumb = hmr(s);
  Scroll_area_thumb.filename = filename;
  Scroll_area_thumb[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var scroll_area_thumb_default = Scroll_area_thumb;
mark_module_end(Scroll_area_thumb);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-corner.svelte
mark_module_start();
Scroll_area_corner[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-corner.svelte";
var root_2125 = add_locations(template(`<div><!></div>`), Scroll_area_corner[FILENAME], [[24, 1]]);
function Scroll_area_corner($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Scroll_area_corner);
  const $$stores = setup_stores();
  const $corner = () => (validate_store(corner, "corner"), store_get(corner, "$corner", $$stores));
  const attrs = mutable_source();
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { corner }, getAttrs: getAttrs2 } = getCtx22();
  const bitsAttrs = getAttrs2("corner");
  legacy_pre_effect(() => deep_read_state($$restProps), () => {
    set(attrs, { ...$$restProps, ...bitsAttrs });
  });
  legacy_pre_effect(() => $corner(), () => {
    set(builder, $corner());
  });
  legacy_pre_effect(() => (get2(builder), get2(attrs)), () => {
    Object.assign(get2(builder), get2(attrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2125();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder) }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Scroll_area_corner);
  const filename = Scroll_area_corner.filename;
  const $$original = Scroll_area_corner;
  Scroll_area_corner = hmr(s);
  Scroll_area_corner.filename = filename;
  Scroll_area_corner[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var scroll_area_corner_default = Scroll_area_corner;
mark_module_end(Scroll_area_corner);

// node_modules/bits-ui/dist/bits/select/index.js
var select_exports = {};
__export(select_exports, {
  Arrow: () => select_arrow_default,
  Content: () => select_content_default,
  Group: () => select_group_default,
  Input: () => select_input_default,
  Item: () => select_item_default,
  ItemIndicator: () => select_item_indicator_default,
  Label: () => select_label_default,
  Root: () => select_default,
  Separator: () => separator_default,
  Trigger: () => select_trigger_default,
  Value: () => select_value_default
});

// node_modules/bits-ui/dist/bits/select/ctx.js
function getSelectData2() {
  const NAME = "select";
  const GROUP_NAME = "select-group";
  const ITEM_NAME = "select-item";
  const PARTS = [
    "arrow",
    "content",
    "group",
    "item",
    "indicator",
    "input",
    "label",
    "trigger",
    "value"
  ];
  return {
    NAME,
    GROUP_NAME,
    ITEM_NAME,
    PARTS
  };
}
function getCtx23() {
  const { NAME } = getSelectData2();
  return getContext(NAME);
}
function setCtx25(props) {
  const { NAME, PARTS } = getSelectData2();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const select = {
    ...createSelect({ ...removeUndefined2(props), forceVisible: true }),
    getAttrs: getAttrs2
  };
  setContext(NAME, select);
  return {
    ...select,
    updateOption: getOptionUpdater(select.options)
  };
}
function setGroupCtx3() {
  const { GROUP_NAME } = getSelectData2();
  const id = generateId2();
  setContext(GROUP_NAME, id);
  const { elements: { group }, getAttrs: getAttrs2 } = getCtx23();
  return { group, id, getAttrs: getAttrs2 };
}
function setItemCtx3(value) {
  const { ITEM_NAME } = getSelectData2();
  const select = getCtx23();
  setContext(ITEM_NAME, value);
  return select;
}
function getGroupLabel3() {
  const { GROUP_NAME } = getSelectData2();
  const id = getContext(GROUP_NAME);
  const { elements: { groupLabel }, getAttrs: getAttrs2 } = getCtx23();
  return { groupLabel, id, getAttrs: getAttrs2 };
}
function getItemIndicator2() {
  const { ITEM_NAME } = getSelectData2();
  const { helpers: { isSelected }, getAttrs: getAttrs2 } = getCtx23();
  const value = getContext(ITEM_NAME);
  return {
    value,
    isSelected,
    getAttrs: getAttrs2
  };
}
function setArrow5(size2 = 8) {
  var _a;
  const select = getCtx23();
  (_a = select.options.arrowSize) == null ? void 0 : _a.set(size2);
  return select;
}
function updatePositioning9(props) {
  const defaultPlacement = {
    side: "bottom",
    align: "center",
    sameWidth: true
  };
  const withDefaults = { ...defaultPlacement, ...props };
  const { options: { positioning } } = getCtx23();
  const updater = getPositioningUpdater(positioning);
  updater(withDefaults);
}

// node_modules/bits-ui/dist/bits/select/components/select.svelte
mark_module_start();
Select[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select.svelte";
function Select($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Select);
  const $$stores = setup_stores();
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  let required = prop($$props, "required", 8, () => void 0);
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let preventScroll = prop($$props, "preventScroll", 8, () => void 0);
  let loop = prop($$props, "loop", 8, () => void 0);
  let closeOnEscape = prop($$props, "closeOnEscape", 8, () => void 0);
  let closeOnOutsideClick = prop($$props, "closeOnOutsideClick", 8, () => void 0);
  let portal = prop($$props, "portal", 8, () => void 0);
  let name27 = prop($$props, "name", 8, () => void 0);
  let multiple = prop($$props, "multiple", 0, false);
  let selected = prop($$props, "selected", 12, () => void 0);
  let onSelectedChange = prop($$props, "onSelectedChange", 8, () => void 0);
  let open = prop($$props, "open", 12, () => void 0);
  let onOpenChange = prop($$props, "onOpenChange", 8, () => void 0);
  let items = prop($$props, "items", 8, () => []);
  let onOutsideClick = prop($$props, "onOutsideClick", 8, () => void 0);
  const {
    states: { open: localOpen, selected: localSelected },
    updateOption,
    ids
  } = setCtx25({
    required: required(),
    disabled: disabled(),
    preventScroll: preventScroll(),
    loop: loop(),
    closeOnEscape: closeOnEscape(),
    closeOnOutsideClick: closeOnOutsideClick(),
    portal: portal(),
    name: name27(),
    onOutsideClick: onOutsideClick(),
    multiple: multiple(),
    forceVisible: true,
    defaultSelected: Array.isArray(selected()) ? [...selected()] : selected(),
    defaultOpen: open(),
    onSelectedChange: ({ next: next2 }) => {
      var _a, _b;
      if (Array.isArray(next2)) {
        if (!Array.isArray(selected()) || !arraysAreEqual(selected(), next2)) {
          (_a = onSelectedChange()) == null ? void 0 : _a(next2);
          selected(next2);
          return next2;
        }
        return next2;
      }
      if (selected() !== next2) {
        (_b = onSelectedChange()) == null ? void 0 : _b(next2);
        selected(next2);
      }
      return next2;
    },
    onOpenChange: ({ next: next2 }) => {
      var _a;
      if (open() !== next2) {
        (_a = onOpenChange()) == null ? void 0 : _a(next2);
        open(next2);
      }
      return next2;
    },
    items: items()
  });
  const idValues = derived([ids.menu, ids.trigger, ids.label], ([$menuId, $triggerId, $labelId]) => ({
    menu: $menuId,
    trigger: $triggerId,
    label: $labelId
  }));
  legacy_pre_effect(() => deep_read_state(open()), () => {
    open() !== void 0 && localOpen.set(open());
  });
  legacy_pre_effect(() => deep_read_state(selected()), () => {
    selected() !== void 0 && localSelected.set(Array.isArray(selected()) ? [...selected()] : selected());
  });
  legacy_pre_effect(() => deep_read_state(required()), () => {
    updateOption("required", required());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => deep_read_state(preventScroll()), () => {
    updateOption("preventScroll", preventScroll());
  });
  legacy_pre_effect(() => deep_read_state(loop()), () => {
    updateOption("loop", loop());
  });
  legacy_pre_effect(() => deep_read_state(closeOnEscape()), () => {
    updateOption("closeOnEscape", closeOnEscape());
  });
  legacy_pre_effect(
    () => deep_read_state(closeOnOutsideClick()),
    () => {
      updateOption("closeOnOutsideClick", closeOnOutsideClick());
    }
  );
  legacy_pre_effect(() => deep_read_state(portal()), () => {
    updateOption("portal", portal());
  });
  legacy_pre_effect(() => deep_read_state(name27()), () => {
    updateOption("name", name27());
  });
  legacy_pre_effect(() => deep_read_state(multiple()), () => {
    updateOption("multiple", multiple());
  });
  legacy_pre_effect(() => deep_read_state(onOutsideClick()), () => {
    updateOption("onOutsideClick", onOutsideClick());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get ids() {
        return $idValues();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Select);
  const filename = Select.filename;
  const $$original = Select;
  Select = hmr(s);
  Select.filename = filename;
  Select[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var select_default = Select;
mark_module_end(Select);

// node_modules/bits-ui/dist/bits/select/components/select-arrow.svelte
mark_module_start();
Select_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-arrow.svelte";
var root_2126 = add_locations(template(`<div></div>`), Select_arrow[FILENAME], [[20, 1]]);
function Select_arrow($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el", "size"]);
  push($$props, false, Select_arrow);
  const $$stores = setup_stores();
  const $arrow = () => (validate_store(arrow2, "arrow"), store_get(arrow2, "$arrow", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  let size2 = prop($$props, "size", 0, 8);
  const { elements: { arrow: arrow2 }, getAttrs: getAttrs2 } = setArrow5(size2());
  const attrs = getAttrs2("arrow");
  legacy_pre_effect(() => $arrow(), () => {
    set(builder, $arrow());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2126();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Select_arrow);
  const filename = Select_arrow.filename;
  const $$original = Select_arrow;
  Select_arrow = hmr(s);
  Select_arrow.filename = filename;
  Select_arrow[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var select_arrow_default = Select_arrow;
mark_module_end(Select_arrow);

// node_modules/bits-ui/dist/bits/select/components/select-content.svelte
mark_module_start();
Select_content[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-content.svelte";
var root_325 = add_locations(template(`<div><!></div>`), Select_content[FILENAME], [[62, 1]]);
var root_515 = add_locations(template(`<div><!></div>`), Select_content[FILENAME], [[73, 1]]);
var root_715 = add_locations(template(`<div><!></div>`), Select_content[FILENAME], [[85, 1]]);
var root_915 = add_locations(template(`<div><!></div>`), Select_content[FILENAME], [[96, 1]]);
var root_1115 = add_locations(template(`<div><!></div>`), Select_content[FILENAME], [[107, 1]]);
function Select_content($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "side",
    "align",
    "sideOffset",
    "alignOffset",
    "collisionPadding",
    "avoidCollisions",
    "collisionBoundary",
    "sameWidth",
    "fitViewport",
    "strategy",
    "overlap",
    "el"
  ]);
  push($$props, false, Select_content);
  const $$stores = setup_stores();
  const $menu = () => (validate_store(menu, "menu"), store_get(menu, "$menu", $$stores));
  const $open = () => (validate_store(open, "open"), store_get(open, "$open", $$stores));
  const builder = mutable_source();
  let transition2 = prop($$props, "transition", 8, () => void 0);
  let transitionConfig = prop($$props, "transitionConfig", 8, () => void 0);
  let inTransition = prop($$props, "inTransition", 8, () => void 0);
  let inTransitionConfig = prop($$props, "inTransitionConfig", 8, () => void 0);
  let outTransition = prop($$props, "outTransition", 8, () => void 0);
  let outTransitionConfig = prop($$props, "outTransitionConfig", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let side = prop($$props, "side", 0, "bottom");
  let align = prop($$props, "align", 0, "center");
  let sideOffset = prop($$props, "sideOffset", 0, 0);
  let alignOffset = prop($$props, "alignOffset", 0, 0);
  let collisionPadding = prop($$props, "collisionPadding", 0, 8);
  let avoidCollisions = prop($$props, "avoidCollisions", 0, true);
  let collisionBoundary = prop($$props, "collisionBoundary", 8, () => void 0);
  let sameWidth = prop($$props, "sameWidth", 0, true);
  let fitViewport = prop($$props, "fitViewport", 0, false);
  let strategy = prop($$props, "strategy", 0, "absolute");
  let overlap = prop($$props, "overlap", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { menu },
    states: { open },
    ids,
    getAttrs: getAttrs2
  } = getCtx23();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("content");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.menu.set(id());
    }
  });
  legacy_pre_effect(() => $menu(), () => {
    set(builder, $menu());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(
    () => ($open(), deep_read_state(side()), deep_read_state(align()), deep_read_state(sideOffset()), deep_read_state(alignOffset()), deep_read_state(collisionPadding()), deep_read_state(avoidCollisions()), deep_read_state(collisionBoundary()), deep_read_state(sameWidth()), deep_read_state(fitViewport()), deep_read_state(strategy()), deep_read_state(overlap())),
    () => {
      if ($open()) {
        updatePositioning9({
          side: side(),
          align: align(),
          sideOffset: sideOffset(),
          alignOffset: alignOffset(),
          collisionPadding: collisionPadding(),
          avoidCollisions: avoidCollisions(),
          collisionBoundary: collisionBoundary(),
          sameWidth: sameWidth(),
          fitViewport: fitViewport(),
          strategy: strategy(),
          overlap: overlap()
        });
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => asChild() && $open(),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      if_block(
        node_2,
        () => transition2() && $open(),
        ($$anchor3) => {
          var div = root_325();
          bind_this(div, ($$value) => el($$value), () => el());
          transition(3, div, transition2, transitionConfig);
          let attributes;
          var node_3 = child(div);
          slot(
            node_3,
            default_slot($$props),
            {
              get builder() {
                return get2(builder);
              }
            },
            null
          );
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
          action(div, ($$node) => get2(builder).action($$node));
          event("m-pointerleave", div, dispatch, false);
          event("keydown", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          if_block(
            node_4,
            () => inTransition() && outTransition() && $open(),
            ($$anchor4) => {
              var div_1 = root_515();
              bind_this(div_1, ($$value) => el($$value), () => el());
              transition(1, div_1, inTransition, inTransitionConfig);
              transition(2, div_1, outTransition, outTransitionConfig);
              let attributes_1;
              var node_5 = child(div_1);
              slot(
                node_5,
                default_slot($$props),
                {
                  get builder() {
                    return get2(builder);
                  }
                },
                null
              );
              reset(div_1);
              template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get2(builder), ...$$restProps }, true, ""));
              action(div_1, ($$node) => get2(builder).action($$node));
              event("m-pointerleave", div_1, dispatch, false);
              event("keydown", div_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              append($$anchor4, div_1);
            },
            ($$anchor4) => {
              var fragment_4 = comment();
              var node_6 = first_child(fragment_4);
              if_block(
                node_6,
                () => inTransition() && $open(),
                ($$anchor5) => {
                  var div_2 = root_715();
                  bind_this(div_2, ($$value) => el($$value), () => el());
                  transition(1, div_2, inTransition, inTransitionConfig);
                  let attributes_2;
                  var node_7 = child(div_2);
                  slot(
                    node_7,
                    default_slot($$props),
                    {
                      get builder() {
                        return get2(builder);
                      }
                    },
                    null
                  );
                  reset(div_2);
                  template_effect(() => attributes_2 = set_attributes(div_2, attributes_2, { ...get2(builder), ...$$restProps }, true, ""));
                  action(div_2, ($$node) => get2(builder).action($$node));
                  event("m-pointerleave", div_2, dispatch, false);
                  event("keydown", div_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  append($$anchor5, div_2);
                },
                ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_8 = first_child(fragment_5);
                  if_block(
                    node_8,
                    () => outTransition() && $open(),
                    ($$anchor6) => {
                      var div_3 = root_915();
                      bind_this(div_3, ($$value) => el($$value), () => el());
                      transition(2, div_3, outTransition, outTransitionConfig);
                      let attributes_3;
                      var node_9 = child(div_3);
                      slot(
                        node_9,
                        default_slot($$props),
                        {
                          get builder() {
                            return get2(builder);
                          }
                        },
                        null
                      );
                      reset(div_3);
                      template_effect(() => attributes_3 = set_attributes(div_3, attributes_3, { ...get2(builder), ...$$restProps }, true, ""));
                      action(div_3, ($$node) => get2(builder).action($$node));
                      event("m-pointerleave", div_3, dispatch, false);
                      event("keydown", div_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      append($$anchor6, div_3);
                    },
                    ($$anchor6) => {
                      var fragment_6 = comment();
                      var node_10 = first_child(fragment_6);
                      if_block(
                        node_10,
                        $open,
                        ($$anchor7) => {
                          var div_4 = root_1115();
                          bind_this(div_4, ($$value) => el($$value), () => el());
                          let attributes_4;
                          var node_11 = child(div_4);
                          slot(
                            node_11,
                            default_slot($$props),
                            {
                              get builder() {
                                return get2(builder);
                              }
                            },
                            null
                          );
                          reset(div_4);
                          template_effect(() => attributes_4 = set_attributes(div_4, attributes_4, { ...get2(builder), ...$$restProps }, true, ""));
                          action(div_4, ($$node) => get2(builder).action($$node));
                          event("m-pointerleave", div_4, dispatch, false);
                          event("keydown", div_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          append($$anchor7, div_4);
                        },
                        null,
                        true
                      );
                      append($$anchor6, fragment_6);
                    },
                    true
                  );
                  append($$anchor5, fragment_5);
                },
                true
              );
              append($$anchor4, fragment_4);
            },
            true
          );
          append($$anchor3, fragment_3);
        },
        true
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Select_content);
  const filename = Select_content.filename;
  const $$original = Select_content;
  Select_content = hmr(s);
  Select_content.filename = filename;
  Select_content[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var select_content_default = Select_content;
mark_module_end(Select_content);

// node_modules/bits-ui/dist/bits/select/components/select-group.svelte
mark_module_start();
Select_group[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-group.svelte";
var root_2127 = add_locations(template(`<div><!></div>`), Select_group[FILENAME], [[16, 1]]);
function Select_group($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Select_group);
  const $$stores = setup_stores();
  const $group = () => (validate_store(group, "group"), store_get(group, "$group", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { group, id, getAttrs: getAttrs2 } = setGroupCtx3();
  const attrs = getAttrs2("group");
  legacy_pre_effect(() => $group(), () => {
    set(builder, $group()(id));
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2127();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Select_group);
  const filename = Select_group.filename;
  const $$original = Select_group;
  Select_group = hmr(s);
  Select_group.filename = filename;
  Select_group[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var select_group_default = Select_group;
mark_module_end(Select_group);

// node_modules/bits-ui/dist/bits/select/components/select-input.svelte
mark_module_start();
Select_input[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-input.svelte";
var root_2128 = add_locations(template(`<input>`), Select_input[FILENAME], [[24, 1]]);
function Select_input($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Select_input);
  const $$stores = setup_stores();
  const $disabled = () => (validate_store(disabled, "disabled"), store_get(disabled, "$disabled", $$stores));
  const $hiddenInput = () => (validate_store(hiddenInput, "hiddenInput"), store_get(hiddenInput, "$hiddenInput", $$stores));
  const attrs = mutable_source();
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { hiddenInput },
    options: { disabled },
    getAttrs: getAttrs2
  } = getCtx23();
  legacy_pre_effect(() => $disabled(), () => {
    set(attrs, {
      ...getAttrs2("input"),
      disabled: $disabled() ? true : void 0
    });
  });
  legacy_pre_effect(() => $hiddenInput(), () => {
    set(builder, $hiddenInput());
  });
  legacy_pre_effect(() => (get2(builder), get2(attrs)), () => {
    Object.assign(get2(builder), get2(attrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var input = root_2128();
      bind_this(input, ($$value) => el($$value), () => el());
      remove_input_defaults(input);
      let attributes;
      template_effect(() => attributes = set_attributes(input, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(input, ($$node) => get2(builder).action($$node));
      append($$anchor2, input);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Select_input);
  const filename = Select_input.filename;
  const $$original = Select_input;
  Select_input = hmr(s);
  Select_input.filename = filename;
  Select_input[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var select_input_default = Select_input;
mark_module_end(Select_input);

// node_modules/bits-ui/dist/bits/select/components/select-item.svelte
mark_module_start();
Select_item[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-item.svelte";
var root_2129 = add_locations(template(`<div><!></div>`), Select_item[FILENAME], [[28, 1]]);
function Select_item($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "value",
    "disabled",
    "label",
    "asChild",
    "el"
  ]);
  push($$props, false, Select_item);
  const $$stores = setup_stores();
  const $item = () => (validate_store(item, "item"), store_get(item, "$item", $$stores));
  const $isSelectedStore = () => (validate_store(isSelectedStore, "isSelectedStore"), store_get(isSelectedStore, "$isSelectedStore", $$stores));
  const builder = mutable_source();
  const isSelected = mutable_source();
  let value = prop($$props, "value");
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let label = prop($$props, "label", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { option: item },
    helpers: { isSelected: isSelectedStore },
    getAttrs: getAttrs2
  } = setItemCtx3(value());
  const dispatch = createDispatcher();
  const attrs = getAttrs2("item");
  legacy_pre_effect(
    () => ($item(), deep_read_state(value()), deep_read_state(disabled()), deep_read_state(label())),
    () => {
      set(builder, $item()({
        value: value(),
        disabled: disabled(),
        label: label()
      }));
    }
  );
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(
    () => ($isSelectedStore(), deep_read_state(value())),
    () => {
      set(isSelected, $isSelectedStore()(value()));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get isSelected() {
            return get2(isSelected);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2129();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get isSelected() {
            return get2(isSelected);
          }
        },
        ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, label() || value()));
          append($$anchor3, text2);
        }
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      event("m-click", div, dispatch, false);
      event("m-pointermove", div, dispatch, false);
      event("focusin", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event("keydown", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event("focusout", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event("pointerleave", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Select_item);
  const filename = Select_item.filename;
  const $$original = Select_item;
  Select_item = hmr(s);
  Select_item.filename = filename;
  Select_item[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var select_item_default = Select_item;
mark_module_end(Select_item);

// node_modules/bits-ui/dist/bits/select/components/select-item-indicator.svelte
mark_module_start();
Select_item_indicator[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-item-indicator.svelte";
var root_2130 = add_locations(template(`<div><!></div>`), Select_item_indicator[FILENAME], [[11, 1]]);
function Select_item_indicator($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Select_item_indicator);
  const $$stores = setup_stores();
  const $isSelected = () => (validate_store(isSelected, "isSelected"), store_get(isSelected, "$isSelected", $$stores));
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { isSelected, value, getAttrs: getAttrs2 } = getItemIndicator2();
  const attrs = getAttrs2("indicator");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          attrs,
          get isSelected() {
            return $isSelected()(value);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2130();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      if_block(node_2, () => $isSelected()(value), ($$anchor3) => {
        var fragment_2 = comment();
        var node_3 = first_child(fragment_2);
        slot(
          node_3,
          default_slot($$props),
          {
            attrs,
            get isSelected() {
              return $isSelected()(value);
            }
          },
          null
        );
        append($$anchor3, fragment_2);
      });
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, ...attrs }, true, ""));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Select_item_indicator);
  const filename = Select_item_indicator.filename;
  const $$original = Select_item_indicator;
  Select_item_indicator = hmr(s);
  Select_item_indicator.filename = filename;
  Select_item_indicator[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var select_item_indicator_default = Select_item_indicator;
mark_module_end(Select_item_indicator);

// node_modules/bits-ui/dist/bits/select/components/select-label.svelte
mark_module_start();
Select_label[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-label.svelte";
var root_2131 = add_locations(template(`<div><!></div>`), Select_label[FILENAME], [[22, 1]]);
function Select_label($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Select_label);
  const $$stores = setup_stores();
  const $groupLabel = () => (validate_store(groupLabel, "groupLabel"), store_get(groupLabel, "$groupLabel", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { ids, getAttrs: getAttrs2 } = getCtx23();
  const { groupLabel, id: groupId } = getGroupLabel3();
  const attrs = getAttrs2("label");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.label.set(id());
    }
  });
  legacy_pre_effect(() => $groupLabel(), () => {
    set(builder, $groupLabel()(groupId));
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2131();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Select_label);
  const filename = Select_label.filename;
  const $$original = Select_label;
  Select_label = hmr(s);
  Select_label.filename = filename;
  Select_label[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var select_label_default = Select_label;
mark_module_end(Select_label);

// node_modules/bits-ui/dist/bits/select/components/select-trigger.svelte
mark_module_start();
Select_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-trigger.svelte";
var root_2132 = add_locations(template(`<button><!></button>`), Select_trigger[FILENAME], [[27, 1]]);
function Select_trigger($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Select_trigger);
  const $$stores = setup_stores();
  const $trigger = () => (validate_store(trigger, "trigger"), store_get(trigger, "$trigger", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { trigger }, ids, getAttrs: getAttrs2 } = getCtx23();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("trigger");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.trigger.set(id());
    }
  });
  legacy_pre_effect(() => $trigger(), () => {
    set(builder, $trigger());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_2132();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Select_trigger);
  const filename = Select_trigger.filename;
  const $$original = Select_trigger;
  Select_trigger = hmr(s);
  Select_trigger.filename = filename;
  Select_trigger[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var select_trigger_default = Select_trigger;
mark_module_end(Select_trigger);

// node_modules/bits-ui/dist/bits/select/components/select-value.svelte
mark_module_start();
Select_value[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-value.svelte";
var root_2133 = add_locations(template(`<span> </span>`), Select_value[FILENAME], [[17, 1]]);
function Select_value($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["placeholder", "asChild", "el"]);
  push($$props, false, Select_value);
  const $$stores = setup_stores();
  const $selectedLabel = () => (validate_store(selectedLabel, "selectedLabel"), store_get(selectedLabel, "$selectedLabel", $$stores));
  const label = mutable_source();
  let placeholder = prop($$props, "placeholder", 0, "");
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { states: { selectedLabel }, getAttrs: getAttrs2 } = getCtx23();
  const attrs = getAttrs2("value");
  legacy_pre_effect(() => $selectedLabel(), () => {
    set(label, $selectedLabel());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get label() {
            return get2(label);
          },
          attrs
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_2133();
      bind_this(span, ($$value) => el($$value), () => el());
      let attributes;
      var text2 = child(span);
      reset(span);
      template_effect(() => {
        attributes = set_attributes(
          span,
          attributes,
          {
            ...$$restProps,
            ...attrs,
            "data-placeholder": !get2(label) ? "" : void 0
          },
          true,
          ""
        );
        set_text(text2, get2(label) || placeholder());
      });
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Select_value);
  const filename = Select_value.filename;
  const $$original = Select_value;
  Select_value = hmr(s);
  Select_value.filename = filename;
  Select_value[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var select_value_default = Select_value;
mark_module_end(Select_value);

// node_modules/bits-ui/dist/bits/separator/index.js
var separator_exports = {};
__export(separator_exports, {
  Root: () => separator_default
});

// node_modules/bits-ui/dist/bits/slider/index.js
var slider_exports = {};
__export(slider_exports, {
  Input: () => slider_input_default,
  Range: () => slider_range_default,
  Root: () => slider_default,
  Thumb: () => slider_thumb_default,
  Tick: () => slider_tick_default
});

// node_modules/bits-ui/dist/bits/slider/ctx.js
function getSliderData() {
  const NAME = "slider";
  const PARTS = ["root", "input", "range", "thumb", "tick"];
  return {
    NAME,
    PARTS
  };
}
function setCtx26(props) {
  const { NAME, PARTS } = getSliderData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const slider = { ...createSlider(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(NAME, slider);
  return {
    ...slider,
    updateOption: getOptionUpdater(slider.options)
  };
}
function getCtx24() {
  const { NAME } = getSliderData();
  return getContext(NAME);
}

// node_modules/bits-ui/dist/bits/slider/components/slider.svelte
mark_module_start();
Slider[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider.svelte";
var root_326 = add_locations(template(`<span><!></span>`), Slider[FILENAME], [[58, 1]]);
function Slider($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "disabled",
    "min",
    "max",
    "step",
    "orientation",
    "dir",
    "value",
    "onValueChange",
    "asChild",
    "el"
  ]);
  push($$props, false, Slider);
  const $$stores = setup_stores();
  const $root = () => (validate_store(root5, "root"), store_get(root5, "$root", $$stores));
  const $ticks = () => (validate_store(ticks, "ticks"), store_get(ticks, "$ticks", $$stores));
  const $thumbs = () => (validate_store(thumbs, "thumbs"), store_get(thumbs, "$thumbs", $$stores));
  const builder = mutable_source();
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let min = prop($$props, "min", 8, () => void 0);
  let max = prop($$props, "max", 8, () => void 0);
  let step = prop($$props, "step", 8, () => void 0);
  let orientation = prop($$props, "orientation", 8, () => void 0);
  let dir = prop($$props, "dir", 8, () => void 0);
  let value = prop($$props, "value", 12, () => void 0);
  let onValueChange = prop($$props, "onValueChange", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { root: root5, ticks, thumbs },
    states: { value: localValue },
    updateOption,
    getAttrs: getAttrs2
  } = setCtx26({
    disabled: disabled(),
    dir: dir(),
    min: min(),
    max: max(),
    step: step(),
    orientation: orientation(),
    defaultValue: value(),
    onValueChange: ({ next: next2 }) => {
      var _a;
      if (value() !== next2) {
        (_a = onValueChange()) == null ? void 0 : _a(next2);
        value(next2);
      }
      return next2;
    }
  });
  const attrs = getAttrs2("root");
  legacy_pre_effect(() => deep_read_state(value()), () => {
    value() !== void 0 && localValue.set(value());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => deep_read_state(min()), () => {
    updateOption("min", min());
  });
  legacy_pre_effect(() => deep_read_state(max()), () => {
    updateOption("max", max());
  });
  legacy_pre_effect(() => deep_read_state(step()), () => {
    updateOption("step", step());
  });
  legacy_pre_effect(() => deep_read_state(orientation()), () => {
    updateOption("orientation", orientation());
  });
  legacy_pre_effect(() => deep_read_state(dir()), () => {
    updateOption("dir", dir());
  });
  legacy_pre_effect(() => $root(), () => {
    set(builder, $root());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get ticks() {
            return $ticks();
          },
          get thumbs() {
            return $thumbs();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_326();
      bind_this(span, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(span);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get ticks() {
            return $ticks();
          },
          get thumbs() {
            return $thumbs();
          }
        },
        null
      );
      reset(span);
      template_effect(() => attributes = set_attributes(span, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(span, ($$node) => get2(builder).action($$node));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Slider);
  const filename = Slider.filename;
  const $$original = Slider;
  Slider = hmr(s);
  Slider.filename = filename;
  Slider[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var slider_default = Slider;
mark_module_end(Slider);

// node_modules/bits-ui/dist/bits/slider/components/slider-range.svelte
mark_module_start();
Slider_range[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider-range.svelte";
var root_2134 = add_locations(template(`<span></span>`), Slider_range[FILENAME], [[19, 1]]);
function Slider_range($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Slider_range);
  const $$stores = setup_stores();
  const $range = () => (validate_store(range, "range"), store_get(range, "$range", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { range }, getAttrs: getAttrs2 } = getCtx24();
  const attrs = getAttrs2("range");
  legacy_pre_effect(() => $range(), () => {
    set(builder, $range());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_2134();
      bind_this(span, ($$value) => el($$value), () => el());
      let attributes;
      template_effect(() => attributes = set_attributes(span, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(span, ($$node) => get2(builder).action($$node));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Slider_range);
  const filename = Slider_range.filename;
  const $$original = Slider_range;
  Slider_range = hmr(s);
  Slider_range.filename = filename;
  Slider_range[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var slider_range_default = Slider_range;
mark_module_end(Slider_range);

// node_modules/bits-ui/dist/bits/slider/components/slider-thumb.svelte
mark_module_start();
Slider_thumb[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider-thumb.svelte";
var root_2135 = add_locations(template(`<span></span>`), Slider_thumb[FILENAME], [[19, 1]]);
function Slider_thumb($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el", "thumb"]);
  push($$props, false, Slider_thumb);
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  let thumb = prop($$props, "thumb");
  const { getAttrs: getAttrs2 } = getCtx24();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("thumb");
  legacy_pre_effect(() => deep_read_state(thumb()), () => {
    set(builder, thumb());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_2135();
      bind_this(span, ($$value) => el($$value), () => el());
      let attributes;
      template_effect(() => attributes = set_attributes(span, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(span, ($$node) => get2(builder).action($$node));
      event("m-keydown", span, dispatch, false);
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Slider_thumb);
  const filename = Slider_thumb.filename;
  const $$original = Slider_thumb;
  Slider_thumb = hmr(s);
  Slider_thumb.filename = filename;
  Slider_thumb[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var slider_thumb_default = Slider_thumb;
mark_module_end(Slider_thumb);

// node_modules/bits-ui/dist/bits/slider/components/slider-input.svelte
mark_module_start();
Slider_input[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider-input.svelte";
var root3 = add_locations(template(`<input>`), Slider_input[FILENAME], [[23, 0]]);
function Slider_input($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["el"]);
  push($$props, false, Slider_input);
  const $$stores = setup_stores();
  const $value = () => (validate_store(value, "value"), store_get(value, "$value", $$stores));
  const inputValue = mutable_source();
  let el = prop($$props, "el", 12, () => void 0);
  const { states: { value }, getAttrs: getAttrs2 } = getCtx24();
  function getValue(value2) {
    if (value2.length === 1) {
      return value2[0];
    } else if (value2.length === 2) {
      return value2[1] - value2[0];
    }
  }
  const attrs = {
    ...getAttrs2("input"),
    style: getSrOnlyStyles()
  };
  legacy_pre_effect(() => $value(), () => {
    set(inputValue, getValue($value()));
  });
  legacy_pre_effect_reset();
  init();
  var input = root3();
  bind_this(input, ($$value) => el($$value), () => el());
  remove_input_defaults(input);
  let attributes;
  template_effect(() => attributes = set_attributes(
    input,
    attributes,
    {
      ...$$restProps,
      value: get2(inputValue),
      ...attrs
    },
    true,
    ""
  ));
  append($$anchor, input);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Slider_input);
  const filename = Slider_input.filename;
  const $$original = Slider_input;
  Slider_input = hmr(s);
  Slider_input.filename = filename;
  Slider_input[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var slider_input_default = Slider_input;
mark_module_end(Slider_input);

// node_modules/bits-ui/dist/bits/slider/components/slider-tick.svelte
mark_module_start();
Slider_tick[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider-tick.svelte";
var root_2136 = add_locations(template(`<span></span>`), Slider_tick[FILENAME], [[17, 1]]);
function Slider_tick($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el", "tick"]);
  push($$props, false, Slider_tick);
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  let tick2 = prop($$props, "tick");
  const { getAttrs: getAttrs2 } = getCtx24();
  const attrs = getAttrs2("tick");
  legacy_pre_effect(() => deep_read_state(tick2()), () => {
    set(builder, tick2());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_2136();
      bind_this(span, ($$value) => el($$value), () => el());
      let attributes;
      template_effect(() => attributes = set_attributes(span, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(span, ($$node) => get2(builder).action($$node));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Slider_tick);
  const filename = Slider_tick.filename;
  const $$original = Slider_tick;
  Slider_tick = hmr(s);
  Slider_tick.filename = filename;
  Slider_tick[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var slider_tick_default = Slider_tick;
mark_module_end(Slider_tick);

// node_modules/bits-ui/dist/bits/switch/index.js
var switch_exports = {};
__export(switch_exports, {
  Input: () => switch_input_default,
  Root: () => switch_default,
  Thumb: () => switch_thumb_default
});

// node_modules/bits-ui/dist/bits/switch/ctx.js
function getSwitchData() {
  const NAME = "switch";
  const PARTS = ["root", "input", "thumb"];
  return {
    NAME,
    PARTS
  };
}
function setCtx27(props) {
  const { NAME, PARTS } = getSwitchData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const Switch2 = { ...createSwitch(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(NAME, Switch2);
  return {
    ...Switch2,
    updateOption: getOptionUpdater(Switch2.options)
  };
}
function getCtx25() {
  const { NAME } = getSwitchData();
  return getContext(NAME);
}

// node_modules/bits-ui/dist/bits/switch/components/switch-input.svelte
mark_module_start();
Switch_input[FILENAME] = "node_modules/bits-ui/dist/bits/switch/components/switch-input.svelte";
var root4 = add_locations(template(`<input>`), Switch_input[FILENAME], [[12, 0]]);
function Switch_input($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["el"]);
  push($$props, false, Switch_input);
  const $$stores = setup_stores();
  const $value = () => (validate_store(value, "value"), store_get(value, "$value", $$stores));
  const $input = () => (validate_store(input, "input"), store_get(input, "$input", $$stores));
  const $name = () => (validate_store(name27, "name"), store_get(name27, "$name", $$stores));
  const $disabled = () => (validate_store(disabled, "disabled"), store_get(disabled, "$disabled", $$stores));
  const $required = () => (validate_store(required, "required"), store_get(required, "$required", $$stores));
  const inputValue = mutable_source();
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { input },
    options: { value, name: name27, disabled, required }
  } = getCtx25();
  legacy_pre_effect(() => $value(), () => {
    set(inputValue, $value() === void 0 || $value() === "" ? "on" : $value());
  });
  legacy_pre_effect_reset();
  init();
  var input_1 = root4();
  bind_this(input_1, ($$value) => el($$value), () => el());
  remove_input_defaults(input_1);
  let attributes;
  template_effect(() => attributes = set_attributes(
    input_1,
    attributes,
    {
      ...$input(),
      name: $name(),
      disabled: $disabled(),
      required: $required(),
      value: get2(inputValue),
      ...$$restProps
    },
    true,
    ""
  ));
  action(input_1, ($$node) => $input().action($$node));
  append($$anchor, input_1);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Switch_input);
  const filename = Switch_input.filename;
  const $$original = Switch_input;
  Switch_input = hmr(s);
  Switch_input.filename = filename;
  Switch_input[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var switch_input_default = Switch_input;
mark_module_end(Switch_input);

// node_modules/bits-ui/dist/bits/switch/components/switch.svelte
mark_module_start();
Switch[FILENAME] = "node_modules/bits-ui/dist/bits/switch/components/switch.svelte";
var root_327 = add_locations(template(`<button><!></button>`), Switch[FILENAME], [[56, 1]]);
var root_1 = add_locations(template(`<!> <!>`, 1), Switch[FILENAME], []);
function Switch($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "checked",
    "onCheckedChange",
    "disabled",
    "name",
    "value",
    "includeInput",
    "required",
    "asChild",
    "inputAttrs",
    "el"
  ]);
  push($$props, false, Switch);
  const $$stores = setup_stores();
  const $root = () => (validate_store(root5, "root"), store_get(root5, "$root", $$stores));
  const builder = mutable_source();
  const attrs = mutable_source();
  let checked = prop($$props, "checked", 12, () => void 0);
  let onCheckedChange = prop($$props, "onCheckedChange", 8, () => void 0);
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let name27 = prop($$props, "name", 8, () => void 0);
  let value = prop($$props, "value", 8, () => void 0);
  let includeInput = prop($$props, "includeInput", 0, true);
  let required = prop($$props, "required", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let inputAttrs = prop($$props, "inputAttrs", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { root: root5 },
    states: { checked: localChecked },
    updateOption,
    getAttrs: getAttrs2
  } = setCtx27({
    disabled: disabled(),
    name: name27(),
    value: value(),
    required: required(),
    defaultChecked: checked(),
    onCheckedChange: ({ next: next2 }) => {
      var _a;
      if (checked() !== next2) {
        (_a = onCheckedChange()) == null ? void 0 : _a(next2);
        checked(next2);
      }
      return next2;
    }
  });
  const dispatch = createDispatcher();
  legacy_pre_effect(() => deep_read_state(checked()), () => {
    checked() !== void 0 && localChecked.set(checked());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => deep_read_state(name27()), () => {
    updateOption("name", name27());
  });
  legacy_pre_effect(() => deep_read_state(value()), () => {
    updateOption("value", value());
  });
  legacy_pre_effect(() => deep_read_state(required()), () => {
    updateOption("required", required());
  });
  legacy_pre_effect(() => $root(), () => {
    set(builder, $root());
  });
  legacy_pre_effect(() => deep_read_state(checked()), () => {
    set(attrs, {
      ...getAttrs2("root"),
      "data-checked": checked() ? "" : void 0
    });
  });
  legacy_pre_effect(() => (get2(builder), get2(attrs)), () => {
    Object.assign(get2(builder), get2(attrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = root_1();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_327();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  var node_3 = sibling(sibling(node, true));
  if_block(node_3, includeInput, ($$anchor2) => {
    var fragment_2 = comment();
    var node_4 = first_child(fragment_2);
    validate_component(switch_input_default)(node_4, spread_props(inputAttrs, { $$legacy: true }));
    append($$anchor2, fragment_2);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Switch);
  const filename = Switch.filename;
  const $$original = Switch;
  Switch = hmr(s);
  Switch.filename = filename;
  Switch[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var switch_default = Switch;
mark_module_end(Switch);

// node_modules/bits-ui/dist/bits/switch/components/switch-thumb.svelte
mark_module_start();
Switch_thumb[FILENAME] = "node_modules/bits-ui/dist/bits/switch/components/switch-thumb.svelte";
var root_2137 = add_locations(template(`<span></span>`), Switch_thumb[FILENAME], [[19, 1]]);
function Switch_thumb($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Switch_thumb);
  const $$stores = setup_stores();
  const $checked = () => (validate_store(checked, "checked"), store_get(checked, "$checked", $$stores));
  const attrs = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { states: { checked }, getAttrs: getAttrs2 } = getCtx25();
  legacy_pre_effect(() => $checked(), () => {
    set(attrs, {
      ...getAttrs2("thumb"),
      "data-state": $checked() ? "checked" : "unchecked",
      "data-checked": $checked() ? "" : void 0
    });
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get attrs() {
            return get2(attrs);
          },
          get checked() {
            return $checked();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_2137();
      bind_this(span, ($$value) => el($$value), () => el());
      let attributes;
      template_effect(() => attributes = set_attributes(span, attributes, { ...$$restProps, ...get2(attrs) }, true, ""));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Switch_thumb);
  const filename = Switch_thumb.filename;
  const $$original = Switch_thumb;
  Switch_thumb = hmr(s);
  Switch_thumb.filename = filename;
  Switch_thumb[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var switch_thumb_default = Switch_thumb;
mark_module_end(Switch_thumb);

// node_modules/bits-ui/dist/bits/tabs/index.js
var tabs_exports = {};
__export(tabs_exports, {
  Content: () => tabs_content_default,
  List: () => tabs_list_default,
  Root: () => tabs_default,
  Trigger: () => tabs_trigger_default
});

// node_modules/bits-ui/dist/bits/tabs/ctx.js
function getTabsData() {
  const NAME = "tabs";
  const PARTS = ["root", "content", "list", "trigger"];
  return {
    NAME,
    PARTS
  };
}
function setCtx28(props) {
  const { NAME, PARTS } = getTabsData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const tabs = { ...createTabs(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(NAME, tabs);
  return {
    ...tabs,
    updateOption: getOptionUpdater(tabs.options)
  };
}
function getCtx26() {
  const { NAME } = getTabsData();
  return getContext(NAME);
}

// node_modules/bits-ui/dist/bits/tabs/components/tabs.svelte
mark_module_start();
Tabs[FILENAME] = "node_modules/bits-ui/dist/bits/tabs/components/tabs.svelte";
var root_328 = add_locations(template(`<div><!></div>`), Tabs[FILENAME], [[50, 1]]);
function Tabs($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "orientation",
    "activateOnFocus",
    "loop",
    "autoSet",
    "value",
    "onValueChange",
    "asChild",
    "el"
  ]);
  push($$props, false, Tabs);
  const $$stores = setup_stores();
  const $root = () => (validate_store(root5, "root"), store_get(root5, "$root", $$stores));
  const $localValue = () => (validate_store(localValue, "localValue"), store_get(localValue, "$localValue", $$stores));
  const builder = mutable_source();
  let orientation = prop($$props, "orientation", 8, () => void 0);
  let activateOnFocus = prop($$props, "activateOnFocus", 8, () => void 0);
  let loop = prop($$props, "loop", 8, () => void 0);
  let autoSet = prop($$props, "autoSet", 8, () => void 0);
  let value = prop($$props, "value", 12, () => void 0);
  let onValueChange = prop($$props, "onValueChange", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { root: root5 },
    states: { value: localValue },
    updateOption,
    getAttrs: getAttrs2
  } = setCtx28({
    orientation: orientation(),
    activateOnFocus: activateOnFocus(),
    loop: loop(),
    autoSet: autoSet(),
    defaultValue: value(),
    onValueChange: ({ next: next2 }) => {
      var _a;
      if (value() !== next2) {
        (_a = onValueChange()) == null ? void 0 : _a(next2);
        value(next2);
      }
      return next2;
    }
  });
  const attrs = getAttrs2("root");
  legacy_pre_effect(() => deep_read_state(value()), () => {
    value() !== void 0 && localValue.set(value());
  });
  legacy_pre_effect(() => deep_read_state(orientation()), () => {
    updateOption("orientation", orientation());
  });
  legacy_pre_effect(() => deep_read_state(activateOnFocus()), () => {
    updateOption("activateOnFocus", activateOnFocus());
  });
  legacy_pre_effect(() => deep_read_state(loop()), () => {
    updateOption("loop", loop());
  });
  legacy_pre_effect(() => deep_read_state(autoSet()), () => {
    updateOption("autoSet", autoSet());
  });
  legacy_pre_effect(() => $root(), () => {
    set(builder, $root());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get value() {
            return $localValue();
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_328();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          },
          get value() {
            return $localValue();
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Tabs);
  const filename = Tabs.filename;
  const $$original = Tabs;
  Tabs = hmr(s);
  Tabs.filename = filename;
  Tabs[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var tabs_default = Tabs;
mark_module_end(Tabs);

// node_modules/bits-ui/dist/bits/tabs/components/tabs-content.svelte
mark_module_start();
Tabs_content[FILENAME] = "node_modules/bits-ui/dist/bits/tabs/components/tabs-content.svelte";
var root_2138 = add_locations(template(`<div><!></div>`), Tabs_content[FILENAME], [[20, 1]]);
function Tabs_content($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["value", "asChild", "el"]);
  push($$props, false, Tabs_content);
  const $$stores = setup_stores();
  const $content = () => (validate_store(content, "content"), store_get(content, "$content", $$stores));
  const builder = mutable_source();
  let value = prop($$props, "value");
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { content }, getAttrs: getAttrs2 } = getCtx26();
  const attrs = getAttrs2("content");
  legacy_pre_effect(
    () => ($content(), deep_read_state(value())),
    () => {
      set(builder, $content()(value()));
    }
  );
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2138();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Tabs_content);
  const filename = Tabs_content.filename;
  const $$original = Tabs_content;
  Tabs_content = hmr(s);
  Tabs_content.filename = filename;
  Tabs_content[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var tabs_content_default = Tabs_content;
mark_module_end(Tabs_content);

// node_modules/bits-ui/dist/bits/tabs/components/tabs-list.svelte
mark_module_start();
Tabs_list[FILENAME] = "node_modules/bits-ui/dist/bits/tabs/components/tabs-list.svelte";
var root_2139 = add_locations(template(`<div><!></div>`), Tabs_list[FILENAME], [[19, 1]]);
function Tabs_list($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Tabs_list);
  const $$stores = setup_stores();
  const $list = () => (validate_store(list, "list"), store_get(list, "$list", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { list }, getAttrs: getAttrs2 } = getCtx26();
  const attrs = getAttrs2("list");
  legacy_pre_effect(() => $list(), () => {
    set(builder, $list());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2139();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Tabs_list);
  const filename = Tabs_list.filename;
  const $$original = Tabs_list;
  Tabs_list = hmr(s);
  Tabs_list.filename = filename;
  Tabs_list[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var tabs_list_default = Tabs_list;
mark_module_end(Tabs_list);

// node_modules/bits-ui/dist/bits/tabs/components/tabs-trigger.svelte
mark_module_start();
Tabs_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/tabs/components/tabs-trigger.svelte";
var root_2140 = add_locations(template(`<button><!></button>`), Tabs_trigger[FILENAME], [[23, 1]]);
function Tabs_trigger($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["value", "disabled", "asChild", "el"]);
  push($$props, false, Tabs_trigger);
  const $$stores = setup_stores();
  const $trigger = () => (validate_store(trigger, "trigger"), store_get(trigger, "$trigger", $$stores));
  const builder = mutable_source();
  let value = prop($$props, "value");
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { trigger }, getAttrs: getAttrs2 } = getCtx26();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("trigger");
  legacy_pre_effect(
    () => ($trigger(), deep_read_state(value()), deep_read_state(disabled())),
    () => {
      set(builder, $trigger()({ value: value(), disabled: disabled() }));
    }
  );
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_2140();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-focus", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Tabs_trigger);
  const filename = Tabs_trigger.filename;
  const $$original = Tabs_trigger;
  Tabs_trigger = hmr(s);
  Tabs_trigger.filename = filename;
  Tabs_trigger[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var tabs_trigger_default = Tabs_trigger;
mark_module_end(Tabs_trigger);

// node_modules/bits-ui/dist/bits/toggle/index.js
var toggle_exports = {};
__export(toggle_exports, {
  Root: () => toggle_default
});

// node_modules/bits-ui/dist/bits/toggle/ctx.js
function getToggleData() {
  const NAME = "toggle";
  const PARTS = ["root", "input"];
  return {
    NAME,
    PARTS
  };
}
function setCtx29(props) {
  const { NAME, PARTS } = getToggleData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const toggle2 = { ...createToggle(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(NAME, toggle2);
  return {
    ...toggle2,
    updateOption: getOptionUpdater(toggle2.options)
  };
}

// node_modules/bits-ui/dist/bits/toggle/components/toggle.svelte
mark_module_start();
Toggle[FILENAME] = "node_modules/bits-ui/dist/bits/toggle/components/toggle.svelte";
var root_329 = add_locations(template(`<button><!></button>`), Toggle[FILENAME], [[40, 1]]);
function Toggle($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "disabled",
    "pressed",
    "onPressedChange",
    "asChild",
    "el"
  ]);
  push($$props, false, Toggle);
  const $$stores = setup_stores();
  const $root = () => (validate_store(root5, "root"), store_get(root5, "$root", $$stores));
  const builder = mutable_source();
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let pressed = prop($$props, "pressed", 12, () => void 0);
  let onPressedChange = prop($$props, "onPressedChange", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { root: root5 },
    states: { pressed: localPressed },
    updateOption,
    getAttrs: getAttrs2
  } = setCtx29({
    disabled: disabled(),
    defaultPressed: pressed(),
    onPressedChange: ({ next: next2 }) => {
      var _a;
      if (pressed() !== next2) {
        (_a = onPressedChange()) == null ? void 0 : _a(next2);
        pressed(next2);
      }
      return next2;
    }
  });
  const dispatch = createDispatcher();
  const attrs = getAttrs2("root");
  legacy_pre_effect(() => deep_read_state(pressed()), () => {
    pressed() !== void 0 && localPressed.set(pressed());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => $root(), () => {
    set(builder, $root());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_329();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Toggle);
  const filename = Toggle.filename;
  const $$original = Toggle;
  Toggle = hmr(s);
  Toggle.filename = filename;
  Toggle[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var toggle_default = Toggle;
mark_module_end(Toggle);

// node_modules/bits-ui/dist/bits/toggle-group/index.js
var toggle_group_exports = {};
__export(toggle_group_exports, {
  Item: () => toggle_group_item_default,
  Root: () => toggle_group_default
});

// node_modules/bits-ui/dist/bits/toggle-group/ctx.js
function getToggleGroupData() {
  const NAME = "toggle-group";
  const PARTS = ["root", "item"];
  return {
    NAME,
    PARTS
  };
}
function setCtx30(props) {
  const { NAME, PARTS } = getToggleGroupData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const toggleGroup = { ...createToggleGroup(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(NAME, toggleGroup);
  return {
    ...toggleGroup,
    updateOption: getOptionUpdater(toggleGroup.options)
  };
}
function getCtx27() {
  const { NAME } = getToggleGroupData();
  return getContext(NAME);
}

// node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group.svelte
mark_module_start();
Toggle_group[FILENAME] = "node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group.svelte";
var root_330 = add_locations(template(`<div><!></div>`), Toggle_group[FILENAME], [[59, 1]]);
function Toggle_group($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "type",
    "disabled",
    "loop",
    "value",
    "orientation",
    "onValueChange",
    "asChild",
    "el"
  ]);
  push($$props, false, Toggle_group);
  const $$stores = setup_stores();
  const $root = () => (validate_store(root5, "root"), store_get(root5, "$root", $$stores));
  const builder = mutable_source();
  let type = prop($$props, "type", 0, "single");
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let loop = prop($$props, "loop", 8, () => void 0);
  let value = prop($$props, "value", 12, () => void 0);
  let orientation = prop($$props, "orientation", 8, () => void 0);
  let onValueChange = prop($$props, "onValueChange", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { root: root5 },
    states: { value: localValue },
    updateOption,
    getAttrs: getAttrs2
  } = setCtx30({
    disabled: disabled(),
    type: type(),
    defaultValue: value(),
    loop: loop(),
    orientation: orientation(),
    onValueChange: ({ next: next2 }) => {
      var _a, _b;
      if (Array.isArray(next2)) {
        if (!Array.isArray(value()) || !arraysAreEqual(value(), next2)) {
          (_a = onValueChange()) == null ? void 0 : _a(next2);
          value(next2);
          return next2;
        }
        return next2;
      }
      if (value() !== next2) {
        (_b = onValueChange()) == null ? void 0 : _b(next2);
        value(next2);
      }
      return next2;
    }
  });
  const attrs = getAttrs2("root");
  legacy_pre_effect(() => deep_read_state(value()), () => {
    value() !== void 0 && localValue.set(Array.isArray(value()) ? [...value()] : value());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => deep_read_state(loop()), () => {
    updateOption("loop", loop());
  });
  legacy_pre_effect(() => deep_read_state(type()), () => {
    updateOption("type", type());
  });
  legacy_pre_effect(() => deep_read_state(orientation()), () => {
    updateOption("orientation", orientation());
  });
  legacy_pre_effect(() => $root(), () => {
    set(builder, $root());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_330();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Toggle_group);
  const filename = Toggle_group.filename;
  const $$original = Toggle_group;
  Toggle_group = hmr(s);
  Toggle_group.filename = filename;
  Toggle_group[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var toggle_group_default = Toggle_group;
mark_module_end(Toggle_group);

// node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group-item.svelte
mark_module_start();
Toggle_group_item[FILENAME] = "node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group-item.svelte";
var root_2141 = add_locations(template(`<button><!></button>`), Toggle_group_item[FILENAME], [[23, 1]]);
function Toggle_group_item($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["value", "disabled", "asChild", "el"]);
  push($$props, false, Toggle_group_item);
  const $$stores = setup_stores();
  const $item = () => (validate_store(item, "item"), store_get(item, "$item", $$stores));
  const builder = mutable_source();
  let value = prop($$props, "value");
  let disabled = prop($$props, "disabled", 0, false);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { item }, getAttrs: getAttrs2 } = getCtx27();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("item");
  legacy_pre_effect(
    () => ($item(), deep_read_state(value()), deep_read_state(disabled())),
    () => {
      set(builder, $item()({ value: value(), disabled: disabled() }));
    }
  );
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_2141();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Toggle_group_item);
  const filename = Toggle_group_item.filename;
  const $$original = Toggle_group_item;
  Toggle_group_item = hmr(s);
  Toggle_group_item.filename = filename;
  Toggle_group_item[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var toggle_group_item_default = Toggle_group_item;
mark_module_end(Toggle_group_item);

// node_modules/bits-ui/dist/bits/toolbar/index.js
var toolbar_exports = {};
__export(toolbar_exports, {
  Button: () => toolbar_button_default,
  Group: () => toolbar_group_default,
  GroupItem: () => toolbar_group_item_default,
  Link: () => toolbar_link_default,
  Root: () => toolbar_default
});

// node_modules/bits-ui/dist/bits/toolbar/ctx.js
function getToolbarData() {
  const NAME = "toolbar";
  const GROUP_NAME = "toolbar-group";
  const PARTS = ["root", "button", "link", "group", "group-item"];
  return {
    NAME,
    GROUP_NAME,
    PARTS
  };
}
function setCtx31(props) {
  const { NAME, PARTS } = getToolbarData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const toolbar = { ...createToolbar(removeUndefined2(props)), getAttrs: getAttrs2 };
  setContext(NAME, toolbar);
  return {
    ...toolbar,
    updateOption: getOptionUpdater(toolbar.options)
  };
}
function setGroupCtx4(props) {
  const { builders: { createToolbarGroup }, getAttrs: getAttrs2 } = getCtx28();
  const group = { ...createToolbarGroup(removeUndefined2(props)), getAttrs: getAttrs2 };
  const { GROUP_NAME } = getToolbarData();
  setContext(GROUP_NAME, group);
  return {
    ...group,
    updateOption: getOptionUpdater(group.options)
  };
}
function getCtx28() {
  const { NAME } = getToolbarData();
  return getContext(NAME);
}
function getGroupCtx() {
  const { GROUP_NAME } = getToolbarData();
  return getContext(GROUP_NAME);
}

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar.svelte
mark_module_start();
Toolbar[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar.svelte";
var root_331 = add_locations(template(`<div><!></div>`), Toolbar[FILENAME], [[29, 1]]);
function Toolbar($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["loop", "orientation", "asChild", "el"]);
  push($$props, false, Toolbar);
  const $$stores = setup_stores();
  const $root = () => (validate_store(root5, "root"), store_get(root5, "$root", $$stores));
  const builder = mutable_source();
  let loop = prop($$props, "loop", 0, true);
  let orientation = prop($$props, "orientation", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { root: root5 }, updateOption, getAttrs: getAttrs2 } = setCtx31({
    loop: loop(),
    orientation: orientation()
  });
  const attrs = getAttrs2("root");
  legacy_pre_effect(() => deep_read_state(loop()), () => {
    updateOption("loop", loop());
  });
  legacy_pre_effect(() => deep_read_state(orientation()), () => {
    updateOption("orientation", orientation());
  });
  legacy_pre_effect(() => $root(), () => {
    set(builder, $root());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_331();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Toolbar);
  const filename = Toolbar.filename;
  const $$original = Toolbar;
  Toolbar = hmr(s);
  Toolbar.filename = filename;
  Toolbar[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var toolbar_default = Toolbar;
mark_module_end(Toolbar);

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-button.svelte
mark_module_start();
Toolbar_button[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar-button.svelte";
var root_2142 = add_locations(template(`<button><!></button>`), Toolbar_button[FILENAME], [[21, 1]]);
function Toolbar_button($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Toolbar_button);
  const $$stores = setup_stores();
  const $button = () => (validate_store(button, "button"), store_get(button, "$button", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { button }, getAttrs: getAttrs2 } = getCtx28();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("button");
  legacy_pre_effect(() => $button(), () => {
    set(builder, $button());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button_1 = root_2142();
      bind_this(button_1, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button_1);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button_1);
      template_effect(() => attributes = set_attributes(
        button_1,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button_1, ($$node) => get2(builder).action($$node));
      event("click", button_1, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event("m-keydown", button_1, dispatch, false);
      append($$anchor2, button_1);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Toolbar_button);
  const filename = Toolbar_button.filename;
  const $$original = Toolbar_button;
  Toolbar_button = hmr(s);
  Toolbar_button.filename = filename;
  Toolbar_button[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var toolbar_button_default = Toolbar_button;
mark_module_end(Toolbar_button);

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-link.svelte
mark_module_start();
Toolbar_link[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar-link.svelte";
var root_2143 = add_locations(template(`<a><!></a>`), Toolbar_link[FILENAME], [[23, 1]]);
function Toolbar_link($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "el"]);
  push($$props, false, Toolbar_link);
  const $$stores = setup_stores();
  const $link = () => (validate_store(link, "link"), store_get(link, "$link", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { link }, getAttrs: getAttrs2 } = getCtx28();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("link");
  legacy_pre_effect(() => $link(), () => {
    set(builder, $link());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var a = root_2143();
      bind_this(a, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(a);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(a);
      template_effect(() => attributes = set_attributes(a, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(a, ($$node) => get2(builder).action($$node));
      event("click", a, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event("m-keydown", a, dispatch, false);
      append($$anchor2, a);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Toolbar_link);
  const filename = Toolbar_link.filename;
  const $$original = Toolbar_link;
  Toolbar_link = hmr(s);
  Toolbar_link.filename = filename;
  Toolbar_link[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var toolbar_link_default = Toolbar_link;
mark_module_end(Toolbar_link);

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group.svelte
mark_module_start();
Toolbar_group[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group.svelte";
var root_2144 = add_locations(template(`<div><!></div>`), Toolbar_group[FILENAME], [[51, 1]]);
function Toolbar_group($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "type",
    "disabled",
    "value",
    "onValueChange",
    "asChild",
    "el"
  ]);
  push($$props, false, Toolbar_group);
  const $$stores = setup_stores();
  const $group = () => (validate_store(group, "group"), store_get(group, "$group", $$stores));
  const builder = mutable_source();
  let type = prop($$props, "type", 0, "single");
  let disabled = prop($$props, "disabled", 8, () => void 0);
  let value = prop($$props, "value", 12, () => void 0);
  let onValueChange = prop($$props, "onValueChange", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { group },
    states: { value: localValue },
    updateOption,
    getAttrs: getAttrs2
  } = setGroupCtx4({
    disabled: disabled(),
    type: type(),
    defaultValue: value(),
    onValueChange: ({ next: next2 }) => {
      var _a, _b;
      if (Array.isArray(next2)) {
        if (!Array.isArray(value()) || !arraysAreEqual(value(), next2)) {
          (_a = onValueChange()) == null ? void 0 : _a(next2);
          value(next2);
          return next2;
        }
        return next2;
      }
      if (value() !== next2) {
        (_b = onValueChange()) == null ? void 0 : _b(next2);
        value(next2);
      }
      return next2;
    }
  });
  const attrs = getAttrs2("group");
  legacy_pre_effect(() => deep_read_state(value()), () => {
    value() !== void 0 && localValue.set(Array.isArray(value()) ? [...value()] : value());
  });
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    updateOption("disabled", disabled());
  });
  legacy_pre_effect(() => deep_read_state(type()), () => {
    updateOption("type", type());
  });
  legacy_pre_effect(() => $group(), () => {
    set(builder, $group());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2144();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(div);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Toolbar_group);
  const filename = Toolbar_group.filename;
  const $$original = Toolbar_group;
  Toolbar_group = hmr(s);
  Toolbar_group.filename = filename;
  Toolbar_group[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var toolbar_group_default = Toolbar_group;
mark_module_end(Toolbar_group);

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group-item.svelte
mark_module_start();
Toolbar_group_item[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group-item.svelte";
var root_2145 = add_locations(template(`<button><!></button>`), Toolbar_group_item[FILENAME], [[24, 1]]);
function Toolbar_group_item($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["value", "disabled", "asChild", "el"]);
  push($$props, false, Toolbar_group_item);
  const $$stores = setup_stores();
  const $item = () => (validate_store(item, "item"), store_get(item, "$item", $$stores));
  const attrs = mutable_source();
  const builder = mutable_source();
  let value = prop($$props, "value");
  let disabled = prop($$props, "disabled", 0, false);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { item }, getAttrs: getAttrs2 } = getGroupCtx();
  const dispatch = createDispatcher();
  legacy_pre_effect(() => deep_read_state(disabled()), () => {
    set(attrs, {
      ...getAttrs2("group-item"),
      ...disabledAttrs(disabled())
    });
  });
  legacy_pre_effect(
    () => ($item(), deep_read_state(value()), deep_read_state(disabled())),
    () => {
      set(builder, $item()({ value: value(), disabled: disabled() }));
    }
  );
  legacy_pre_effect(() => (get2(builder), get2(attrs)), () => {
    Object.assign(get2(builder), get2(attrs));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_2145();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-click", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Toolbar_group_item);
  const filename = Toolbar_group_item.filename;
  const $$original = Toolbar_group_item;
  Toolbar_group_item = hmr(s);
  Toolbar_group_item.filename = filename;
  Toolbar_group_item[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var toolbar_group_item_default = Toolbar_group_item;
mark_module_end(Toolbar_group_item);

// node_modules/bits-ui/dist/bits/tooltip/index.js
var tooltip_exports = {};
__export(tooltip_exports, {
  Arrow: () => tooltip_arrow_default,
  Content: () => tooltip_content_default,
  Root: () => tooltip_default,
  Trigger: () => tooltip_trigger_default
});

// node_modules/bits-ui/dist/bits/tooltip/ctx.js
function getTooltipData() {
  const NAME = "tooltip";
  const PARTS = ["arrow", "content", "trigger"];
  return {
    NAME,
    PARTS
  };
}
function setCtx32(props) {
  const { NAME, PARTS } = getTooltipData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const tooltip = {
    ...createTooltip({
      positioning: {
        placement: "top",
        gutter: 0
      },
      openDelay: 700,
      ...removeUndefined2(props),
      forceVisible: true
    }),
    getAttrs: getAttrs2
  };
  setContext(NAME, tooltip);
  return {
    ...tooltip,
    updateOption: getOptionUpdater(tooltip.options)
  };
}
function getCtx29() {
  const { NAME } = getTooltipData();
  return getContext(NAME);
}
function setArrow6(size2 = 8) {
  const tooltip = getCtx29();
  tooltip.options.arrowSize.set(size2);
  return tooltip;
}
function updatePositioning10(props) {
  const defaultPlacement = {
    side: "top",
    align: "center",
    sideOffset: 1
  };
  const withDefaults = { ...defaultPlacement, ...props };
  const { options: { positioning } } = getCtx29();
  const updater = getPositioningUpdater(positioning);
  updater({ ...withDefaults });
}

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip.svelte
mark_module_start();
Tooltip[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip.svelte";
function Tooltip($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Tooltip);
  const $$stores = setup_stores();
  const $idValues = () => (validate_store(idValues, "idValues"), store_get(idValues, "$idValues", $$stores));
  let closeOnEscape = prop($$props, "closeOnEscape", 8, () => void 0);
  let portal = prop($$props, "portal", 8, () => void 0);
  let closeOnPointerDown = prop($$props, "closeOnPointerDown", 8, () => void 0);
  let openDelay = prop($$props, "openDelay", 8, () => void 0);
  let closeDelay = prop($$props, "closeDelay", 8, () => void 0);
  let open = prop($$props, "open", 12, () => void 0);
  let onOpenChange = prop($$props, "onOpenChange", 8, () => void 0);
  let disableHoverableContent = prop($$props, "disableHoverableContent", 8, () => void 0);
  let group = prop($$props, "group", 8, () => void 0);
  const {
    states: { open: localOpen },
    updateOption,
    ids
  } = setCtx32({
    closeOnEscape: closeOnEscape(),
    portal: portal(),
    closeOnPointerDown: closeOnPointerDown(),
    openDelay: openDelay(),
    closeDelay: closeDelay(),
    forceVisible: true,
    defaultOpen: open(),
    disableHoverableContent: disableHoverableContent(),
    group: group(),
    onOpenChange: ({ next: next2 }) => {
      var _a;
      if (open() !== next2) {
        (_a = onOpenChange()) == null ? void 0 : _a(next2);
        open(next2);
      }
      return next2;
    },
    positioning: { gutter: 0, offset: { mainAxis: 1 } }
  });
  const idValues = derived([ids.content, ids.trigger], ([$contentId, $triggerId]) => ({ content: $contentId, trigger: $triggerId }));
  legacy_pre_effect(() => deep_read_state(open()), () => {
    open() !== void 0 && localOpen.set(open());
  });
  legacy_pre_effect(() => deep_read_state(closeOnEscape()), () => {
    updateOption("closeOnEscape", closeOnEscape());
  });
  legacy_pre_effect(() => deep_read_state(portal()), () => {
    updateOption("portal", portal());
  });
  legacy_pre_effect(
    () => deep_read_state(closeOnPointerDown()),
    () => {
      updateOption("closeOnPointerDown", closeOnPointerDown());
    }
  );
  legacy_pre_effect(() => deep_read_state(openDelay()), () => {
    updateOption("openDelay", openDelay());
  });
  legacy_pre_effect(() => deep_read_state(closeDelay()), () => {
    updateOption("closeDelay", closeDelay());
  });
  legacy_pre_effect(() => deep_read_state(group()), () => {
    updateOption("group", group());
  });
  legacy_pre_effect(
    () => deep_read_state(disableHoverableContent()),
    () => {
      updateOption("disableHoverableContent", disableHoverableContent());
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    default_slot($$props),
    {
      get ids() {
        return $idValues();
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Tooltip);
  const filename = Tooltip.filename;
  const $$original = Tooltip;
  Tooltip = hmr(s);
  Tooltip.filename = filename;
  Tooltip[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var tooltip_default = Tooltip;
mark_module_end(Tooltip);

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-content.svelte
mark_module_start();
Tooltip_content[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-content.svelte";
var root_332 = add_locations(template(`<div><!></div>`), Tooltip_content[FILENAME], [[61, 1]]);
var root_516 = add_locations(template(`<div><!></div>`), Tooltip_content[FILENAME], [[72, 1]]);
var root_716 = add_locations(template(`<div><!></div>`), Tooltip_content[FILENAME], [[84, 1]]);
var root_916 = add_locations(template(`<div><!></div>`), Tooltip_content[FILENAME], [[95, 1]]);
var root_1116 = add_locations(template(`<div><!></div>`), Tooltip_content[FILENAME], [[106, 1]]);
function Tooltip_content($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "side",
    "align",
    "sideOffset",
    "alignOffset",
    "collisionPadding",
    "avoidCollisions",
    "collisionBoundary",
    "sameWidth",
    "fitViewport",
    "strategy",
    "overlap",
    "el"
  ]);
  push($$props, false, Tooltip_content);
  const $$stores = setup_stores();
  const $content = () => (validate_store(content, "content"), store_get(content, "$content", $$stores));
  const $open = () => (validate_store(open, "open"), store_get(open, "$open", $$stores));
  const builder = mutable_source();
  let transition2 = prop($$props, "transition", 8, () => void 0);
  let transitionConfig = prop($$props, "transitionConfig", 8, () => void 0);
  let inTransition = prop($$props, "inTransition", 8, () => void 0);
  let inTransitionConfig = prop($$props, "inTransitionConfig", 8, () => void 0);
  let outTransition = prop($$props, "outTransition", 8, () => void 0);
  let outTransitionConfig = prop($$props, "outTransitionConfig", 8, () => void 0);
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let side = prop($$props, "side", 0, "top");
  let align = prop($$props, "align", 0, "center");
  let sideOffset = prop($$props, "sideOffset", 0, 0);
  let alignOffset = prop($$props, "alignOffset", 0, 0);
  let collisionPadding = prop($$props, "collisionPadding", 0, 8);
  let avoidCollisions = prop($$props, "avoidCollisions", 0, true);
  let collisionBoundary = prop($$props, "collisionBoundary", 8, () => void 0);
  let sameWidth = prop($$props, "sameWidth", 0, false);
  let fitViewport = prop($$props, "fitViewport", 0, false);
  let strategy = prop($$props, "strategy", 0, "absolute");
  let overlap = prop($$props, "overlap", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const {
    elements: { content },
    states: { open },
    ids,
    getAttrs: getAttrs2
  } = getCtx29();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("content");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.content.set(id());
    }
  });
  legacy_pre_effect(() => $content(), () => {
    set(builder, $content());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect(
    () => ($open(), deep_read_state(side()), deep_read_state(align()), deep_read_state(sideOffset()), deep_read_state(alignOffset()), deep_read_state(collisionPadding()), deep_read_state(avoidCollisions()), deep_read_state(collisionBoundary()), deep_read_state(sameWidth()), deep_read_state(fitViewport()), deep_read_state(strategy()), deep_read_state(overlap())),
    () => {
      if ($open()) {
        updatePositioning10({
          side: side(),
          align: align(),
          sideOffset: sideOffset(),
          alignOffset: alignOffset(),
          collisionPadding: collisionPadding(),
          avoidCollisions: avoidCollisions(),
          collisionBoundary: collisionBoundary(),
          sameWidth: sameWidth(),
          fitViewport: fitViewport(),
          strategy: strategy(),
          overlap: overlap()
        });
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => asChild() && $open(),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      if_block(
        node_2,
        () => transition2() && $open(),
        ($$anchor3) => {
          var div = root_332();
          bind_this(div, ($$value) => el($$value), () => el());
          transition(3, div, transition2, transitionConfig);
          let attributes;
          var node_3 = child(div);
          slot(
            node_3,
            default_slot($$props),
            {
              get builder() {
                return get2(builder);
              }
            },
            null
          );
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
          action(div, ($$node) => get2(builder).action($$node));
          event("m-pointerdown", div, dispatch, false);
          event("m-pointerenter", div, dispatch, false);
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          if_block(
            node_4,
            () => inTransition() && outTransition() && $open(),
            ($$anchor4) => {
              var div_1 = root_516();
              bind_this(div_1, ($$value) => el($$value), () => el());
              transition(1, div_1, inTransition, inTransitionConfig);
              transition(2, div_1, outTransition, outTransitionConfig);
              let attributes_1;
              var node_5 = child(div_1);
              slot(
                node_5,
                default_slot($$props),
                {
                  get builder() {
                    return get2(builder);
                  }
                },
                null
              );
              reset(div_1);
              template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get2(builder), ...$$restProps }, true, ""));
              action(div_1, ($$node) => get2(builder).action($$node));
              event("m-pointerdown", div_1, dispatch, false);
              event("m-pointerenter", div_1, dispatch, false);
              append($$anchor4, div_1);
            },
            ($$anchor4) => {
              var fragment_4 = comment();
              var node_6 = first_child(fragment_4);
              if_block(
                node_6,
                () => inTransition() && $open(),
                ($$anchor5) => {
                  var div_2 = root_716();
                  bind_this(div_2, ($$value) => el($$value), () => el());
                  transition(1, div_2, inTransition, inTransitionConfig);
                  let attributes_2;
                  var node_7 = child(div_2);
                  slot(
                    node_7,
                    default_slot($$props),
                    {
                      get builder() {
                        return get2(builder);
                      }
                    },
                    null
                  );
                  reset(div_2);
                  template_effect(() => attributes_2 = set_attributes(div_2, attributes_2, { ...get2(builder), ...$$restProps }, true, ""));
                  action(div_2, ($$node) => get2(builder).action($$node));
                  event("m-pointerdown", div_2, dispatch, false);
                  event("m-pointerenter", div_2, dispatch, false);
                  append($$anchor5, div_2);
                },
                ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_8 = first_child(fragment_5);
                  if_block(
                    node_8,
                    () => outTransition() && $open(),
                    ($$anchor6) => {
                      var div_3 = root_916();
                      bind_this(div_3, ($$value) => el($$value), () => el());
                      transition(2, div_3, outTransition, outTransitionConfig);
                      let attributes_3;
                      var node_9 = child(div_3);
                      slot(
                        node_9,
                        default_slot($$props),
                        {
                          get builder() {
                            return get2(builder);
                          }
                        },
                        null
                      );
                      reset(div_3);
                      template_effect(() => attributes_3 = set_attributes(div_3, attributes_3, { ...get2(builder), ...$$restProps }, true, ""));
                      action(div_3, ($$node) => get2(builder).action($$node));
                      event("m-pointerdown", div_3, dispatch, false);
                      event("m-pointerenter", div_3, dispatch, false);
                      append($$anchor6, div_3);
                    },
                    ($$anchor6) => {
                      var fragment_6 = comment();
                      var node_10 = first_child(fragment_6);
                      if_block(
                        node_10,
                        $open,
                        ($$anchor7) => {
                          var div_4 = root_1116();
                          bind_this(div_4, ($$value) => el($$value), () => el());
                          let attributes_4;
                          var node_11 = child(div_4);
                          slot(
                            node_11,
                            default_slot($$props),
                            {
                              get builder() {
                                return get2(builder);
                              }
                            },
                            null
                          );
                          reset(div_4);
                          template_effect(() => attributes_4 = set_attributes(div_4, attributes_4, { ...get2(builder), ...$$restProps }, true, ""));
                          action(div_4, ($$node) => get2(builder).action($$node));
                          event("m-pointerdown", div_4, dispatch, false);
                          event("m-pointerenter", div_4, dispatch, false);
                          append($$anchor7, div_4);
                        },
                        null,
                        true
                      );
                      append($$anchor6, fragment_6);
                    },
                    true
                  );
                  append($$anchor5, fragment_5);
                },
                true
              );
              append($$anchor4, fragment_4);
            },
            true
          );
          append($$anchor3, fragment_3);
        },
        true
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Tooltip_content);
  const filename = Tooltip_content.filename;
  const $$original = Tooltip_content;
  Tooltip_content = hmr(s);
  Tooltip_content.filename = filename;
  Tooltip_content[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var tooltip_content_default = Tooltip_content;
mark_module_end(Tooltip_content);

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-trigger.svelte
mark_module_start();
Tooltip_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-trigger.svelte";
var root_2146 = add_locations(template(`<button><!></button>`), Tooltip_trigger[FILENAME], [[27, 1]]);
function Tooltip_trigger($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push($$props, false, Tooltip_trigger);
  const $$stores = setup_stores();
  const $trigger = () => (validate_store(trigger, "trigger"), store_get(trigger, "$trigger", $$stores));
  const builder = mutable_source();
  let asChild = prop($$props, "asChild", 0, false);
  let id = prop($$props, "id", 8, () => void 0);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { trigger }, ids, getAttrs: getAttrs2 } = getCtx29();
  const dispatch = createDispatcher();
  const attrs = getAttrs2("trigger");
  legacy_pre_effect(() => deep_read_state(id()), () => {
    if (id()) {
      ids.trigger.set(id());
    }
  });
  legacy_pre_effect(() => $trigger(), () => {
    set(builder, $trigger());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_2146();
      bind_this(button, ($$value) => el($$value), () => el());
      let attributes;
      var node_2 = child(button);
      slot(
        node_2,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      reset(button);
      template_effect(() => attributes = set_attributes(
        button,
        attributes,
        {
          ...get2(builder),
          type: "button",
          ...$$restProps
        },
        true,
        ""
      ));
      action(button, ($$node) => get2(builder).action($$node));
      event("m-blur", button, dispatch, false);
      event("m-focus", button, dispatch, false);
      event("m-keydown", button, dispatch, false);
      event("m-pointerdown", button, dispatch, false);
      event("m-pointerenter", button, dispatch, false);
      event("m-pointerleave", button, dispatch, false);
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Tooltip_trigger);
  const filename = Tooltip_trigger.filename;
  const $$original = Tooltip_trigger;
  Tooltip_trigger = hmr(s);
  Tooltip_trigger.filename = filename;
  Tooltip_trigger[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var tooltip_trigger_default = Tooltip_trigger;
mark_module_end(Tooltip_trigger);

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-arrow.svelte
mark_module_start();
Tooltip_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-arrow.svelte";
var root_2147 = add_locations(template(`<div></div>`), Tooltip_arrow[FILENAME], [[20, 1]]);
function Tooltip_arrow($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["size", "asChild", "el"]);
  push($$props, false, Tooltip_arrow);
  const $$stores = setup_stores();
  const $arrow = () => (validate_store(arrow2, "arrow"), store_get(arrow2, "$arrow", $$stores));
  const builder = mutable_source();
  let size2 = prop($$props, "size", 0, 8);
  let asChild = prop($$props, "asChild", 0, false);
  let el = prop($$props, "el", 12, () => void 0);
  const { elements: { arrow: arrow2 }, getAttrs: getAttrs2 } = setArrow6(size2());
  const attrs = getAttrs2("arrow");
  legacy_pre_effect(() => $arrow(), () => {
    set(builder, $arrow());
  });
  legacy_pre_effect(() => get2(builder), () => {
    Object.assign(get2(builder), attrs);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    asChild,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        default_slot($$props),
        {
          get builder() {
            return get2(builder);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2147();
      bind_this(div, ($$value) => el($$value), () => el());
      let attributes;
      template_effect(() => attributes = set_attributes(div, attributes, { ...get2(builder), ...$$restProps }, true, ""));
      action(div, ($$node) => get2(builder).action($$node));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  const s = source(Tooltip_arrow);
  const filename = Tooltip_arrow.filename;
  const $$original = Tooltip_arrow;
  Tooltip_arrow = hmr(s);
  Tooltip_arrow.filename = filename;
  Tooltip_arrow[ORIGINAL] = $$original;
  import.meta.hot.accept((module) => {
    set(s, module.default[ORIGINAL]);
  });
}
var tooltip_arrow_default = Tooltip_arrow;
mark_module_end(Tooltip_arrow);
export {
  accordion_exports as Accordion,
  alert_dialog_exports as AlertDialog,
  aspect_ratio_exports as AspectRatio,
  avatar_exports as Avatar,
  button_exports as Button,
  calendar_exports as Calendar,
  checkbox_exports as Checkbox,
  collapsible_exports as Collapsible,
  combobox_exports as Combobox,
  context_menu_exports as ContextMenu,
  date_field_exports as DateField,
  date_picker_exports as DatePicker,
  date_range_field_exports as DateRangeField,
  date_range_picker_exports as DateRangePicker,
  dialog_exports as Dialog,
  dropdown_menu_exports as DropdownMenu,
  label_exports as Label,
  link_preview_exports as LinkPreview,
  menubar_exports as Menubar,
  pagination_exports as Pagination,
  pin_input_exports as PinInput,
  popover_exports as Popover,
  progress_exports as Progress,
  radio_group_exports as RadioGroup,
  range_calendar_exports as RangeCalendar,
  scroll_area_exports as ScrollArea,
  select_exports as Select,
  separator_exports as Separator,
  slider_exports as Slider,
  switch_exports as Switch,
  tabs_exports as Tabs,
  toggle_exports as Toggle,
  toggle_group_exports as ToggleGroup,
  toolbar_exports as Toolbar,
  tooltip_exports as Tooltip,
  builderActions,
  getAttrs
};
//# sourceMappingURL=bits-ui.js.map
